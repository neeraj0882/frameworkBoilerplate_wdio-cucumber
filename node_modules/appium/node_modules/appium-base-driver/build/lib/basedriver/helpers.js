'use strict';

var _extends = require('babel-runtime/helpers/extends')['default'];

var _defineProperty = require('babel-runtime/helpers/define-property')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _teen_process = require('teen_process');

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

var ZIP_EXTS = ['.zip', '.ipa'];
var ZIP_MIME_TYPE = 'application/zip';
var DOWNLOADS_CACHE = {};

function getModificationDate(url) {
  var response, value;
  return _regeneratorRuntime.async(function getModificationDate$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        response = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_request2['default'].head(url));

      case 4:
        response = context$1$0.sent;
        context$1$0.next = 11;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].debug('Cannot send HEAD request to \'' + url + '\'. Original error: ' + context$1$0.t0.message);
        return context$1$0.abrupt('return', null);

      case 11:
        value = response.headers['Last-Modified'];

        _logger2['default'].debug('Got \'' + value + '\' as \'Last-Modified\' HEAD response header value of \'' + url + '\'');
        return context$1$0.abrupt('return', value ? new Date(value) : null);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
}

function getCachedApplicationPath(url) {
  var appInfo, lastModified, fullPath, currentModified;
  return _regeneratorRuntime.async(function getCachedApplicationPath$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        appInfo = DOWNLOADS_CACHE[url];

        if (appInfo) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt('return', null);

      case 3:
        lastModified = appInfo.lastModified;
        fullPath = appInfo.fullPath;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(getModificationDate(url));

      case 7:
        currentModified = context$1$0.sent;

        if (currentModified) {
          context$1$0.next = 10;
          break;
        }

        return context$1$0.abrupt('return', null);

      case 10:
        if (!(currentModified <= lastModified)) {
          context$1$0.next = 13;
          break;
        }

        _logger2['default'].debug('\'Last-Modified\' response header value of \'' + url + '\' is less or equal in comparison to the ' + ('cached value \'' + lastModified + '\''));
        return context$1$0.abrupt('return', fullPath);

      case 13:
        _logger2['default'].debug('\'Last-Modified\' response header value of \'' + url + '\' is greater in comparison to the ' + ('cached value \'' + lastModified + '\''));
        return context$1$0.abrupt('return', null);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function configureApp(app, appExt) {
  var mountRoot = arguments.length <= 2 || arguments[2] === undefined ? "Volumes" : arguments[2];
  var windowsShareUserName = arguments.length <= 3 || arguments[3] === undefined ? "" : arguments[3];
  var windowsSharePassword = arguments.length <= 4 || arguments[4] === undefined ? "" : arguments[4];

  var newApp, shouldUnzipApp, _url$parse, protocol, isUrl, cachedPath, _ref, targetPath, contentType, errorMessage, archivePath, lastModified;

  return _regeneratorRuntime.async(function configureApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (_lodash2['default'].isString(app)) {
          context$1$0.next = 2;
          break;
        }

        return context$1$0.abrupt('return');

      case 2:
        newApp = app;
        shouldUnzipApp = false;
        _url$parse = _url2['default'].parse(newApp);
        protocol = _url$parse.protocol;
        isUrl = ['http:', 'https:'].includes(protocol);

        if (!newApp.startsWith('\\\\')) {
          context$1$0.next = 19;
          break;
        }

        // Use the app from Windows network share
        _logger2['default'].info('Downloading the application \'' + newApp + '\' from SMB share...');
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(copyFromWindowsNetworkShare(newApp, appExt, mountRoot, windowsShareUserName, windowsSharePassword));

      case 11:
        newApp = context$1$0.sent;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(newApp));

      case 14:
        if (context$1$0.sent) {
          context$1$0.next = 16;
          break;
        }

        throw new Error('The application at \'' + app + '\' does not exist or is not accessible for download');

      case 16:
        _logger2['default'].info('Downloaded the app to \'' + newApp + '\'');
        context$1$0.next = 60;
        break;

      case 19:
        if (!isUrl) {
          context$1$0.next = 42;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(getCachedApplicationPath(newApp));

      case 22:
        cachedPath = context$1$0.sent;

        if (!cachedPath) {
          context$1$0.next = 31;
          break;
        }

        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(cachedPath));

      case 26:
        if (!context$1$0.sent) {
          context$1$0.next = 29;
          break;
        }

        _logger2['default'].info('Reusing the previously downloaded application at \'' + cachedPath + '\'');
        return context$1$0.abrupt('return', cachedPath);

      case 29:
        _logger2['default'].info('The application at \'' + cachedPath + '\' does not exist anymore. Deleting it from the cache');
        delete DOWNLOADS_CACHE[newApp];

      case 31:
        _logger2['default'].info('Using downloadable app \'' + newApp + '\'');
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap(downloadApp(newApp, appExt));

      case 34:
        _ref = context$1$0.sent;
        targetPath = _ref.targetPath;
        contentType = _ref.contentType;

        newApp = targetPath;
        // the filetype may not be obvious for certain urls, so check the mime type too
        shouldUnzipApp = _lodash2['default'].includes(ZIP_EXTS, _path2['default'].extname(newApp)) || contentType === ZIP_MIME_TYPE;
        _logger2['default'].info('Downloaded the app to \'' + newApp + '\'');
        context$1$0.next = 60;
        break;

      case 42:
        context$1$0.next = 44;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(newApp));

      case 44:
        if (!context$1$0.sent) {
          context$1$0.next = 57;
          break;
        }

        // Use the local app
        _logger2['default'].info('Using local app \'' + newApp + '\'');
        shouldUnzipApp = _lodash2['default'].includes(ZIP_EXTS, _path2['default'].extname(newApp));

        if (!shouldUnzipApp) {
          context$1$0.next = 53;
          break;
        }

        context$1$0.next = 50;
        return _regeneratorRuntime.awrap(copyLocalZip(newApp));

      case 50:
        context$1$0.t0 = context$1$0.sent;
        context$1$0.next = 54;
        break;

      case 53:
        context$1$0.t0 = newApp;

      case 54:
        newApp = context$1$0.t0;
        context$1$0.next = 60;
        break;

      case 57:
        errorMessage = 'The application at \'' + newApp + '\' does not exist or is not accessible';

        // protocol value for 'C:\\temp' is 'c:', so we check the length as well
        if (_lodash2['default'].isString(protocol) && protocol.length > 2) {
          errorMessage = 'The protocol \'' + protocol + '\' used in \'' + newApp + '\' is not supported. ' + 'Only http: and https: protocols are supported';
        }
        throw new Error(errorMessage);

      case 60:
        if (!shouldUnzipApp) {
          context$1$0.next = 72;
          break;
        }

        _logger2['default'].info('Unzipping local app \'' + newApp + '\'...');
        archivePath = newApp;
        context$1$0.prev = 63;
        context$1$0.next = 66;
        return _regeneratorRuntime.awrap(unzipApp(archivePath, appExt));

      case 66:
        newApp = context$1$0.sent;

      case 67:
        context$1$0.prev = 67;
        context$1$0.next = 70;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(archivePath));

      case 70:
        return context$1$0.finish(67);

      case 71:
        _logger2['default'].info('Unzipped local app to \'' + newApp + '\'');

      case 72:
        if (!(_path2['default'].extname(newApp) !== appExt)) {
          context$1$0.next = 77;
          break;
        }

        if (!(newApp !== app)) {
          context$1$0.next = 76;
          break;
        }

        context$1$0.next = 76;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(newApp));

      case 76:
        throw new Error('New app path \'' + newApp + '\' did not have extension \'' + appExt + '\'');

      case 77:
        if (!isUrl) {
          context$1$0.next = 82;
          break;
        }

        context$1$0.next = 80;
        return _regeneratorRuntime.awrap(getModificationDate(app));

      case 80:
        lastModified = context$1$0.sent;

        if (lastModified) {
          DOWNLOADS_CACHE[_url2['default']] = {
            lastModified: lastModified,
            fullPath: newApp
          };
        } else {
          _logger2['default'].info('Skipping \'' + app + '\' caching, because the HEAD response didn\'t return' + ' any valid Last-Modified headers');
        }

      case 82:
        return context$1$0.abrupt('return', newApp);

      case 83:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[63,, 67, 71]]);
}

function downloadApp(app, appExt) {
  var appUrl, isZipFile, downloadedApp;
  return _regeneratorRuntime.async(function downloadApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        appUrl = undefined;
        context$1$0.prev = 1;

        appUrl = _url2['default'].parse(app);
        context$1$0.next = 8;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](1);
        throw new Error('Invalid App URL (' + app + ')');

      case 8:
        isZipFile = _lodash2['default'].includes(ZIP_EXTS, _path2['default'].extname(appUrl.pathname));

        appExt = isZipFile ? '.zip' : appExt;

        downloadedApp = undefined;
        context$1$0.prev = 11;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(downloadFile(_url2['default'].format(appUrl), appExt));

      case 14:
        downloadedApp = context$1$0.sent;
        context$1$0.next = 20;
        break;

      case 17:
        context$1$0.prev = 17;
        context$1$0.t1 = context$1$0['catch'](11);
        throw new Error('Problem downloading app from url ' + app + ': ' + context$1$0.t1);

      case 20:
        return context$1$0.abrupt('return', downloadedApp);

      case 21:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 5], [11, 17]]);
}

function downloadFile(sourceUrl, suffix) {
  var targetPath, contentType;
  return _regeneratorRuntime.async(function downloadFile$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({ prefix: 'appium-app', suffix: suffix }));

      case 2:
        targetPath = context$1$0.sent;
        contentType = undefined;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
          (0, _request2['default'])(sourceUrl).on('error', reject) // handle real errors, like connection errors
          .on('response', function (res) {
            // handle responses that fail, like 404s
            if (res.statusCode >= 400) {
              reject('Error downloading file: ' + res.statusCode);
            }
            contentType = res.headers['content-type'];
          }).pipe(_fs3['default'].createWriteStream(targetPath)).on('error', reject).on('close', resolve);
        }));

      case 6:
        _logger2['default'].debug(sourceUrl + ' downloaded to ' + targetPath);
        _logger2['default'].debug('Downloaded file type \'' + contentType + '\'');
        return context$1$0.abrupt('return', { targetPath: targetPath, contentType: contentType });

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function copyLocalZip(localZipPath) {
  var fileInfo, infile, outfile;
  return _regeneratorRuntime.async(function copyLocalZip$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Copying local zip to tmp dir');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(localZipPath));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Local zip did not exist');

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.open({ prefix: 'appium-app', suffix: '.zip' }));

      case 7:
        fileInfo = context$1$0.sent;
        infile = _fs3['default'].createReadStream(localZipPath);
        outfile = _fs3['default'].createWriteStream(fileInfo.path);
        return context$1$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
          infile.pipe(outfile).on('close', function () {
            resolve(fileInfo.path);
          }).on('error', function (err) {
            // eslint-disable-line promise/prefer-await-to-callbacks
            reject(err);
          });
        }));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function unzipApp(zipPath, appExt) {
  var _ref2,
  // first delete any existing apps that might be in our tmp dir
  stdout, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, output, relaxedRegStr, strictReg, relaxedReg, strictMatch, relaxedMatch, getAppPath;

  return _regeneratorRuntime.async(function unzipApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('find', [_path2['default'].dirname(zipPath), '-type', 'd', '-name', '*' + appExt]));

      case 2:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 7;
        _iterator = _getIterator(stdout.trim().split('\n').filter(Boolean));

      case 9:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 16;
          break;
        }

        line = _step.value;
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(line));

      case 13:
        _iteratorNormalCompletion = true;
        context$1$0.next = 9;
        break;

      case 16:
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](7);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 22:
        context$1$0.prev = 22;
        context$1$0.prev = 23;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 25:
        context$1$0.prev = 25;

        if (!_didIteratorError) {
          context$1$0.next = 28;
          break;
        }

        throw _iteratorError;

      case 28:
        return context$1$0.finish(25);

      case 29:
        return context$1$0.finish(22);

      case 30:
        context$1$0.next = 32;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(_path2['default'].resolve(_path2['default'].dirname(zipPath), 'Payload*')));

      case 32:
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap(unzipFile(zipPath));

      case 34:
        output = context$1$0.sent;
        relaxedRegStr = '(?:creating|inflating|extracting): (.+' + appExt + ')/?';
        strictReg = new RegExp(relaxedRegStr + '$', 'm');
        relaxedReg = new RegExp(relaxedRegStr, 'm');
        strictMatch = strictReg.exec(output);
        relaxedMatch = relaxedReg.exec(output);

        getAppPath = function getAppPath(match) {
          return _path2['default'].resolve(_path2['default'].dirname(zipPath), match[1]);
        };

        if (!strictMatch) {
          context$1$0.next = 43;
          break;
        }

        return context$1$0.abrupt('return', getAppPath(strictMatch));

      case 43:
        if (!relaxedMatch) {
          context$1$0.next = 46;
          break;
        }

        _logger2['default'].debug('Got a relaxed match for app in zip, be careful for app match errors');
        return context$1$0.abrupt('return', getAppPath(relaxedMatch));

      case 46:
        throw new Error('App zip unzipped OK, but we could not find a ' + appExt + ' bundle ' + ('in it. Make sure your archive contains the ' + appExt + ' package ') + 'and nothing else');

      case 47:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 18, 22, 30], [23,, 25, 29]]);
}

function unzipFile(zipPath) {
  var valid, execEnv, execOpts, _ref3, stdout;

  return _regeneratorRuntime.async(function unzipFile$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Unzipping ' + zipPath);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(testZipArchive(zipPath));

      case 3:
        valid = context$1$0.sent;

        if (valid) {
          context$1$0.next = 6;
          break;
        }

        throw new Error('Zip archive ' + zipPath + ' did not test valid');

      case 6:
        if (!_appiumSupport.system.isWindows()) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.zip.extractAllTo(zipPath, _path2['default'].dirname(zipPath)));

      case 9:
        _logger2['default'].debug('Unzip successful');
        return context$1$0.abrupt('return');

      case 11:
        execEnv = _lodash2['default'].clone(process.env);

        delete execEnv.UNZIP;
        execOpts = { cwd: _path2['default'].dirname(zipPath), env: execEnv };
        context$1$0.prev = 14;
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('unzip', ['-o', zipPath], execOpts));

      case 17:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;
        return context$1$0.abrupt('return', stdout);

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](14);

        _logger2['default'].error('Unzip threw error ' + context$1$0.t0);
        _logger2['default'].error('Stderr: ' + context$1$0.t0.stderr);
        _logger2['default'].error('Stdout: ' + context$1$0.t0.stdout);
        throw new Error('Archive could not be unzipped, check appium logs.');

      case 28:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[14, 22]]);
}

function testZipArchive(zipPath) {
  var execEnv, execOpts, output;
  return _regeneratorRuntime.async(function testZipArchive$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Testing zip archive: ' + zipPath);

        if (!_appiumSupport.system.isWindows()) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(zipPath));

      case 4:
        if (!context$1$0.sent) {
          context$1$0.next = 9;
          break;
        }

        _logger2['default'].debug('Zip archive tested clean');
        return context$1$0.abrupt('return', true);

      case 9:
        _logger2['default'].debug('Zip archive not found');
        return context$1$0.abrupt('return', false);

      case 11:
        execEnv = _lodash2['default'].clone(process.env);

        delete execEnv.UNZIP;
        execOpts = { cwd: _path2['default'].dirname(zipPath), env: execEnv };
        output = undefined;
        context$1$0.prev = 15;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('unzip', ['-tq', zipPath], execOpts));

      case 18:
        output = context$1$0.sent;

        if (!/No errors detected/.exec(output.stdout)) {
          context$1$0.next = 21;
          break;
        }

        return context$1$0.abrupt('return', true);

      case 21:
        _logger2['default'].error('Zip file ' + zipPath + ' was not valid');
        _logger2['default'].error('Stderr: ' + output.stderr);
        _logger2['default'].error('Stdout: ' + output.stdout);
        _logger2['default'].error('Zip archive did not test successfully, check appium server ' + 'logs for output');
        return context$1$0.abrupt('return', false);

      case 28:
        context$1$0.prev = 28;
        context$1$0.t0 = context$1$0['catch'](15);

        _logger2['default'].error('Test zip archive threw error ' + context$1$0.t0);
        _logger2['default'].error('Stderr: ' + context$1$0.t0.stderr);
        _logger2['default'].error('Stdout: ' + context$1$0.t0.stdout);
        throw new Error('Error testing zip archive, are you sure this is a zip file?');

      case 34:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[15, 28]]);
}

function copyFromWindowsNetworkShare(app, appExt, mountRoot, windowsUserName, windowsPassword) {
  return _regeneratorRuntime.async(function copyFromWindowsNetworkShare$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!_appiumSupport.system.isWindows()) {
          context$1$0.next = 6;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(copyLocallyFromWindowsShare(app, appExt));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(mountWindowsShareOnMac(app, mountRoot, windowsUserName, windowsPassword));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function mountWindowsShareOnMac(app, mountRoot, windowsUserName, windowsPassword) {
  var pathSplit, networkShare, rootFolder, mountPath, mountNetworkShare, umountArgs;
  return _regeneratorRuntime.async(function mountWindowsShareOnMac$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        pathSplit = app.split("\\");
        networkShare = pathSplit[2];
        rootFolder = pathSplit[3];

        app = app.replace(/\\/g, "/");
        app = app.replace('/' + networkShare, mountRoot);
        mountPath = '/' + mountRoot + '/' + rootFolder;

        mountNetworkShare = function mountNetworkShare() {
          var mountArgs;
          return _regeneratorRuntime.async(function mountNetworkShare$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(_appiumSupport.fs.mkdir(mountPath));

              case 2:
                mountArgs = ['-t', 'smbfs', '//' + windowsUserName + ':' + windowsPassword + '@' + networkShare + '/' + rootFolder, mountPath];
                context$2$0.prev = 3;
                context$2$0.next = 6;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('mount', mountArgs));

              case 6:
                context$2$0.next = 11;
                break;

              case 8:
                context$2$0.prev = 8;
                context$2$0.t0 = context$2$0['catch'](3);

                _logger2['default'].errorAndThrow('Error mounting: ' + context$2$0.t0.message);

              case 11:
              case 'end':
                return context$2$0.stop();
            }
          }, null, this, [[3, 8]]);
        };

        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(mountPath));

      case 9:
        if (!context$1$0.sent) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(app));

      case 12:
        if (!context$1$0.sent) {
          context$1$0.next = 14;
          break;
        }

        return context$1$0.abrupt('return', app);

      case 14:
        umountArgs = [mountPath];
        context$1$0.prev = 15;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('umount', umountArgs));

      case 18:
        context$1$0.next = 23;
        break;

      case 20:
        context$1$0.prev = 20;
        context$1$0.t0 = context$1$0['catch'](15);

        _logger2['default'].error('Error Unmounting :' + context$1$0.t0.message);

      case 23:
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(mountRoot));

      case 25:
        context$1$0.next = 27;
        return _regeneratorRuntime.awrap(mountNetworkShare());

      case 27:
        return context$1$0.abrupt('return', app);

      case 28:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[15, 20]]);
}

function copyLocallyFromWindowsShare(app, appExt) {
  var fileInfo;
  return _regeneratorRuntime.async(function copyLocallyFromWindowsShare$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.open({ prefix: 'appium-app', suffix: appExt }));

      case 2:
        fileInfo = context$1$0.sent;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.copyFile(app, fileInfo.path));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function isPackageOrBundle(app) {
  return (/^([a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)+$/.test(app)
  );
}

function getCoordDefault(val) {
  // going the long way and checking for undefined and null since
  // we can't be assured `elId` is a string and not an int. Same
  // thing with destElement below.
  return _appiumSupport.util.hasValue(val) ? val : 0.5;
}

function getSwipeTouchDuration(waitGesture) {
  // the touch action api uses ms, we want seconds
  // 0.8 is the default time for the operation
  var duration = 0.8;
  if (typeof waitGesture.options.ms !== 'undefined' && waitGesture.options.ms) {
    duration = waitGesture.options.ms / 1000;
    if (duration === 0) {
      // set to a very low number, since they wanted it fast
      // but below 0.1 becomes 0 steps, which causes errors
      duration = 0.1;
    }
  }
  return duration;
}

/**
 * Recursively find all instances of the key 'inKey' and rename them 'outKey'
 * @param {*} input Any type of input
 * @param {String} inKey The key name to replace
 * @param {String} outKey The key name to replace it with
 */
function renameKey(input, inKey, outKey) {
  if (_lodash2['default'].isArray(input)) {
    return input.map(function (item) {
      return renameKey(item, inKey, outKey);
    });
  } else if (_lodash2['default'].isPlainObject(input)) {
    return _lodash2['default'].reduce(input, function (resultObj, value, key) {
      return _extends({}, resultObj, _defineProperty({}, key === inKey ? outKey : key, renameKey(value, inKey, outKey)));
    }, {});
  }

  return input;
}

exports['default'] = { configureApp: configureApp, downloadApp: downloadApp, downloadFile: downloadFile, copyLocalZip: copyLocalZip,
  unzipApp: unzipApp, unzipFile: unzipFile, testZipArchive: testZipArchive, isPackageOrBundle: isPackageOrBundle,
  getCoordDefault: getCoordDefault, getSwipeTouchDuration: getSwipeTouchDuration, copyFromWindowsNetworkShare: copyFromWindowsNetworkShare, renameKey: renameKey };
module.exports = exports['default'];

// immediately shortcircuit if not given an app

// Use the app from remote URL

// check if this is zipped

// We will be downloading the files to a directory, so make sure it's there
// This step is not required if you have manually created the directory

// don't use request-promise here, we need streams

// now delete any existing zip payload

// in the strict regex, we check for an entry which ends with the
// extension

// otherwise, we allow an entry which contains the extension, but we
// need to be careful, because it might be a false positive
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2hlbHBlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7O29CQUNMLE1BQU07Ozs7bUJBQ1AsS0FBSzs7OztzQkFDRixVQUFVOzs7O21CQUNiLElBQUk7Ozs7d0JBQ04sVUFBVTs7Ozs2QkFDdUIsZ0JBQWdCOzs0QkFDMUMsY0FBYzs7dUJBQ2YsU0FBUzs7OztBQUU3QixJQUFNLFFBQVEsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztBQUNsQyxJQUFNLGFBQWEsR0FBRyxpQkFBaUIsQ0FBQztBQUN4QyxJQUFNLGVBQWUsR0FBRyxFQUFFLENBQUM7O0FBRTNCLFNBQWUsbUJBQW1CLENBQUUsR0FBRztNQUNqQyxRQUFRLEVBT04sS0FBSzs7OztBQVBQLGdCQUFROzs7eUNBRU8scUJBQVEsSUFBSSxDQUFDLEdBQUcsQ0FBQzs7O0FBQWxDLGdCQUFROzs7Ozs7OztBQUVSLDRCQUFPLEtBQUssb0NBQWlDLEdBQUcsNEJBQXNCLGVBQUUsT0FBTyxDQUFHLENBQUM7NENBQzVFLElBQUk7OztBQUVQLGFBQUssR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQzs7QUFDL0MsNEJBQU8sS0FBSyxZQUFTLEtBQUssZ0VBQXVELEdBQUcsUUFBSSxDQUFDOzRDQUNsRixLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSTs7Ozs7OztDQUN0Qzs7QUFFRCxTQUFlLHdCQUF3QixDQUFFLEdBQUc7TUFDcEMsT0FBTyxFQUlOLFlBQVksRUFBRSxRQUFRLEVBQ3ZCLGVBQWU7Ozs7QUFMZixlQUFPLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQzs7WUFDL0IsT0FBTzs7Ozs7NENBQ0gsSUFBSTs7O0FBRU4sb0JBQVksR0FBYyxPQUFPLENBQWpDLFlBQVk7QUFBRSxnQkFBUSxHQUFJLE9BQU8sQ0FBbkIsUUFBUTs7eUNBQ0MsbUJBQW1CLENBQUMs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RyxDQUFDO0tBQ2hCO0dBQ0Y7QUFDRCxTQUFPLFFBQVEsQ0FBQztDQUNqQjs7Ozs7Ozs7QUFTRCxTQUFTLFNBQVMsQ0FBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUN4QyxNQUFJLG9CQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUNwQixXQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBQyxJQUFJO2FBQUssU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDO0tBQUEsQ0FBQyxDQUFDO0dBQzVELE1BQU0sSUFBSSxvQkFBRSxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDakMsV0FBTyxvQkFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLFVBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxHQUFHOzBCQUN4QyxTQUFTLHNCQUNYLEdBQUcsS0FBSyxLQUFLLEdBQUcsTUFBTSxHQUFHLEdBQUcsRUFBRyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUM7S0FDL0QsRUFBRSxFQUFFLENBQUMsQ0FBQztHQUNUOztBQUVELFNBQU8sS0FBSyxDQUFDO0NBQ2Q7O3FCQUVjLEVBQUUsWUFBWSxFQUFaLFlBQVksRUFBRSxXQUFXLEVBQVgsV0FBVyxFQUFFLFlBQVksRUFBWixZQUFZLEVBQUUsWUFBWSxFQUFaLFlBQVk7QUFDckQsVUFBUSxFQUFSLFFBQVEsRUFBRSxTQUFTLEVBQVQsU0FBUyxFQUFFLGNBQWMsRUFBZCxjQUFjLEVBQUUsaUJBQWlCLEVBQWpCLGlCQUFpQjtBQUN0RCxpQkFBZSxFQUFmLGVBQWUsRUFBRSxxQkFBcUIsRUFBckIscUJBQXFCLEVBQUUsMkJBQTJCLEVBQTNCLDJCQUEyQixFQUFFLFNBQVMsRUFBVCxTQUFTLEVBQUUiLCJmaWxlIjoibGliL2Jhc2Vkcml2ZXIvaGVscGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IF9mcyBmcm9tICdmcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyB0ZW1wRGlyLCBzeXN0ZW0sIGZzLCB1dGlsLCB6aXAgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCByZXF1ZXN0IGZyb20gJ3JlcXVlc3QnO1xuXG5jb25zdCBaSVBfRVhUUyA9IFsnLnppcCcsICcuaXBhJ107XG5jb25zdCBaSVBfTUlNRV9UWVBFID0gJ2FwcGxpY2F0aW9uL3ppcCc7XG5jb25zdCBET1dOTE9BRFNfQ0FDSEUgPSB7fTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZSAodXJsKSB7XG4gIGxldCByZXNwb25zZTtcbiAgdHJ5IHtcbiAgICByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuaGVhZCh1cmwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmRlYnVnKGBDYW5ub3Qgc2VuZCBIRUFEIHJlcXVlc3QgdG8gJyR7dXJsfScuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHJlc3BvbnNlLmhlYWRlcnNbJ0xhc3QtTW9kaWZpZWQnXTtcbiAgbG9nZ2VyLmRlYnVnKGBHb3QgJyR7dmFsdWV9JyBhcyAnTGFzdC1Nb2RpZmllZCcgSEVBRCByZXNwb25zZSBoZWFkZXIgdmFsdWUgb2YgJyR7dXJsfSdgKTtcbiAgcmV0dXJuIHZhbHVlID8gbmV3IERhdGUodmFsdWUpIDogbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGVkQXBwbGljYXRpb25QYXRoICh1cmwpIHtcbiAgY29uc3QgYXBwSW5mbyA9IERPV05MT0FEU19DQUNIRVt1cmxdO1xuICBpZiAoIWFwcEluZm8pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7bGFzdE1vZGlmaWVkLCBmdWxsUGF0aH0gPSBhcHBJbmZvO1xuICBjb25zdCBjdXJyZW50TW9kaWZpZWQgPSBhd2FpdCBnZXRNb2RpZmljYXRpb25EYXRlKHVybCk7XG4gIGlmICghY3VycmVudE1vZGlmaWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGN1cnJlbnRNb2RpZmllZCA8PSBsYXN0TW9kaWZpZWQpIHtcbiAgICBsb2dnZXIuZGVidWcoYCdMYXN0LU1vZGlmaWVkJyByZXNwb25zZSBoZWFkZXIgdmFsdWUgb2YgJyR7dXJsfScgaXMgbGVzcyBvciBlcXVhbCBpbiBjb21wYXJpc29uIHRvIHRoZSBgICtcbiAgICAgICAgICAgICAgICAgYGNhY2hlZCB2YWx1ZSAnJHtsYXN0TW9kaWZpZWR9J2ApO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuICBsb2dnZXIuZGVidWcoYCdMYXN0LU1vZGlmaWVkJyByZXNwb25zZSBoZWFkZXIgdmFsdWUgb2YgJyR7dXJsfScgaXMgZ3JlYXRlciBpbiBjb21wYXJpc29uIHRvIHRoZSBgICtcbiAgICAgICAgICAgICAgIGBjYWNoZWQgdmFsdWUgJyR7bGFzdE1vZGlmaWVkfSdgKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbmZpZ3VyZUFwcCAoYXBwLCBhcHBFeHQsIG1vdW50Um9vdD1cIlZvbHVtZXNcIiwgd2luZG93c1NoYXJlVXNlck5hbWU9XCJcIiwgd2luZG93c1NoYXJlUGFzc3dvcmQ9XCJcIikge1xuICBpZiAoIV8uaXNTdHJpbmcoYXBwKSkge1xuICAgIC8vIGltbWVkaWF0ZWx5IHNob3J0Y2lyY3VpdCBpZiBub3QgZ2l2ZW4gYW4gYXBwXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IG5ld0FwcCA9IGFwcDtcbiAgbGV0IHNob3VsZFVuemlwQXBwID0gZmFsc2U7XG4gIGNvbnN0IHtwcm90b2NvbH0gPSB1cmwucGFyc2UobmV3QXBwKTtcbiAgY29uc3QgaXNVcmwgPSBbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHByb3RvY29sKTtcblxuICBpZiAobmV3QXBwLnN0YXJ0c1dpdGgoJ1xcXFxcXFxcJykpIHtcbiAgICAvLyBVc2UgdGhlIGFwcCBmcm9tIFdpbmRvd3MgbmV0d29yayBzaGFyZVxuICAgIGxvZ2dlci5pbmZvKGBEb3dubG9hZGluZyB0aGUgYXBwbGljYXRpb24gJyR7bmV3QXBwfScgZnJvbSBTTUIgc2hhcmUuLi5gKTtcbiAgICBuZXdBcHAgPSBhd2FpdCBjb3B5RnJvbVdpbmRvd3NOZXR3b3JrU2hhcmUobmV3QXBwLCBhcHBFeHQsXG4gICAgICBtb3VudFJvb3QsIHdpbmRvd3NTaGFyZVVzZXJOYW1lLCB3aW5kb3dzU2hhcmVQYXNzd29yZCk7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMobmV3QXBwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgYXBwbGljYXRpb24gYXQgJyR7YXBwfScgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGFjY2Vzc2libGUgZm9yIGRvd25sb2FkYCk7XG4gICAgfVxuICAgIGxvZ2dlci5pbmZvKGBEb3dubG9hZGVkIHRoZSBhcHAgdG8gJyR7bmV3QXBwfSdgKTtcbiAgfSBlbHNlIGlmIChpc1VybCkge1xuICAgIC8vIFVzZSB0aGUgYXBwIGZyb20gcmVtb3RlIFVSTFxuICAgIGNvbnN0IGNhY2hlZFBhdGggPSBhd2FpdCBnZXRDYWNoZWRBcHBsaWNhdGlvblBhdGgobmV3QXBwKTtcbiAgICBpZiAoY2FjaGVkUGF0aCkge1xuICAgICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhjYWNoZWRQYXRoKSkge1xuICAgICAgICBsb2dnZXIuaW5mbyhgUmV1c2luZyB0aGUgcHJldmlvdXNseSBkb3dubG9hZGVkIGFwcGxpY2F0aW9uIGF0ICcke2NhY2hlZFBhdGh9J2ApO1xuICAgICAgICByZXR1cm4gY2FjaGVkUGF0aDtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5pbmZvKGBUaGUgYXBwbGljYXRpb24gYXQgJyR7Y2FjaGVkUGF0aH0nIGRvZXMgbm90IGV4aXN0IGFueW1vcmUuIERlbGV0aW5nIGl0IGZyb20gdGhlIGNhY2hlYCk7XG4gICAgICBkZWxldGUgRE9XTkxPQURTX0NBQ0hFW25ld0FwcF07XG4gICAgfVxuICAgIGxvZ2dlci5pbmZvKGBVc2luZyBkb3dubG9hZGFibGUgYXBwICcke25ld0FwcH0nYCk7XG4gICAgY29uc3Qge3RhcmdldFBhdGgsIGNvbnRlbnRUeXBlfSA9IGF3YWl0IGRvd25sb2FkQXBwKG5ld0FwcCwgYXBwRXh0KTtcbiAgICBuZXdBcHAgPSB0YXJnZXRQYXRoO1xuICAgIC8vIHRoZSBmaWxldHlwZSBtYXkgbm90IGJlIG9idmlvdXMgZm9yIGNlcnRhaW4gdXJscywgc28gY2hlY2sgdGhlIG1pbWUgdHlwZSB0b29cbiAgICBzaG91bGRVbnppcEFwcCA9IF8uaW5jbHVkZXMoWklQX0VYVFMsIHBhdGguZXh0bmFtZShuZXdBcHApKSB8fCBjb250ZW50VHlwZSA9PT0gWklQX01JTUVfVFlQRTtcbiAgICBsb2dnZXIuaW5mbyhgRG93bmxvYWRlZCB0aGUgYXBwIHRvICcke25ld0FwcH0nYCk7XG4gIH0gZWxzZSBpZiAoYXdhaXQgZnMuZXhpc3RzKG5ld0FwcCkpIHtcbiAgICAvLyBVc2UgdGhlIGxvY2FsIGFwcFxuICAgIGxvZ2dlci5pbmZvKGBVc2luZyBsb2NhbCBhcHAgJyR7bmV3QXBwfSdgKTtcbiAgICBzaG91bGRVbnppcEFwcCA9IF8uaW5jbHVkZXMoWklQX0VYVFMsIHBhdGguZXh0bmFtZShuZXdBcHApKTtcbiAgICBuZXdBcHAgPSBzaG91bGRVbnppcEFwcCA/IGF3YWl0IGNvcHlMb2NhbFppcChuZXdBcHApIDogbmV3QXBwO1xuICB9IGVsc2Uge1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgVGhlIGFwcGxpY2F0aW9uIGF0ICcke25ld0FwcH0nIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhY2Nlc3NpYmxlYDtcbiAgICAvLyBwcm90b2NvbCB2YWx1ZSBmb3IgJ0M6XFxcXHRlbXAnIGlzICdjOicsIHNvIHdlIGNoZWNrIHRoZSBsZW5ndGggYXMgd2VsbFxuICAgIGlmIChfLmlzU3RyaW5nKHByb3RvY29sKSAmJiBwcm90b2NvbC5sZW5ndGggPiAyKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgVGhlIHByb3RvY29sICcke3Byb3RvY29sfScgdXNlZCBpbiAnJHtuZXdBcHB9JyBpcyBub3Qgc3VwcG9ydGVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgIGBPbmx5IGh0dHA6IGFuZCBodHRwczogcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWRgO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIGlmIChzaG91bGRVbnppcEFwcCkge1xuICAgIGxvZ2dlci5pbmZvKGBVbnppcHBpbmcgbG9jYWwgYXBwICcke25ld0FwcH0nLi4uYCk7XG4gICAgY29uc3QgYXJjaGl2ZVBhdGggPSBuZXdBcHA7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0FwcCA9IGF3YWl0IHVuemlwQXBwKGFyY2hpdmVQYXRoLCBhcHBFeHQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBmcy5yaW1yYWYoYXJjaGl2ZVBhdGgpO1xuICAgIH1cbiAgICBsb2dnZXIuaW5mbyhgVW56aXBwZWQgbG9jYWwgYXBwIHRvICcke25ld0FwcH0nYCk7XG4gIH1cblxuICBpZiAocGF0aC5leHRuYW1lKG5ld0FwcCkgIT09IGFwcEV4dCkge1xuICAgIGlmIChuZXdBcHAgIT09IGFwcCkge1xuICAgICAgYXdhaXQgZnMucmltcmFmKG5ld0FwcCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTmV3IGFwcCBwYXRoICcke25ld0FwcH0nIGRpZCBub3QgaGF2ZSBleHRlbnNpb24gJyR7YXBwRXh0fSdgKTtcbiAgfVxuXG4gIGlmIChpc1VybCkge1xuICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IGF3YWl0IGdldE1vZGlmaWNhdGlvbkRhdGUoYXBwKTtcbiAgICBpZiAobGFzdE1vZGlmaWVkKSB7XG4gICAgICBET1dOTE9BRFNfQ0FDSEVbdXJsXSA9IHtcbiAgICAgICAgbGFzdE1vZGlmaWVkLFxuICAgICAgICBmdWxsUGF0aDogbmV3QXBwLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmluZm8oYFNraXBwaW5nICcke2FwcH0nIGNhY2hpbmcsIGJlY2F1c2UgdGhlIEhFQUQgcmVzcG9uc2UgZGlkbid0IHJldHVybmAgK1xuICAgICAgICAgICAgICAgICAgYCBhbnkgdmFsaWQgTGFzdC1Nb2RpZmllZCBoZWFkZXJzYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0FwcDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRBcHAgKGFwcCwgYXBwRXh0KSB7XG4gIGxldCBhcHBVcmw7XG4gIHRyeSB7XG4gICAgYXBwVXJsID0gdXJsLnBhcnNlKGFwcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBBcHAgVVJMICgke2FwcH0pYCk7XG4gIH1cblxuICAvLyBjaGVjayBpZiB0aGlzIGlzIHppcHBlZFxuICBsZXQgaXNaaXBGaWxlID0gXy5pbmNsdWRlcyhaSVBfRVhUUywgcGF0aC5leHRuYW1lKGFwcFVybC5wYXRobmFtZSkpO1xuICBhcHBFeHQgPSBpc1ppcEZpbGUgPyAnLnppcCcgOiBhcHBFeHQ7XG5cbiAgbGV0IGRvd25sb2FkZWRBcHA7XG4gIHRyeSB7XG4gICAgZG93bmxvYWRlZEFwcCA9IGF3YWl0IGRvd25sb2FkRmlsZSh1cmwuZm9ybWF0KGFwcFVybCksIGFwcEV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgUHJvYmxlbSBkb3dubG9hZGluZyBhcHAgZnJvbSB1cmwgJHthcHB9OiAke2Vycn1gKTtcbiAgfVxuXG4gIHJldHVybiBkb3dubG9hZGVkQXBwO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUgKHNvdXJjZVVybCwgc3VmZml4KSB7XG4gIC8vIFdlIHdpbGwgYmUgZG93bmxvYWRpbmcgdGhlIGZpbGVzIHRvIGEgZGlyZWN0b3J5LCBzbyBtYWtlIHN1cmUgaXQncyB0aGVyZVxuICAvLyBUaGlzIHN0ZXAgaXMgbm90IHJlcXVpcmVkIGlmIHlvdSBoYXZlIG1hbnVhbGx5IGNyZWF0ZWQgdGhlIGRpcmVjdG9yeVxuICBsZXQgdGFyZ2V0UGF0aCA9IGF3YWl0IHRlbXBEaXIucGF0aCh7cHJlZml4OiAnYXBwaXVtLWFwcCcsIHN1ZmZpeH0pO1xuICBsZXQgY29udGVudFR5cGU7XG5cbiAgLy8gZG9uJ3QgdXNlIHJlcXVlc3QtcHJvbWlzZSBoZXJlLCB3ZSBuZWVkIHN0cmVhbXNcbiAgYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3Qoc291cmNlVXJsKVxuICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCkgLy8gaGFuZGxlIHJlYWwgZXJyb3JzLCBsaWtlIGNvbm5lY3Rpb24gZXJyb3JzXG4gICAgICAub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBoYW5kbGUgcmVzcG9uc2VzIHRoYXQgZmFpbCwgbGlrZSA0MDRzXG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICByZWplY3QoYEVycm9yIGRvd25sb2FkaW5nIGZpbGU6ICR7cmVzLnN0YXR1c0NvZGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudFR5cGUgPSByZXMuaGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgICB9KVxuICAgICAgLnBpcGUoX2ZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRhcmdldFBhdGgpKVxuICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgIC5vbignY2xvc2UnLCByZXNvbHZlKTtcbiAgfSk7XG4gIGxvZ2dlci5kZWJ1ZyhgJHtzb3VyY2VVcmx9IGRvd25sb2FkZWQgdG8gJHt0YXJnZXRQYXRofWApO1xuICBsb2dnZXIuZGVidWcoYERvd25sb2FkZWQgZmlsZSB0eXBlICcke2NvbnRlbnRUeXBlfSdgKTtcbiAgcmV0dXJuIHt0YXJnZXRQYXRoLCBjb250ZW50VHlwZX07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlMb2NhbFppcCAobG9jYWxaaXBQYXRoKSB7XG4gIGxvZ2dlci5kZWJ1ZygnQ29weWluZyBsb2NhbCB6aXAgdG8gdG1wIGRpcicpO1xuICBpZiAoIShhd2FpdCBmcy5leGlzdHMobG9jYWxaaXBQYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsIHppcCBkaWQgbm90IGV4aXN0Jyk7XG4gIH1cbiAgbGV0IGZpbGVJbmZvID0gYXdhaXQgdGVtcERpci5vcGVuKHtwcmVmaXg6ICdhcHBpdW0tYXBwJywgc3VmZml4OiAnLnppcCd9KTtcbiAgbGV0IGluZmlsZSA9IF9mcy5jcmVhdGVSZWFkU3RyZWFtKGxvY2FsWmlwUGF0aCk7XG4gIGxldCBvdXRmaWxlID0gX2ZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGVJbmZvLnBhdGgpO1xuICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGluZmlsZS5waXBlKG91dGZpbGUpLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHJlc29sdmUoZmlsZUluZm8ucGF0aCk7XG4gICAgfSkub24oJ2Vycm9yJywgKGVycikgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLWNhbGxiYWNrc1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1bnppcEFwcCAoemlwUGF0aCwgYXBwRXh0KSB7XG4gIC8vIGZpcnN0IGRlbGV0ZSBhbnkgZXhpc3RpbmcgYXBwcyB0aGF0IG1pZ2h0IGJlIGluIG91ciB0bXAgZGlyXG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ2ZpbmQnLCBbcGF0aC5kaXJuYW1lKHppcFBhdGgpLCAnLXR5cGUnLCAnZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy1uYW1lJywgYCoke2FwcEV4dH1gXSk7XG4gIGZvciAobGV0IGxpbmUgb2Ygc3Rkb3V0LnRyaW0oKS5zcGxpdCgnXFxuJykuZmlsdGVyKEJvb2xlYW4pKSB7XG4gICAgYXdhaXQgZnMucmltcmFmKGxpbmUpO1xuICB9XG4gIC8vIG5vdyBkZWxldGUgYW55IGV4aXN0aW5nIHppcCBwYXlsb2FkXG4gIGF3YWl0IGZzLnJpbXJhZihwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHppcFBhdGgpLCAnUGF5bG9hZConKSk7XG4gIGxldCBvdXRwdXQgPSBhd2FpdCB1bnppcEZpbGUoemlwUGF0aCk7XG4gIGxldCByZWxheGVkUmVnU3RyID0gYCg/OmNyZWF0aW5nfGluZmxhdGluZ3xleHRyYWN0aW5nKTogKC4rJHthcHBFeHR9KS8/YDtcbiAgLy8gaW4gdGhlIHN0cmljdCByZWdleCwgd2UgY2hlY2sgZm9yIGFuIGVudHJ5IHdoaWNoIGVuZHMgd2l0aCB0aGVcbiAgLy8gZXh0ZW5zaW9uXG4gIGxldCBzdHJpY3RSZWcgPSBuZXcgUmVnRXhwKGAke3JlbGF4ZWRSZWdTdHJ9JGAsICdtJyk7XG4gIC8vIG90aGVyd2lzZSwgd2UgYWxsb3cgYW4gZW50cnkgd2hpY2ggY29udGFpbnMgdGhlIGV4dGVuc2lvbiwgYnV0IHdlXG4gIC8vIG5lZWQgdG8gYmUgY2FyZWZ1bCwgYmVjYXVzZSBpdCBtaWdodCBiZSBhIGZhbHNlIHBvc2l0aXZlXG4gIGxldCByZWxheGVkUmVnID0gbmV3IFJlZ0V4cChyZWxheGVkUmVnU3RyLCAnbScpO1xuICBsZXQgc3RyaWN0TWF0Y2ggPSBzdHJpY3RSZWcuZXhlYyhvdXRwdXQpO1xuICBsZXQgcmVsYXhlZE1hdGNoID0gcmVsYXhlZFJlZy5leGVjKG91dHB1dCk7XG4gIGxldCBnZXRBcHBQYXRoID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoemlwUGF0aCksIG1hdGNoWzFdKTtcbiAgfTtcblxuICBpZiAoc3RyaWN0TWF0Y2gpIHtcbiAgICByZXR1cm4gZ2V0QXBwUGF0aChzdHJpY3RNYXRjaCk7XG4gIH1cblxuICBpZiAocmVsYXhlZE1hdGNoKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdHb3QgYSByZWxheGVkIG1hdGNoIGZvciBhcHAgaW4gemlwLCBiZSBjYXJlZnVsIGZvciBhcHAgbWF0Y2ggZXJyb3JzJyk7XG4gICAgcmV0dXJuIGdldEFwcFBhdGgocmVsYXhlZE1hdGNoKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihgQXBwIHppcCB1bnppcHBlZCBPSywgYnV0IHdlIGNvdWxkIG5vdCBmaW5kIGEgJHthcHBFeHR9IGJ1bmRsZSBgICtcbiAgICAgICAgICAgICAgICAgIGBpbiBpdC4gTWFrZSBzdXJlIHlvdXIgYXJjaGl2ZSBjb250YWlucyB0aGUgJHthcHBFeHR9IHBhY2thZ2UgYCArXG4gICAgICAgICAgICAgICAgICBgYW5kIG5vdGhpbmcgZWxzZWApO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1bnppcEZpbGUgKHppcFBhdGgpIHtcbiAgbG9nZ2VyLmRlYnVnKGBVbnppcHBpbmcgJHt6aXBQYXRofWApO1xuICBsZXQgdmFsaWQgPSBhd2FpdCB0ZXN0WmlwQXJjaGl2ZSh6aXBQYXRoKTtcbiAgaWYgKCF2YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWmlwIGFyY2hpdmUgJHt6aXBQYXRofSBkaWQgbm90IHRlc3QgdmFsaWRgKTtcbiAgfVxuXG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBhd2FpdCB6aXAuZXh0cmFjdEFsbFRvKHppcFBhdGgsIHBhdGguZGlybmFtZSh6aXBQYXRoKSk7XG4gICAgbG9nZ2VyLmRlYnVnKCdVbnppcCBzdWNjZXNzZnVsJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGV4ZWNFbnYgPSBfLmNsb25lKHByb2Nlc3MuZW52KTtcbiAgZGVsZXRlIGV4ZWNFbnYuVU5aSVA7XG4gIGxldCBleGVjT3B0cyA9IHtjd2Q6IHBhdGguZGlybmFtZSh6aXBQYXRoKSwgZW52OiBleGVjRW52fTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCd1bnppcCcsIFsnLW8nLCB6aXBQYXRoXSwgZXhlY09wdHMpO1xuICAgIHJldHVybiBzdGRvdXQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5lcnJvcihgVW56aXAgdGhyZXcgZXJyb3IgJHtlcnJ9YCk7XG4gICAgbG9nZ2VyLmVycm9yKGBTdGRlcnI6ICR7ZXJyLnN0ZGVycn1gKTtcbiAgICBsb2dnZXIuZXJyb3IoYFN0ZG91dDogJHtlcnIuc3Rkb3V0fWApO1xuICAgIHRocm93IG5ldyBFcnJvcignQXJjaGl2ZSBjb3VsZCBub3QgYmUgdW56aXBwZWQsIGNoZWNrIGFwcGl1bSBsb2dzLicpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRlc3RaaXBBcmNoaXZlICh6aXBQYXRoKSB7XG4gIGxvZ2dlci5kZWJ1ZyhgVGVzdGluZyB6aXAgYXJjaGl2ZTogJHt6aXBQYXRofWApO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyh6aXBQYXRoKSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdaaXAgYXJjaGl2ZSB0ZXN0ZWQgY2xlYW4nKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1ppcCBhcmNoaXZlIG5vdCBmb3VuZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGxldCBleGVjRW52ID0gXy5jbG9uZShwcm9jZXNzLmVudik7XG4gIGRlbGV0ZSBleGVjRW52LlVOWklQO1xuICBsZXQgZXhlY09wdHMgPSB7Y3dkOiBwYXRoLmRpcm5hbWUoemlwUGF0aCksIGVudjogZXhlY0Vudn07XG4gIGxldCBvdXRwdXQ7XG4gIHRyeSB7XG4gICAgb3V0cHV0ID0gYXdhaXQgZXhlYygndW56aXAnLCBbJy10cScsIHppcFBhdGhdLCBleGVjT3B0cyk7XG4gICAgaWYgKC9ObyBlcnJvcnMgZGV0ZWN0ZWQvLmV4ZWMob3V0cHV0LnN0ZG91dCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsb2dnZXIuZXJyb3IoYFppcCBmaWxlICR7emlwUGF0aH0gd2FzIG5vdCB2YWxpZGApO1xuICAgIGxvZ2dlci5lcnJvcihgU3RkZXJyOiAke291dHB1dC5zdGRlcnJ9YCk7XG4gICAgbG9nZ2VyLmVycm9yKGBTdGRvdXQ6ICR7b3V0cHV0LnN0ZG91dH1gKTtcbiAgICBsb2dnZXIuZXJyb3IoJ1ppcCBhcmNoaXZlIGRpZCBub3QgdGVzdCBzdWNjZXNzZnVsbHksIGNoZWNrIGFwcGl1bSBzZXJ2ZXIgJyArXG4gICAgICAgICAgICAgICAgICdsb2dzIGZvciBvdXRwdXQnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5lcnJvcihgVGVzdCB6aXAgYXJjaGl2ZSB0aHJldyBlcnJvciAke2Vycn1gKTtcbiAgICBsb2dnZXIuZXJyb3IoYFN0ZGVycjogJHtlcnIuc3RkZXJyfWApO1xuICAgIGxvZ2dlci5lcnJvcihgU3Rkb3V0OiAke2Vyci5zdGRvdXR9YCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0ZXN0aW5nIHppcCBhcmNoaXZlLCBhcmUgeW91IHN1cmUgdGhpcyBpcyBhIHppcCBmaWxlPycpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlGcm9tV2luZG93c05ldHdvcmtTaGFyZSAoYXBwLCBhcHBFeHQsIG1vdW50Um9vdCwgd2luZG93c1VzZXJOYW1lLCB3aW5kb3dzUGFzc3dvcmQpIHtcbiAgaWYgKHN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgIHJldHVybiBhd2FpdCBjb3B5TG9jYWxseUZyb21XaW5kb3dzU2hhcmUoYXBwLCBhcHBFeHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhd2FpdCBtb3VudFdpbmRvd3NTaGFyZU9uTWFjKGFwcCwgbW91bnRSb290LCB3aW5kb3dzVXNlck5hbWUsIHdpbmRvd3NQYXNzd29yZCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbW91bnRXaW5kb3dzU2hhcmVPbk1hYyAoYXBwLCBtb3VudFJvb3QsIHdpbmRvd3NVc2VyTmFtZSwgd2luZG93c1Bhc3N3b3JkKSB7XG4gIGxldCBwYXRoU3BsaXQgPSBhcHAuc3BsaXQoXCJcXFxcXCIpO1xuICBsZXQgbmV0d29ya1NoYXJlID0gcGF0aFNwbGl0WzJdO1xuICBsZXQgcm9vdEZvbGRlciA9IHBhdGhTcGxpdFszXTtcbiAgYXBwID0gYXBwLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuICBhcHAgPSBhcHAucmVwbGFjZShgLyR7bmV0d29ya1NoYXJlfWAsIG1vdW50Um9vdCk7XG4gIGxldCBtb3VudFBhdGggPSBgLyR7bW91bnRSb290fS8ke3Jvb3RGb2xkZXJ9YDtcblxuICBsZXQgbW91bnROZXR3b3JrU2hhcmUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgYXdhaXQgZnMubWtkaXIobW91bnRQYXRoKTtcbiAgICBsZXQgbW91bnRBcmdzID0gW2AtdGAsIGBzbWJmc2AsIGAvLyR7d2luZG93c1VzZXJOYW1lfToke3dpbmRvd3NQYXNzd29yZH1AJHtuZXR3b3JrU2hhcmV9LyR7cm9vdEZvbGRlcn1gLCBtb3VudFBhdGhdO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBleGVjKCdtb3VudCcsIG1vdW50QXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3JBbmRUaHJvdyhgRXJyb3IgbW91bnRpbmc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChhd2FpdCBmcy5leGlzdHMobW91bnRQYXRoKSkge1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMoYXBwKSkge1xuICAgICAgcmV0dXJuIGFwcDtcbiAgICB9XG4gICAgbGV0IHVtb3VudEFyZ3MgPSBbbW91bnRQYXRoXTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlYygndW1vdW50JywgdW1vdW50QXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYEVycm9yIFVubW91bnRpbmcgOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGF3YWl0IGZzLnJpbXJhZihtb3VudFJvb3QpO1xuICB9XG4gIGF3YWl0IG1vdW50TmV0d29ya1NoYXJlKCk7XG4gIHJldHVybiBhcHA7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlMb2NhbGx5RnJvbVdpbmRvd3NTaGFyZSAoYXBwLCBhcHBFeHQpIHtcbiAgbGV0IGZpbGVJbmZvID0gYXdhaXQgdGVtcERpci5vcGVuKHtwcmVmaXg6ICdhcHBpdW0tYXBwJywgc3VmZml4OiBhcHBFeHR9KTtcbiAgcmV0dXJuIGF3YWl0IGZzLmNvcHlGaWxlKGFwcCwgZmlsZUluZm8ucGF0aCk7XG59XG5cbmZ1bmN0aW9uIGlzUGFja2FnZU9yQnVuZGxlIChhcHApIHtcbiAgcmV0dXJuICgvXihbYS16QS1aMC05XFwtX10rXFwuW2EtekEtWjAtOVxcLV9dKykrJC8pLnRlc3QoYXBwKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29vcmREZWZhdWx0ICh2YWwpIHtcbiAgLy8gZ29pbmcgdGhlIGxvbmcgd2F5IGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkIGFuZCBudWxsIHNpbmNlXG4gIC8vIHdlIGNhbid0IGJlIGFzc3VyZWQgYGVsSWRgIGlzIGEgc3RyaW5nIGFuZCBub3QgYW4gaW50LiBTYW1lXG4gIC8vIHRoaW5nIHdpdGggZGVzdEVsZW1lbnQgYmVsb3cuXG4gIHJldHVybiB1dGlsLmhhc1ZhbHVlKHZhbCkgPyB2YWwgOiAwLjU7XG59XG5cbmZ1bmN0aW9uIGdldFN3aXBlVG91Y2hEdXJhdGlvbiAod2FpdEdlc3R1cmUpIHtcbiAgLy8gdGhlIHRvdWNoIGFjdGlvbiBhcGkgdXNlcyBtcywgd2Ugd2FudCBzZWNvbmRzXG4gIC8vIDAuOCBpcyB0aGUgZGVmYXVsdCB0aW1lIGZvciB0aGUgb3BlcmF0aW9uXG4gIGxldCBkdXJhdGlvbiA9IDAuODtcbiAgaWYgKHR5cGVvZiB3YWl0R2VzdHVyZS5vcHRpb25zLm1zICE9PSAndW5kZWZpbmVkJyAmJiB3YWl0R2VzdHVyZS5vcHRpb25zLm1zKSB7XG4gICAgZHVyYXRpb24gPSB3YWl0R2VzdHVyZS5vcHRpb25zLm1zIC8gMTAwMDtcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIC8vIHNldCB0byBhIHZlcnkgbG93IG51bWJlciwgc2luY2UgdGhleSB3YW50ZWQgaXQgZmFzdFxuICAgICAgLy8gYnV0IGJlbG93IDAuMSBiZWNvbWVzIDAgc3RlcHMsIHdoaWNoIGNhdXNlcyBlcnJvcnNcbiAgICAgIGR1cmF0aW9uID0gMC4xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVyYXRpb247XG59XG5cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBmaW5kIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGtleSAnaW5LZXknIGFuZCByZW5hbWUgdGhlbSAnb3V0S2V5J1xuICogQHBhcmFtIHsqfSBpbnB1dCBBbnkgdHlwZSBvZiBpbnB1dFxuICogQHBhcmFtIHtTdHJpbmd9IGluS2V5IFRoZSBrZXkgbmFtZSB0byByZXBsYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0S2V5IFRoZSBrZXkgbmFtZSB0byByZXBsYWNlIGl0IHdpdGhcbiAqL1xuZnVuY3Rpb24gcmVuYW1lS2V5IChpbnB1dCwgaW5LZXksIG91dEtleSkge1xuICBpZiAoXy5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IHJlbmFtZUtleShpdGVtLCBpbktleSwgb3V0S2V5KSk7XG4gIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KGlucHV0KSkge1xuICAgIHJldHVybiBfLnJlZHVjZShpbnB1dCwgKHJlc3VsdE9iaiwgdmFsdWUsIGtleSkgPT4gKHtcbiAgICAgIC4uLnJlc3VsdE9iaixcbiAgICAgIFtrZXkgPT09IGluS2V5ID8gb3V0S2V5IDoga2V5XTogcmVuYW1lS2V5KHZhbHVlLCBpbktleSwgb3V0S2V5KSxcbiAgICB9KSwge30pO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IGNvbmZpZ3VyZUFwcCwgZG93bmxvYWRBcHAsIGRvd25sb2FkRmlsZSwgY29weUxvY2FsWmlwLFxuICAgICAgICAgICAgICAgICB1bnppcEFwcCwgdW56aXBGaWxlLCB0ZXN0WmlwQXJjaGl2ZSwgaXNQYWNrYWdlT3JCdW5kbGUsXG4gICAgICAgICAgICAgICAgIGdldENvb3JkRGVmYXVsdCwgZ2V0U3dpcGVUb3VjaER1cmF0aW9uLCBjb3B5RnJvbVdpbmRvd3NOZXR3b3JrU2hhcmUsIHJlbmFtZUtleSB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
