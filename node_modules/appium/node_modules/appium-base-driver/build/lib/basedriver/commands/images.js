'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _protocolErrors = require('../../protocol/errors');

var _appiumSupport = require('appium-support');

var commands = {},
    helpers = {},
    extensions = {};

var MATCH_FEATURES_MODE = 'matchFeatures';
var GET_SIMILARITY_MODE = 'getSimilarity';
var MATCH_TEMPLATE_MODE = 'matchTemplate';

/**
 * Performs images comparison using OpenCV framework features.
 * It is expected that both OpenCV framework and opencv4nodejs
 * module are installed on the machine where Appium server is running.
 *
 * @param {string} mode - One of possible comparison modes:
 * matchFeatures, getSimilarity, matchTemplate
 * @param {string} firstImage - Base64-encoded image file.
 * All image formats, that OpenCV library itself accepts, are supported.
 * @param {string} secondImage - Base64-encoded image file.
 * All image formats, that OpenCV library itself accepts, are supported.
 * @param {?Object} options [{}] - The content of this dictionary depends
 * on the actual `mode` value. See the documentation on `appium-support`
 * module for more details.
 * @returns {Object} The content of the resulting dictionary depends
 * on the actual `mode` and `options` values. See the documentation on
 * `appium-support` module for more details.
 * @throws {Error} If required OpenCV modules are not installed or
 * if `mode` value is incorrect or if there was an unexpected issue while
 * matching the images.
 */
commands.compareImages = function callee$0$0(mode, firstImage, secondImage) {
  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
  var img1, img2, result;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        img1 = Buffer.from(firstImage, 'base64');
        img2 = Buffer.from(secondImage, 'base64');
        result = {};
        context$1$0.t0 = _lodash2['default'].toLower(mode);
        context$1$0.next = context$1$0.t0 === MATCH_FEATURES_MODE.toLowerCase() ? 6 : context$1$0.t0 === GET_SIMILARITY_MODE.toLowerCase() ? 10 : context$1$0.t0 === MATCH_TEMPLATE_MODE.toLowerCase() ? 14 : 18;
        break;

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.imageUtil.getImagesMatches(img1, img2, options));

      case 8:
        result = context$1$0.sent;
        return context$1$0.abrupt('break', 19);

      case 10:
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.imageUtil.getImagesSimilarity(img1, img2, options));

      case 12:
        result = context$1$0.sent;
        return context$1$0.abrupt('break', 19);

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(_appiumSupport.imageUtil.getImageOccurrence(img1, img2, options));

      case 16:
        result = context$1$0.sent;
        return context$1$0.abrupt('break', 19);

      case 18:
        throw new _protocolErrors.errors.InvalidArgumentError('\'' + mode + '\' images comparison mode is unknown. ' + ('Only ' + JSON.stringify([MATCH_FEATURES_MODE, GET_SIMILARITY_MODE, MATCH_TEMPLATE_MODE]) + ' modes are supported.'));

      case 19:
        if (!_lodash2['default'].isEmpty(result.visualization)) {
          result.visualization = result.visualization.toString('base64');
        }
        return context$1$0.abrupt('return', result);

      case 21:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

_Object$assign(extensions, commands, helpers);
exports.commands = commands;
exports.helpers = helpers;
exports['default'] = extensions;

// firstImage/img1 is the full image and secondImage/img2 is the partial one
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2NvbW1hbmRzL2ltYWdlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7c0JBQWMsUUFBUTs7Ozs4QkFDQyx1QkFBdUI7OzZCQUNwQixnQkFBZ0I7O0FBRTFDLElBQU0sUUFBUSxHQUFHLEVBQUU7SUFBRSxPQUFPLEdBQUcsRUFBRTtJQUFFLFVBQVUsR0FBRyxFQUFFLENBQUM7O0FBRW5ELElBQU0sbUJBQW1CLEdBQUcsZUFBZSxDQUFDO0FBQzVDLElBQU0sbUJBQW1CLEdBQUcsZUFBZSxDQUFDO0FBQzVDLElBQU0sbUJBQW1CLEdBQUcsZUFBZSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCNUMsUUFBUSxDQUFDLGFBQWEsR0FBRyxvQkFBZ0IsSUFBSSxFQUFFLFVBQVUsRUFBRSxXQUFXO01BQUUsT0FBTyx5REFBRyxFQUFFO01BQzVFLElBQUksRUFDSixJQUFJLEVBQ04sTUFBTTs7OztBQUZKLFlBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUM7QUFDeEMsWUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQztBQUMzQyxjQUFNLEdBQUcsRUFBRTt5QkFDUCxvQkFBRSxPQUFPLENBQUMsSUFBSSxDQUFDOzhDQUNoQixtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsMEJBR2pDLG1CQUFtQixDQUFDLFdBQVcsRUFBRSwyQkFHakMsbUJBQW1CLENBQUMsV0FBVyxFQUFFOzs7Ozt5Q0FMckIseUJBQVUsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUM7OztBQUE5RCxjQUFNOzs7Ozt5Q0FHUyx5QkFBVSxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQzs7O0FBQWpFLGNBQU07Ozs7O3lDQUlTLHlCQUFVLGtCQUFrQixDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDOzs7QUFBaEUsY0FBTTs7OztjQUdBLElBQUksdUJBQU8sb0JBQW9CLENBQUMsT0FBSSxJQUFJLHlEQUNwQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsbUJBQW1CLEVBQUUsbUJBQW1CLEVBQUUsbUJBQW1CLENBQUMsQ0FBQywyQkFBdUIsQ0FBQzs7O0FBRXJILFlBQUksQ0FBQyxvQkFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFO0FBQ3BDLGdCQUFNLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ2hFOzRDQUNNLE1BQU07Ozs7Ozs7Q0FDZCxDQUFDOztBQUVGLGVBQWMsVUFBVSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNwQyxRQUFRLEdBQVIsUUFBUTtRQUFFLE9BQU8sR0FBUCxPQUFPO3FCQUNYLFVBQVUiLCJmaWxlIjoibGliL2Jhc2Vkcml2ZXIvY29tbWFuZHMvaW1hZ2VzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGVycm9ycyB9IGZyb20gJy4uLy4uL3Byb3RvY29sL2Vycm9ycyc7XG5pbXBvcnQgeyBpbWFnZVV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5cbmNvbnN0IGNvbW1hbmRzID0ge30sIGhlbHBlcnMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9O1xuXG5jb25zdCBNQVRDSF9GRUFUVVJFU19NT0RFID0gJ21hdGNoRmVhdHVyZXMnO1xuY29uc3QgR0VUX1NJTUlMQVJJVFlfTU9ERSA9ICdnZXRTaW1pbGFyaXR5JztcbmNvbnN0IE1BVENIX1RFTVBMQVRFX01PREUgPSAnbWF0Y2hUZW1wbGF0ZSc7XG5cbi8qKlxuICogUGVyZm9ybXMgaW1hZ2VzIGNvbXBhcmlzb24gdXNpbmcgT3BlbkNWIGZyYW1ld29yayBmZWF0dXJlcy5cbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgYm90aCBPcGVuQ1YgZnJhbWV3b3JrIGFuZCBvcGVuY3Y0bm9kZWpzXG4gKiBtb2R1bGUgYXJlIGluc3RhbGxlZCBvbiB0aGUgbWFjaGluZSB3aGVyZSBBcHBpdW0gc2VydmVyIGlzIHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBPbmUgb2YgcG9zc2libGUgY29tcGFyaXNvbiBtb2RlczpcbiAqIG1hdGNoRmVhdHVyZXMsIGdldFNpbWlsYXJpdHksIG1hdGNoVGVtcGxhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaXJzdEltYWdlIC0gQmFzZTY0LWVuY29kZWQgaW1hZ2UgZmlsZS5cbiAqIEFsbCBpbWFnZSBmb3JtYXRzLCB0aGF0IE9wZW5DViBsaWJyYXJ5IGl0c2VsZiBhY2NlcHRzLCBhcmUgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlY29uZEltYWdlIC0gQmFzZTY0LWVuY29kZWQgaW1hZ2UgZmlsZS5cbiAqIEFsbCBpbWFnZSBmb3JtYXRzLCB0aGF0IE9wZW5DViBsaWJyYXJ5IGl0c2VsZiBhY2NlcHRzLCBhcmUgc3VwcG9ydGVkLlxuICogQHBhcmFtIHs/T2JqZWN0fSBvcHRpb25zIFt7fV0gLSBUaGUgY29udGVudCBvZiB0aGlzIGRpY3Rpb25hcnkgZGVwZW5kc1xuICogb24gdGhlIGFjdHVhbCBgbW9kZWAgdmFsdWUuIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvbiBgYXBwaXVtLXN1cHBvcnRgXG4gKiBtb2R1bGUgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb250ZW50IG9mIHRoZSByZXN1bHRpbmcgZGljdGlvbmFyeSBkZXBlbmRzXG4gKiBvbiB0aGUgYWN0dWFsIGBtb2RlYCBhbmQgYG9wdGlvbnNgIHZhbHVlcy4gU2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4gKiBgYXBwaXVtLXN1cHBvcnRgIG1vZHVsZSBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHJlcXVpcmVkIE9wZW5DViBtb2R1bGVzIGFyZSBub3QgaW5zdGFsbGVkIG9yXG4gKiBpZiBgbW9kZWAgdmFsdWUgaXMgaW5jb3JyZWN0IG9yIGlmIHRoZXJlIHdhcyBhbiB1bmV4cGVjdGVkIGlzc3VlIHdoaWxlXG4gKiBtYXRjaGluZyB0aGUgaW1hZ2VzLlxuICovXG5jb21tYW5kcy5jb21wYXJlSW1hZ2VzID0gYXN5bmMgZnVuY3Rpb24gKG1vZGUsIGZpcnN0SW1hZ2UsIHNlY29uZEltYWdlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaW1nMSA9IEJ1ZmZlci5mcm9tKGZpcnN0SW1hZ2UsICdiYXNlNjQnKTtcbiAgY29uc3QgaW1nMiA9IEJ1ZmZlci5mcm9tKHNlY29uZEltYWdlLCAnYmFzZTY0Jyk7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgc3dpdGNoIChfLnRvTG93ZXIobW9kZSkpIHtcbiAgICBjYXNlIE1BVENIX0ZFQVRVUkVTX01PREUudG9Mb3dlckNhc2UoKTpcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGltYWdlVXRpbC5nZXRJbWFnZXNNYXRjaGVzKGltZzEsIGltZzIsIG9wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBHRVRfU0lNSUxBUklUWV9NT0RFLnRvTG93ZXJDYXNlKCk6XG4gICAgICByZXN1bHQgPSBhd2FpdCBpbWFnZVV0aWwuZ2V0SW1hZ2VzU2ltaWxhcml0eShpbWcxLCBpbWcyLCBvcHRpb25zKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTUFUQ0hfVEVNUExBVEVfTU9ERS50b0xvd2VyQ2FzZSgpOlxuICAgICAgLy8gZmlyc3RJbWFnZS9pbWcxIGlzIHRoZSBmdWxsIGltYWdlIGFuZCBzZWNvbmRJbWFnZS9pbWcyIGlzIHRoZSBwYXJ0aWFsIG9uZVxuICAgICAgcmVzdWx0ID0gYXdhaXQgaW1hZ2VVdGlsLmdldEltYWdlT2NjdXJyZW5jZShpbWcxLCBpbWcyLCBvcHRpb25zKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudEVycm9yKGAnJHttb2RlfScgaW1hZ2VzIGNvbXBhcmlzb24gbW9kZSBpcyB1bmtub3duLiBgICtcbiAgICAgICAgYE9ubHkgJHtKU09OLnN0cmluZ2lmeShbTUFUQ0hfRkVBVFVSRVNfTU9ERSwgR0VUX1NJTUlMQVJJVFlfTU9ERSwgTUFUQ0hfVEVNUExBVEVfTU9ERV0pfSBtb2RlcyBhcmUgc3VwcG9ydGVkLmApO1xuICB9XG4gIGlmICghXy5pc0VtcHR5KHJlc3VsdC52aXN1YWxpemF0aW9uKSkge1xuICAgIHJlc3VsdC52aXN1YWxpemF0aW9uID0gcmVzdWx0LnZpc3VhbGl6YXRpb24udG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PYmplY3QuYXNzaWduKGV4dGVuc2lvbnMsIGNvbW1hbmRzLCBoZWxwZXJzKTtcbmV4cG9ydCB7IGNvbW1hbmRzLCBoZWxwZXJzfTtcbmV4cG9ydCBkZWZhdWx0IGV4dGVuc2lvbnM7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uLy4uIn0=
