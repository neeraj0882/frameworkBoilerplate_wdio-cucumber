'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _fs = require('fs');

var _fs2 = require('./fs');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _util = require('./util');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _requestPromise = require('request-promise');

var _requestPromise2 = _interopRequireDefault(_requestPromise);

var _jsftp = require('jsftp');

var _jsftp2 = _interopRequireDefault(_jsftp);

function uploadFileToHttp(remoteUrl) {
  var uploadOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var response, responseDebugMsg;
  return _regeneratorRuntime.async(function uploadFileToHttp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug(remoteUrl.protocol + ' upload options: ' + JSON.stringify(uploadOptions));
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _requestPromise2['default'])(uploadOptions));

      case 3:
        response = context$1$0.sent;
        responseDebugMsg = 'Response code: ' + response.statusCode + '. ' + ('Response body: ' + JSON.stringify(response.body));

        _logger2['default'].debug(responseDebugMsg);

        if (!(response.statusCode >= 400)) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Cannot upload the recorded media to \'' + remoteUrl.href + '\'. ' + responseDebugMsg);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function uploadFileToFtp(localFileStream, remoteUrl) {
  var uploadOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _regeneratorRuntime.async(function uploadFileToFtp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug(remoteUrl.protocol + ' upload options: ' + JSON.stringify(uploadOptions));
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
          new _jsftp2['default'](uploadOptions).put(localFileStream, remoteUrl.pathname, function (err) {
            if (err) {
              return reject(err);
            }
            resolve();
          });
        }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Uploads the given file to a remote location. HTTP(S) and FTP
 * protocols are supported.
 *
 * @param {string} localPath - The path to a file on the local storage.
 * @param {string} remotePath - The remote URL to upload the file to.
 * @param {Object} uploadOptions - The options set, which depends on the protocol set for remotePath.
 *                                 See https://www.npmjs.com/package/request-promise and
 *                                 https://www.npmjs.com/package/jsftp for more details.
 */
function uploadFile(localPath, remotePath) {
  var uploadOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var remoteUrl, _ref, size, timeStarted, timeElapsed;

  return _regeneratorRuntime.async(function uploadFile$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _fs2.exists)(localPath));

      case 2:
        if (context$1$0.sent) {
          context$1$0.next = 4;
          break;
        }

        throw new Error('\'' + localPath + '\' does not exists or is not accessible');

      case 4:
        remoteUrl = _url2['default'].parse(remotePath);
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _fs2.stat)(localPath));

      case 7:
        _ref = context$1$0.sent;
        size = _ref.size;

        _logger2['default'].info('Uploading \'' + localPath + '\' of ' + (0, _util.toReadableSizeString)(size) + ' size to \'' + remotePath + '\'...');
        timeStarted = process.hrtime();

        if (!['http:', 'https:'].includes(remoteUrl.protocol)) {
          context$1$0.next = 16;
          break;
        }

        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(uploadFileToHttp(remoteUrl, uploadOptions));

      case 14:
        context$1$0.next = 22;
        break;

      case 16:
        if (!(remoteUrl.protocol === 'ftp:')) {
          context$1$0.next = 21;
          break;
        }

        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(uploadFileToFtp((0, _fs.createReadStream)(localPath), remoteUrl, uploadOptions));

      case 19:
        context$1$0.next = 22;
        break;

      case 21:
        throw new Error('Cannot upload the file at \'' + localPath + '\' to \'' + remotePath + '\'. ' + ('Unsupported remote protocol \'' + remoteUrl.protocol + '\'. ') + 'Only http/https and ftp protocols are supported.');

      case 22:
        timeElapsed = process.hrtime(timeStarted)[0];

        _logger2['default'].info('Uploaded \'' + localPath + '\' of ' + (0, _util.toReadableSizeString)(size) + ' size in ' + timeElapsed + ' second' + (timeElapsed === 1 ? '' : 's'));

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

exports.uploadFile = uploadFile;
//# sourceMappingURL=data:application/json;charset=utf8;base64,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Q0FBQyxpQkFBWSxXQUFXLGdCQUFVLFdBQVcsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQSxDQUFHLENBQUM7Ozs7Ozs7Q0FDbkk7O1FBRVEsVUFBVSxHQUFWLFVBQVUiLCJmaWxlIjoibGliL25ldC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlYWRTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBzdGF0LCBleGlzdHMgfSBmcm9tICcuL2ZzJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHRvUmVhZGFibGVTaXplU3RyaW5nIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHJlcXVlc3QgZnJvbSAncmVxdWVzdC1wcm9taXNlJztcbmltcG9ydCBGdHAgZnJvbSAnanNmdHAnO1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGVUb0h0dHAgKHJlbW90ZVVybCwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGxvZy5kZWJ1ZyhgJHtyZW1vdGVVcmwucHJvdG9jb2x9IHVwbG9hZCBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KHVwbG9hZE9wdGlvbnMpfWApO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QodXBsb2FkT3B0aW9ucyk7XG4gIGNvbnN0IHJlc3BvbnNlRGVidWdNc2cgPSBgUmVzcG9uc2UgY29kZTogJHtyZXNwb25zZS5zdGF0dXNDb2RlfS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBgUmVzcG9uc2UgYm9keTogJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZS5ib2R5KX1gO1xuICBsb2cuZGVidWcocmVzcG9uc2VEZWJ1Z01zZyk7XG4gIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVwbG9hZCB0aGUgcmVjb3JkZWQgbWVkaWEgdG8gJyR7cmVtb3RlVXJsLmhyZWZ9Jy4gJHtyZXNwb25zZURlYnVnTXNnfWApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGVUb0Z0cCAobG9jYWxGaWxlU3RyZWFtLCByZW1vdGVVcmwsIHVwbG9hZE9wdGlvbnMgPSB7fSkge1xuICBsb2cuZGVidWcoYCR7cmVtb3RlVXJsLnByb3RvY29sfSB1cGxvYWQgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeSh1cGxvYWRPcHRpb25zKX1gKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBuZXcgRnRwKHVwbG9hZE9wdGlvbnMpLnB1dChsb2NhbEZpbGVTdHJlYW0sIHJlbW90ZVVybC5wYXRobmFtZSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFVwbG9hZHMgdGhlIGdpdmVuIGZpbGUgdG8gYSByZW1vdGUgbG9jYXRpb24uIEhUVFAoUykgYW5kIEZUUFxuICogcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aCAtIFRoZSBwYXRoIHRvIGEgZmlsZSBvbiB0aGUgbG9jYWwgc3RvcmFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBVUkwgdG8gdXBsb2FkIHRoZSBmaWxlIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IHVwbG9hZE9wdGlvbnMgLSBUaGUgb3B0aW9ucyBzZXQsIHdoaWNoIGRlcGVuZHMgb24gdGhlIHByb3RvY29sIHNldCBmb3IgcmVtb3RlUGF0aC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlcXVlc3QtcHJvbWlzZSBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNmdHAgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZSAobG9jYWxQYXRoLCByZW1vdGVQYXRoLCB1cGxvYWRPcHRpb25zID0ge30pIHtcbiAgaWYgKCFhd2FpdCBleGlzdHMobG9jYWxQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvciAoYCcke2xvY2FsUGF0aH0nIGRvZXMgbm90IGV4aXN0cyBvciBpcyBub3QgYWNjZXNzaWJsZWApO1xuICB9XG4gIGNvbnN0IHJlbW90ZVVybCA9IHVybC5wYXJzZShyZW1vdGVQYXRoKTtcbiAgY29uc3Qge3NpemV9ID0gYXdhaXQgc3RhdChsb2NhbFBhdGgpO1xuICBsb2cuaW5mbyhgVXBsb2FkaW5nICcke2xvY2FsUGF0aH0nIG9mICR7dG9SZWFkYWJsZVNpemVTdHJpbmcoc2l6ZSl9IHNpemUgdG8gJyR7cmVtb3RlUGF0aH0nLi4uYCk7XG4gIGNvbnN0IHRpbWVTdGFydGVkID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgaWYgKFsnaHR0cDonLCAnaHR0cHM6J10uaW5jbHVkZXMocmVtb3RlVXJsLnByb3RvY29sKSkge1xuICAgIGF3YWl0IHVwbG9hZEZpbGVUb0h0dHAocmVtb3RlVXJsLCB1cGxvYWRPcHRpb25zKTtcbiAgfSBlbHNlIGlmIChyZW1vdGVVcmwucHJvdG9jb2wgPT09ICdmdHA6Jykge1xuICAgIGF3YWl0IHVwbG9hZEZpbGVUb0Z0cChjcmVhdGVSZWFkU3RyZWFtKGxvY2FsUGF0aCksIHJlbW90ZVVybCwgdXBsb2FkT3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBsb2FkIHRoZSBmaWxlIGF0ICcke2xvY2FsUGF0aH0nIHRvICcke3JlbW90ZVBhdGh9Jy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCByZW1vdGUgcHJvdG9jb2wgJyR7cmVtb3RlVXJsLnByb3RvY29sfScuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgT25seSBodHRwL2h0dHBzIGFuZCBmdHAgcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgY29uc3QgdGltZUVsYXBzZWQgPSBwcm9jZXNzLmhydGltZSh0aW1lU3RhcnRlZClbMF07XG4gIGxvZy5pbmZvKGBVcGxvYWRlZCAnJHtsb2NhbFBhdGh9JyBvZiAke3RvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSBzaXplIGluICR7dGltZUVsYXBzZWR9IHNlY29uZCR7dGltZUVsYXBzZWQgPT09IDEgPyAnJyA6ICdzJ31gKTtcbn1cblxuZXhwb3J0IHsgdXBsb2FkRmlsZSB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
