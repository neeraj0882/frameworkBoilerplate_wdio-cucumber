'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _npmlog = require('npmlog');

var _npmlog2 = _interopRequireDefault(_npmlog);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

// levels that are available from `npmlog`
var NPM_LEVELS = ['silly', 'verbose', 'debug', 'info', 'http', 'warn', 'error'];
var MAX_LOG_RECORDS_COUNT = 3000;

// mock log object used in testing mode
var mockLog = {};
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  for (var _iterator = _getIterator(NPM_LEVELS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var level = _step.value;

    mockLog[level] = function () {};
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator['return']) {
      _iterator['return']();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

function patchLogger(logger) {
  if (!logger.debug) {
    logger.addLevel('debug', 1000, { fg: 'blue', bg: 'black' }, 'dbug');
  }
}

function _getLogger() {
  // check if the user set the `_TESTING` or `_FORCE_LOGS` flag
  var testingMode = parseInt(process.env._TESTING, 10) === 1;
  var forceLogMode = parseInt(process.env._FORCE_LOGS, 10) === 1;

  // if is possible that there is a logger instance that is already around,
  // in which case we want t o use that
  var usingGlobalLog = !!global._global_npmlog;
  var logger = undefined;
  if (testingMode && !forceLogMode) {
    // in testing mode, use a mock logger object that we can query
    logger = mockLog;
  } else {
    // otherwise, either use the global, or a new `npmlog` object
    logger = global._global_npmlog || _npmlog2['default'];
    // The default value is 10000, which causes excessive memory usage
    logger.maxRecordSize = MAX_LOG_RECORDS_COUNT;
  }
  patchLogger(logger);
  return [logger, usingGlobalLog];
}

function getLogger() {
  var prefix = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

  var _getLogger2 = _getLogger();

  var _getLogger22 = _slicedToArray(_getLogger2, 2);

  var logger = _getLogger22[0];
  var usingGlobalLog = _getLogger22[1];

  // wrap the logger so that we can catch and modify any logging
  var wrappedLogger = { unwrap: function unwrap() {
      return logger;
    } };

  // allow access to the level of the underlying logger
  Object.defineProperty(wrappedLogger, 'level', {
    get: function get() {
      return logger.level;
    },
    set: function set(newValue) {
      logger.level = newValue;
    },
    enumerable: true,
    configurable: true
  });
  // This lambda function is necessary to workaround unexpected memory leaks
  // caused by NodeJS behavior described in https://bugs.chromium.org/p/v8/issues/detail?id=2869
  var unleakIfString = function unleakIfString(x) {
    return _lodash2['default'].isString(x) ? (' ' + x).substr(1) : x;
  };
  // add all the levels from `npmlog`, and map to the underlying logger
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    var _loop = function () {
      var level = _step2.value;

      wrappedLogger[level] = function () {
        var actualPrefix = _lodash2['default'].isFunction(prefix) ? prefix() : prefix;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          for (var _iterator3 = _getIterator(args.map(unleakIfString)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var arg = _step3.value;

            var out = arg + '';
            if (_lodash2['default'].isError(arg) && arg.stack) {
              out = arg.stack;
            }
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = _getIterator(out.split('\n')), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var line = _step4.value;

                logger[level](actualPrefix, line);
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                  _iterator4['return']();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
              _iterator3['return']();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      };
    };

    for (var _iterator2 = _getIterator(NPM_LEVELS), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      _loop();
    }
    // add method to log an error, and throw it, for convenience
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
        _iterator2['return']();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  wrappedLogger.errorAndThrow = function (err) {
    // make sure we have an `Error` object. Wrap if necessary
    if (!(err instanceof Error)) {
      err = new Error(err);
    }
    // log and throw
    this.error(unleakIfString(err));
    throw err;
  };
  if (!usingGlobalLog) {
    // if we're not using a global log specified from some top-level package,
    // set the log level to a default of verbose. Otherwise, let the top-level
    // package set the log level
    wrappedLogger.level = 'verbose';
  }
  wrappedLogger.levels = NPM_LEVELS;
  return wrappedLogger;
}

// export a default logger with no prefix
var log = getLogger();

exports.log = log;
exports.patchLogger = patchLogger;
exports.getLogger = getLogger;
exports['default'] = log;
//# sourceMappingURL=data:application/json;charset=utf8;base64,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bXBvcnQgbnBtbG9nIGZyb20gJ25wbWxvZyc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5cbi8vIGxldmVscyB0aGF0IGFyZSBhdmFpbGFibGUgZnJvbSBgbnBtbG9nYFxuY29uc3QgTlBNX0xFVkVMUyA9IFsnc2lsbHknLCAndmVyYm9zZScsICdkZWJ1ZycsICdpbmZvJywgJ2h0dHAnLCAnd2FybicsICdlcnJvciddO1xuY29uc3QgTUFYX0xPR19SRUNPUkRTX0NPVU5UID0gMzAwMDtcblxuLy8gbW9jayBsb2cgb2JqZWN0IHVzZWQgaW4gdGVzdGluZyBtb2RlXG5sZXQgbW9ja0xvZyA9IHt9O1xuZm9yIChsZXQgbGV2ZWwgb2YgTlBNX0xFVkVMUykge1xuICBtb2NrTG9nW2xldmVsXSA9ICgpID0+IHt9O1xufVxuXG5mdW5jdGlvbiBwYXRjaExvZ2dlciAobG9nZ2VyKSB7XG4gIGlmICghbG9nZ2VyLmRlYnVnKSB7XG4gICAgbG9nZ2VyLmFkZExldmVsKCdkZWJ1ZycsIDEwMDAsIHsgZmc6ICdibHVlJywgYmc6ICdibGFjaycgfSwgJ2RidWcnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0TG9nZ2VyICgpIHtcbiAgLy8gY2hlY2sgaWYgdGhlIHVzZXIgc2V0IHRoZSBgX1RFU1RJTkdgIG9yIGBfRk9SQ0VfTE9HU2AgZmxhZ1xuICBjb25zdCB0ZXN0aW5nTW9kZSA9IHBhcnNlSW50KHByb2Nlc3MuZW52Ll9URVNUSU5HLCAxMCkgPT09IDE7XG4gIGNvbnN0IGZvcmNlTG9nTW9kZSA9IHBhcnNlSW50KHByb2Nlc3MuZW52Ll9GT1JDRV9MT0dTLCAxMCkgPT09IDE7XG5cbiAgLy8gaWYgaXMgcG9zc2libGUgdGhhdCB0aGVyZSBpcyBhIGxvZ2dlciBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHkgYXJvdW5kLFxuICAvLyBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdCBvIHVzZSB0aGF0XG4gIGNvbnN0IHVzaW5nR2xvYmFsTG9nID0gISFnbG9iYWwuX2dsb2JhbF9ucG1sb2c7XG4gIGxldCBsb2dnZXI7XG4gIGlmICh0ZXN0aW5nTW9kZSAmJiAhZm9yY2VMb2dNb2RlKSB7XG4gICAgLy8gaW4gdGVzdGluZyBtb2RlLCB1c2UgYSBtb2NrIGxvZ2dlciBvYmplY3QgdGhhdCB3ZSBjYW4gcXVlcnlcbiAgICBsb2dnZXIgPSBtb2NrTG9nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwgZWl0aGVyIHVzZSB0aGUgZ2xvYmFsLCBvciBhIG5ldyBgbnBtbG9nYCBvYmplY3RcbiAgICBsb2dnZXIgPSBnbG9iYWwuX2dsb2JhbF9ucG1sb2cgfHwgbnBtbG9nO1xuICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDEwMDAwLCB3aGljaCBjYXVzZXMgZXhjZXNzaXZlIG1lbW9yeSB1c2FnZVxuICAgIGxvZ2dlci5tYXhSZWNvcmRTaXplID0gTUFYX0xPR19SRUNPUkRTX0NPVU5UO1xuICB9XG4gIHBhdGNoTG9nZ2VyKGxvZ2dlcik7XG4gIHJldHVybiBbbG9nZ2VyLCB1c2luZ0dsb2JhbExvZ107XG59XG5cbmZ1bmN0aW9uIGdldExvZ2dlciAocHJlZml4ID0gbnVsbCkge1xuICBsZXQgW2xvZ2dlciwgdXNpbmdHbG9iYWxMb2ddID0gX2dldExvZ2dlcigpO1xuXG4gIC8vIHdyYXAgdGhlIGxvZ2dlciBzbyB0aGF0IHdlIGNhbiBjYXRjaCBhbmQgbW9kaWZ5IGFueSBsb2dnaW5nXG4gIGxldCB3cmFwcGVkTG9nZ2VyID0ge3Vud3JhcDogKCkgPT4gbG9nZ2VyfTtcblxuICAvLyBhbGxvdyBhY2Nlc3MgdG8gdGhlIGxldmVsIG9mIHRoZSB1bmRlcmx5aW5nIGxvZ2dlclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlZExvZ2dlciwgJ2xldmVsJywge1xuICAgIGdldDogKCkgPT4geyByZXR1cm4gbG9nZ2VyLmxldmVsOyB9LFxuICAgIHNldDogKG5ld1ZhbHVlKSA9PiB7IGxvZ2dlci5sZXZlbCA9IG5ld1ZhbHVlOyB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvLyBUaGlzIGxhbWJkYSBmdW5jdGlvbiBpcyBuZWNlc3NhcnkgdG8gd29ya2Fyb3VuZCB1bmV4cGVjdGVkIG1lbW9yeSBsZWFrc1xuICAvLyBjYXVzZWQgYnkgTm9kZUpTIGJlaGF2aW9yIGRlc2NyaWJlZCBpbiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yODY5XG4gIGNvbnN0IHVubGVha0lmU3RyaW5nID0gKHgpID0+IF8uaXNTdHJpbmcoeCkgPyBgICR7eH1gLnN1YnN0cigxKSA6IHg7XG4gIC8vIGFkZCBhbGwgdGhlIGxldmVscyBmcm9tIGBucG1sb2dgLCBhbmQgbWFwIHRvIHRoZSB1bmRlcmx5aW5nIGxvZ2dlclxuICBmb3IgKGNvbnN0IGxldmVsIG9mIE5QTV9MRVZFTFMpIHtcbiAgICB3cmFwcGVkTG9nZ2VyW2xldmVsXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBjb25zdCBhY3R1YWxQcmVmaXggPSBfLmlzRnVuY3Rpb24ocHJlZml4KSA/IHByZWZpeCgpIDogcHJlZml4O1xuICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncy5tYXAodW5sZWFrSWZTdHJpbmcpKSB7XG4gICAgICAgIGxldCBvdXQgPSBhcmcgKyAnJztcbiAgICAgICAgaWYgKF8uaXNFcnJvcihhcmcpICYmIGFyZy5zdGFjaykge1xuICAgICAgICAgIG91dCA9IGFyZy5zdGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygb3V0LnNwbGl0KCdcXG4nKSkge1xuICAgICAgICAgIGxvZ2dlcltsZXZlbF0oYWN0dWFsUHJlZml4LCBsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gYWRkIG1ldGhvZCB0byBsb2cgYW4gZXJyb3IsIGFuZCB0aHJvdyBpdCwgZm9yIGNvbnZlbmllbmNlXG4gIHdyYXBwZWRMb2dnZXIuZXJyb3JBbmRUaHJvdyA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhbiBgRXJyb3JgIG9iamVjdC4gV3JhcCBpZiBuZWNlc3NhcnlcbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcihlcnIpO1xuICAgIH1cbiAgICAvLyBsb2cgYW5kIHRocm93XG4gICAgdGhpcy5lcnJvcih1bmxlYWtJZlN0cmluZyhlcnIpKTtcbiAgICB0aHJvdyBlcnI7XG4gIH07XG4gIGlmICghdXNpbmdHbG9iYWxMb2cpIHtcbiAgICAvLyBpZiB3ZSdyZSBub3QgdXNpbmcgYSBnbG9iYWwgbG9nIHNwZWNpZmllZCBmcm9tIHNvbWUgdG9wLWxldmVsIHBhY2thZ2UsXG4gICAgLy8gc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYSBkZWZhdWx0IG9mIHZlcmJvc2UuIE90aGVyd2lzZSwgbGV0IHRoZSB0b3AtbGV2ZWxcbiAgICAvLyBwYWNrYWdlIHNldCB0aGUgbG9nIGxldmVsXG4gICAgd3JhcHBlZExvZ2dlci5sZXZlbCA9ICd2ZXJib3NlJztcbiAgfVxuICB3cmFwcGVkTG9nZ2VyLmxldmVscyA9IE5QTV9MRVZFTFM7XG4gIHJldHVybiB3cmFwcGVkTG9nZ2VyO1xufVxuXG4vLyBleHBvcnQgYSBkZWZhdWx0IGxvZ2dlciB3aXRoIG5vIHByZWZpeFxuY29uc3QgbG9nID0gZ2V0TG9nZ2VyKCk7XG5cbmV4cG9ydCB7IGxvZywgcGF0Y2hMb2dnZXIsIGdldExvZ2dlciB9O1xuZXhwb3J0IGRlZmF1bHQgbG9nO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
