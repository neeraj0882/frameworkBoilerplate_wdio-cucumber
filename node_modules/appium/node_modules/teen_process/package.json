{
  "_args": [
    [
      {
        "raw": "teen_process@https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
        "scope": null,
        "escapedName": "teen_process",
        "name": "teen_process",
        "rawSpec": "https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
        "spec": "https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
        "type": "remote"
      },
      "/Users/saxenan3/myprojects/uiAutomation/mytest_project/node_modules/appium"
    ]
  ],
  "_from": "teen_process@https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
  "_id": "teen_process@1.12.0",
  "_inCache": true,
  "_location": "/appium/teen_process",
  "_phantomChildren": {},
  "_requested": {
    "raw": "teen_process@https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
    "scope": null,
    "escapedName": "teen_process",
    "name": "teen_process",
    "rawSpec": "https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
    "spec": "https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/appium",
    "/appium/appium-adb",
    "/appium/appium-android-bootstrap",
    "/appium/appium-android-driver",
    "/appium/appium-base-driver",
    "/appium/appium-chromedriver",
    "/appium/appium-espresso-driver",
    "/appium/appium-ios-driver",
    "/appium/appium-ios-simulator",
    "/appium/appium-mac-driver",
    "/appium/appium-selendroid-driver",
    "/appium/appium-support",
    "/appium/appium-uiautomator2-driver",
    "/appium/appium-windows-driver",
    "/appium/appium-xcode",
    "/appium/appium-xcuitest-driver",
    "/appium/appium-xcuitest-driver/appium-ios-simulator",
    "/appium/node-simctl"
  ],
  "_resolved": "https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
  "_shasum": "215fcf2ffc9a853a17ab38ab5b3af234793ede66",
  "_shrinkwrap": null,
  "_spec": "teen_process@https://registry.npmjs.org/teen_process/-/teen_process-1.12.0.tgz",
  "_where": "/Users/saxenan3/myprojects/uiAutomation/mytest_project/node_modules/appium",
  "author": {
    "name": "appium"
  },
  "bin": {},
  "bugs": {
    "url": "https://github.com/appium/node-teen_process/issues"
  },
  "dependencies": {
    "appium-support": "^2.0.10",
    "babel-runtime": "=5.8.24",
    "shell-quote": "^1.4.3",
    "source-map-support": "^0.5.3",
    "through": "^2.3.8"
  },
  "description": "A grown up version of Node's spawn/exec",
  "devDependencies": {
    "appium-gulp-plugins": "^2.2.0",
    "babel-eslint": "^7.1.1",
    "bluebird": "^3.5.1",
    "chai": "^4.1.2",
    "chai-as-promised": "^7.1.1",
    "eslint": "^3.10.2",
    "eslint-config-appium": "^2.1.0",
    "eslint-plugin-import": "^2.2.0",
    "eslint-plugin-mocha": "^4.7.0",
    "eslint-plugin-promise": "^3.3.1",
    "gulp": "^3.9.0",
    "lodash": "^4.17.4",
    "pre-commit": "^1.2.2"
  },
  "directories": {
    "lib": "lib"
  },
  "engines": [
    "node"
  ],
  "homepage": "https://github.com/appium/node-teen_process#readme",
  "keywords": [
    "child_process",
    "process management"
  ],
  "license": "Apache-2.0",
  "main": "./build/index.js",
  "name": "teen_process",
  "optionalDependencies": {},
  "pre-commit": [
    "precommit-msg",
    "precommit-test"
  ],
  "readme": "node-teen_process\n=================\n\nA grown-up version of Node's child_process. `exec` is really useful, but it\nsuffers many limitations. This is an es7 (`async`/`await`) implementation of\n`exec` that uses `spawn` under the hood. It takes care of wrapping commands and\narguments so we don't have to care about escaping spaces. It can also return\nstdout/stderr even when the command fails, or times out. Importantly, it's also\nnot susceptible to max buffer issues.\n\n## teen_process.exec\n\nExamples:\n\n```js\nimport { exec } from 'teen_process';\n\n// basic usage\nlet {stdout, stderr, code} = await exec('ls', ['/usr/local/bin']);\nconsole.log(stdout.split(\"\\n\"));  // array of files\nconsole.log(stderr);              // ''\nconsole.log(code);                // 0\n\n// works with spaces\nawait exec('/command/with spaces.sh', ['foo', 'argument with spaces'])\n// as though we had run: \"/command/with spaces.sh\" foo \"argument with spaces\"\n\n// nice error handling that still includes stderr/stdout/code\ntry {\n  await exec('echo_and_exit', ['foo', '10']);\n} catch (e) {\n  console.log(e.message);  // \"Exited with code 10\"\n  console.log(e.stdout);   // \"foo\"\n  console.log(e.code);     // 10\n}\n```\n\nThe `exec` function takes some options, with these defaults:\n\n```js\n{\n  cwd: undefined,\n  env: process.env,\n  timeout: null,\n  killSignal: 'SIGTERM',\n  encoding: 'utf8',\n  ignoreOutput: false,\n  stdio: \"inherit\",\n  isBuffer: false,\n  shell: undefined,\n}\n```\n\nMost of these are self-explanatory. `ignoreOutput` is useful if you have a very\nchatty process whose output you don't care about and don't want to add it to\nthe memory consumed by your program.\n\nExample:\n\n```js\ntry {\n  await exec('sleep', ['10'], {timeout: 500, killSignal: 'SIGINT'});\n} catch (e) {\n  console.log(e.message);  // \"'sleep 10' timed out after 500ms\"\n}\n```\n\nThe `isBuffer` option specifies that the returned standard I/O is an instance\nof a [Buffer](https://nodejs.org/api/buffer.html).\n\nExample:\n\n```js\nlet {stdout, stderr} = await exec('cat', [filename], {isBuffer: true});\nBuffer.isBuffer(stdout); // true\n```\n\n## teen_process.SubProcess\n\n`spawn` is already pretty great but for some uses there's a fair amount of\nboilerplate, especially when using in an `async/await` context. `teen_process`\nalso exposes a `SubProcess` class, which can be used to cut down on some\nboilerplate. It has 2 methods, `start` and `stop`:\n\n```js\nimport { SubProcess } from 'teen_process';\n\nasync function tailFileForABit () {\n  let proc = new SubProcess('tail', ['-f', '/var/log/foo.log']);\n  await proc.start();\n  await proc.stop();\n}\n```\n\nErrors with start/stop are thrown in the calling context.\n\n### Events\n\nYou can listen to 8 events:\n\n* `exit`\n* `stop`\n* `end`\n* `die`\n* `output`\n* `lines-stdout`\n* `lines-stderr`\n* `stream-line`\n\n```js\nproc.on('exit', (code, signal) => {\n  // if we get here, all we know is that the proc exited\n  console.log(`exited with code ${code} from signal ${signal}`);\n  // exited with code 127 from signal SIGHUP\n});\n\nproc.on('stop', (code, signal) => {\n  // if we get here, we know that we intentionally stopped the proc\n  // by calling proc.stop\n});\n\nproc.on('end', (code, signal) => {\n  // if we get here, we know that the process stopped outside of our control\n  // but with a 0 exit code\n});\n\nproc.on('die', (code, signal) => {\n  // if we get here, we know that the process stopped outside of our control\n  // with a non-zero exit code\n});\n\nproc.on('output', (stdout, stderr) => {\n  console.log(`stdout: ${stdout}`);\n  console.log(`stderr: ${stderr}`);\n});\n\n// lines-stderr is just the same\nproc.on('lines-stdout', lines => {\n  console.log(lines);\n  // ['foo', 'bar', 'baz']\n  // automatically handles rejoining lines across stream chunks\n});\n\n// stream-line gives you one line at a time, with [STDOUT] or [STDERR]\n// prepended\nproc.on('stream-line', line => {\n  console.log(line);\n  // [STDOUT] foo\n});\n// so we could do: proc.on('stream-line', console.log.bind(console))\n```\n\n### Start Detectors\n\nHow does `SubProcess` know when to return control from `start()`? Well, the\ndefault is to wait until there is some output. You can also pass in a number,\nwhich will cause it to wait for that number of ms, or a function (which I call\na `startDetector`) which takes stdout and stderr and returns true when you want\ncontrol back. Examples:\n\n```js\nawait proc.start(); // will continue when stdout or stderr has received data\nawait proc.start(0); // will continue immediately\n\nlet sd = (stdout, stderr) => {\n  return stderr.indexOf('blarg') !== -1;\n};\nawait proc.start(sd); // will continue when stderr receives 'blarg'\n```\n\nA custom `startDetector` can also throw an error if it wants to declare the\nstart unsuccessful. For example, if we know that the first output might contain\na string which invalidates the process (for us), we could define a custom\n`startDetector` as follows:\n\n```js\nlet sd = (stdout, stderr) => {\n  if (/fail/.test(stderr)) {\n    throw new Error(\"Encountered failure condition\");\n  }\n  return stdout || stderr;\n};\nawait proc.start(sd); // will continue when output is received that doesn't\n                      // match 'fail'\n```\n\nFinally, if you want to specify a maximum time to wait for a process to start,\nyou can do that by passing a second parameter in milliseconds to `start()`:\n\n```js\n// use the default startDetector and throw an error if we wait for more than\n// 1000ms for output\nawait proc.start(null, 1000);\n```\n\n### Finishing Processes\n\nAfter the process has been started you can use `join()` to wait for it to\nfinish on its own:\n\n```js\nawait proc.join(); // will throw on exitcode not 0\nawait proc.join([0, 1]); // will throw on exitcode not 0 or 1\n```\n\nAnd how about killing the processes? Can you provide a custom signal, instead\nof using the default `SIGTERM`? Why yes:\n\n```js\nawait proc.stop('SIGHUP');\n```\n\nIf your process might not be killable and you don't really care, you can also\npass a timeout, which will return control to you in the form of an error after\nthe timeout has passed:\n\n```js\ntry {\n  await proc.stop('SIGHUP', 1000);\n} catch (e) {\n  console.log(\"Proc failed to stop, ignoring cause YOLO\");\n}\n```\n\nAll in all, this makes it super simple to, say, write a script that tails\na file for X seconds and then stops, using async/await and pretty\nstraightforward error handling.\n\n```js\nasync function boredTail (filePath, boredAfter = 10000) {\n  let p = new SubProcess('tail', ['-f', filePath]);\n  p.on('stream-line', console.log);\n  await p.start();\n  await Bluebird.delay(boredAfter);\n  await p.stop();\n}\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/appium/node-teen_process.git"
  },
  "scripts": {
    "lint": "gulp eslint",
    "lint:fix": "gulp eslint --fix",
    "precommit-msg": "echo 'Pre-commit checks...' && exit 0",
    "precommit-test": "REPORTER=dot gulp once",
    "prepublish": "gulp prepublish",
    "test": "gulp once",
    "watch": "gulp"
  },
  "version": "1.12.0"
}
