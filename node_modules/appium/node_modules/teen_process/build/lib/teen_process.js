/* eslint-disable promise/prefer-await-to-callbacks */

'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _child_process = require('child_process');

var _shellQuote = require('shell-quote');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _through = require('through');

var _through2 = _interopRequireDefault(_through);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var EventEmitter = _events2['default'].EventEmitter;

function exec(cmd) {
  var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  // get a quoted representation of the command for error strings
  var rep = (0, _shellQuote.quote)([cmd].concat(args));

  // extend default options; we're basically re-implementing exec's options
  // for use here with spawn under the hood
  opts = _Object$assign({
    timeout: null,
    encoding: 'utf8',
    killSignal: 'SIGTERM',
    cwd: undefined,
    env: process.env,
    ignoreOutput: false,
    stdio: "inherit",
    isBuffer: false,
    shell: undefined
  }, opts);

  // this is an async function, so return a promise
  return new _bluebird2['default'](function (resolve, reject) {
    // spawn the child process with options; we don't currently expose any of
    // the other 'spawn' options through the API
    var proc = (0, _child_process.spawn)(cmd, args, { cwd: opts.cwd, env: opts.env, shell: opts.shell });
    var stdoutArr = [],
        stderrArr = [],
        timer = null;

    // if the process errors out, reject the promise
    proc.on('error', function (err) {
      var msg = 'Command \'' + rep + '\' errored out: ' + err.stack;
      if (err.errno === 'ENOENT') {
        msg = 'Command \'' + cmd + '\' not found. Is it installed?';
      }
      reject(new Error(msg));
    });
    if (proc.stdin) {
      proc.stdin.on('error', function (err) {
        reject(new Error('Standard input \'' + err.syscall + '\' error: ' + err.stack));
      });
    }
    if (proc.stdout) {
      proc.stdout.on('error', function (err) {
        reject(new Error('Standard output \'' + err.syscall + '\' error: ' + err.stack));
      });
    }
    if (proc.stderr) {
      proc.stderr.on('error', function (err) {
        reject(new Error('Standard error \'' + err.syscall + '\' error: ' + err.stack));
      });
    }

    // keep track of stdout/stderr if we haven't said not to
    if (!opts.ignoreOutput) {
      if (proc.stdout) {
        proc.stdout.on('data', function (data) {
          stdoutArr.push(data);
        });
      }
      if (proc.stderr) {
        proc.stderr.on('data', function (data) {
          stderrArr.push(data);
        });
      }
    }

    function getStdio(isBuffer) {
      var stdout = undefined,
          stderr = undefined;
      if (isBuffer) {
        stdout = Buffer.concat(stdoutArr);
        stderr = Buffer.concat(stderrArr);
      } else {
        stdout = Buffer.concat(stdoutArr).toString(opts.encoding);
        stderr = Buffer.concat(stderrArr).toString(opts.encoding);
      }
      return { stdout: stdout, stderr: stderr };
    }

    // if the process ends, either resolve or reject the promise based on the
    // exit code of the process. either way, attach stdout, stderr, and code.
    // Also clean up the timer if it exists
    proc.on('close', function (code) {
      if (timer) {
        clearTimeout(timer);
      }

      var _getStdio = getStdio(opts.isBuffer);

      var stdout = _getStdio.stdout;
      var stderr = _getStdio.stderr;

      if (code === 0) {
        resolve({ stdout: stdout, stderr: stderr, code: code });
      } else {
        var err = new Error('Command \'' + rep + '\' exited with code ' + code);
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: code });
        reject(err);
      }
    });

    // if we set a timeout on the child process, cut into the execution and
    // reject if the timeout is reached. Attach the stdout/stderr we currently
    // have in case it's helpful in debugging
    if (opts.timeout) {
      timer = setTimeout(function () {
        var _getStdio2 = getStdio(opts.isBuffer);

        var stdout = _getStdio2.stdout;
        var stderr = _getStdio2.stderr;

        var err = new Error('Command \'' + rep + '\' timed out after ' + opts.timeout + 'ms');
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: null });
        reject(err);
        // reject and THEN kill to avoid race conditions with the handlers
        // above
        proc.kill(opts.killSignal);
      }, opts.timeout);
    }
  });
}

var SubProcess = (function (_EventEmitter) {
  _inherits(SubProcess, _EventEmitter);

  function SubProcess(cmd) {
    var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, SubProcess);

    _get(Object.getPrototypeOf(SubProcess.prototype), 'constructor', this).call(this);
    if (!cmd) throw new Error("Command is required"); // eslint-disable-line curly
    if (typeof cmd !== "string") throw new Error("Command must be a string"); // eslint-disable-line curly
    if (!(args instanceof Array)) throw new Error("Args must be an array"); // eslint-disable-line curly
    this.cmd = cmd;
    this.args = args;
    this.proc = null;
    this.opts = opts;
    this.expectingExit = false;
  }

  _createClass(SubProcess, [{
    key: 'emitLines',
    value: function emitLines(stream, lines) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(lines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var line = _step.value;

          this.emit('stream-line', '[' + stream.toUpperCase() + '] ' + line);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    // spawn the subprocess and return control whenever we deem that it has fully
    // "started"
  }, {
    key: 'start',
    value: function start() {
      var startDetector = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
      var timeoutMs = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      var startDelay;
      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            startDelay = 10;

            // the default start detector simply returns true when we get any output
            if (startDetector === null) {
              startDetector = function (stdout, stderr) {
                return stdout || stderr;
              };
            }

            // if the user passes a number, then we simply delay a certain amount of
            // time before returning control, rather than waiting for a condition
            if (typeof startDetector === 'number') {
              startDelay = startDetector;
              startDetector = null;
            }

            // return a promise so we can wrap the async behavior
            return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
              // actually spawn the subproc
              _this.proc = (0, _child_process.spawn)(_this.cmd, _this.args, _this.opts);

              if (_this.proc.stdout) {
                _this.proc.stdout.setEncoding(_this.opts.encoding || 'utf8');
              }
              if (_this.proc.stderr) {
                _this.proc.stderr.setEncoding(_this.opts.encoding || 'utf8');
              }
              _this.lastLinePortion = { stdout: "", stderr: "" };

              // this function handles output that we collect from the subproc
              var handleOutput = function handleOutput(data) {
                // if we have a startDetector, run it on the output so we can resolve/
                // reject and move on from start
                try {
                  if (startDetector && startDetector(data.stdout, data.stderr)) {
                    startDetector = null;
                    resolve();
                  }
                } catch (e) {
                  reject(e);
                }

                // emit the actual output for whomever's listening
                _this.emit('output', data.stdout, data.stderr);

                // we also want to emit lines, but it's more complex since output
                // comes in chunks and a line could come in two different chunks, so
                // we have logic to handle that case (using this.lastLinePortion to
                // remember a line that started but did not finish in the last chunk)
                var _arr = ['stdout', 'stderr'];
                for (var _i = 0; _i < _arr.length; _i++) {
                  var stream = _arr[_i];
                  if (!data[stream]) continue; // eslint-disable-line curly
                  var lines = data[stream].split("\n");
                  if (lines.length > 1) {
                    var retLines = lines.slice(0, -1);
                    retLines[0] = _this.lastLinePortion[stream] + retLines[0];
                    _this.lastLinePortion[stream] = lines[lines.length - 1];
                    _this.emit('lines-' + stream, retLines);
                    _this.emitLines(stream, retLines);
                  } else {
                    _this.lastLinePortion[stream] += lines[0];
                  }
                }
              };

              // if we get an error spawning the proc, reject and clean up the proc
              _this.proc.on('error', function (err) {
                _this.proc.removeAllListeners('exit');
                _this.proc.kill('SIGINT');

                if (err.errno === 'ENOENT') {
                  err = new Error('Command \'' + _this.cmd + '\' not found. Is it installed?');
                }
                reject(err);
              });

              if (_this.proc.stdout) {
                _this.proc.stdout.pipe((0, _through2['default'])(function (stdout) {
                  handleOutput({ stdout: stdout, stderr: '' });
                }));
              }

              if (_this.proc.stderr) {
                _this.proc.stderr.pipe((0, _through2['default'])(function (stderr) {
                  handleOutput({ stdout: '', stderr: stderr });
                }));
              }

              // when the proc exits, we might still have a buffer of lines we were
              // waiting on more chunks to complete. Go ahead and emit those, then
              // re-emit the exit so a listener can handle the possibly-unexpected exit
              _this.proc.on('exit', function (code, signal) {
                _this.handleLastLines();

                _this.emit('exit', code, signal);

                // in addition to the bare exit event, also emit one of three other
                // events that contain more helpful information:
                // 'stop': we stopped this
                // 'die': the process ended out of our control with a non-zero exit
                // 'end': the process ended out of our control with a zero exit
                var event = _this.expectingExit ? 'stop' : 'die';
                if (!_this.expectingExit && code === 0) {
                  event = 'end';
                }
                _this.emit(event, code, signal);

                // finally clean up the proc and make sure to reset our exit
                // expectations
                _this.proc = null;
                _this.expectingExit = false;
              });

              // if the user hasn't given us a startDetector, instead just resolve
              // when startDelay ms have passed
              if (!startDetector) {
                setTimeout(function () {
                  resolve();
                }, startDelay);
              }

              // if the user has given us a timeout, start the clock for rejecting
              // the promise if we take too long to start
              if (typeof timeoutMs === "number") {
                setTimeout(function () {
                  reject(new Error("The process did not start in the allotted time " + ('(' + timeoutMs + 'ms)')));
                }, timeoutMs);
              }
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'handleLastLines',
    value: function handleLastLines() {
      var _arr2 = ['stdout', 'stderr'];

      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
        var stream = _arr2[_i2];
        if (this.lastLinePortion[stream]) {
          var lastLines = [this.lastLinePortion[stream]];
          this.emit('lines-' + stream, lastLines);
          this.emitLines(stream, lastLines);
          this.lastLinePortion[stream] = '';
        }
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var signal = arguments.length <= 0 || arguments[0] === undefined ? 'SIGTERM' : arguments[0];
      var timeout = arguments.length <= 1 || arguments[1] === undefined ? 10000 : arguments[1];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isRunning) {
              context$2$0.next = 2;
              break;
            }

            throw new Error('Can\'t stop process; it\'s not currently running (cmd: \'' + this.cmd + '\')');

          case 2:
            // make sure to emit any data in our lines buffer whenever we're done with
            // the proc
            this.handleLastLines();
            return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
              _this2.proc.on('close', resolve);
              _this2.expectingExit = true;
              _this2.proc.kill(signal);
              setTimeout(function () {
                reject(new Error('Process didn\'t end after ' + timeout + 'ms'));
              }, timeout);
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'join',
    value: function join() {
      var allowedExitCodes = arguments.length <= 0 || arguments[0] === undefined ? [0] : arguments[0];
      return _regeneratorRuntime.async(function join$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isRunning) {
              context$2$0.next = 2;
              break;
            }

            throw new Error("Can't join process; it's not currently running");

          case 2:
            return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
              _this3.proc.on('exit', function (code) {
                if (allowedExitCodes.indexOf(code) === -1) {
                  reject(new Error('Process ended with exitcode ' + code));
                } else {
                  resolve(code);
                }
              });
            }));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'isRunning',
    get: function get() {
      // presence of `proc` means we have connected and started
      return !!this.proc;
    }
  }]);

  return SubProcess;
})(EventEmitter);

exports.exec = exec;
exports.spawn = _child_process.spawn;
exports.SubProcess = SubProcess;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90ZWVuX3Byb2Nlc3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQUVzQixlQUFlOzswQkFDZixhQUFhOztzQkFDaEIsUUFBUTs7Ozt1QkFDUCxTQUFTOzs7O3dCQUVmLFVBQVU7Ozs7SUFEaEIsWUFBWSx1QkFBWixZQUFZOztBQUlwQixTQUFTLElBQUksQ0FBRSxHQUFHLEVBQXdCO01BQXRCLElBQUkseURBQUcsRUFBRTtNQUFFLElBQUkseURBQUcsRUFBRTs7O0FBRXRDLE1BQUksR0FBRyxHQUFHLHVCQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Ozs7QUFJcEMsTUFBSSxHQUFHLGVBQWM7QUFDbkIsV0FBTyxFQUFFLElBQUk7QUFDYixZQUFRLEVBQUUsTUFBTTtBQUNoQixjQUFVLEVBQUUsU0FBUztBQUNyQixPQUFHLEVBQUUsU0FBUztBQUNkLE9BQUcsRUFBRSxPQUFPLENBQUMsR0FBRztBQUNoQixnQkFBWSxFQUFFLEtBQUs7QUFDbkIsU0FBSyxFQUFFLFNBQVM7QUFDaEIsWUFBUSxFQUFFLEtBQUs7QUFDZixTQUFLLEVBQUUsU0FBUztHQUNqQixFQUFFLElBQUksQ0FBQyxDQUFDOzs7QUFHVCxTQUFPLDBCQUFNLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSzs7O0FBR2hDLFFBQUksSUFBSSxHQUFHLDBCQUFNLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBQyxDQUFDLENBQUM7QUFDL0UsUUFBSSxTQUFTLEdBQUcsRUFBRTtRQUFFLFNBQVMsR0FBRyxFQUFFO1FBQUUsS0FBSyxHQUFHLElBQUksQ0FBQzs7O0FBR2pELFFBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFVBQUMsR0FB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LENBQUMsQ0FBQztBQUN2Qix3QkFBVSxDQUFDLFlBQU07QUFDZixzQkFBTSxDQUFDLElBQUksS0FBSyxnQ0FBNkIsT0FBTyxRQUFLLENBQUMsQ0FBQztlQUM1RCxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ2IsQ0FBQzs7Ozs7OztLQUNIOzs7V0FFVTtVQUFDLGdCQUFnQix5REFBRyxDQUFDLENBQUMsQ0FBQzs7Ozs7O2dCQUMzQixJQUFJLENBQUMsU0FBUzs7Ozs7a0JBQ1gsSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUM7OztnREFHNUQsMEJBQU0sVUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFLO0FBQ2hDLHFCQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLFVBQUMsSUFBSSxFQUFLO0FBQzdCLG9CQUFJLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUN6Qyx3QkFBTSxDQUFDLElBQUksS0FBSyxrQ0FBZ0MsSUFBSSxDQUFHLENBQUMsQ0FBQztpQkFDMUQsTUFBTTtBQUNMLHlCQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ2Y7ZUFDRixDQUFDLENBQUM7YUFDSixDQUFDOzs7Ozs7O0tBQ0g7OztTQXpMYSxlQUFHOztBQUVmLGFBQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7S0FDcEI7OztTQWhCRyxVQUFVO0dBQVMsWUFBWTs7UUF5TTVCLElBQUksR0FBSixJQUFJO1FBQUUsS0FBSztRQUFFLFVBQVUsR0FBVixVQUFVIiwiZmlsZSI6ImxpYi90ZWVuX3Byb2Nlc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by1jYWxsYmFja3MgKi9cblxuaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHF1b3RlIH0gZnJvbSAnc2hlbGwtcXVvdGUnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IHRocm91Z2ggZnJvbSAndGhyb3VnaCc7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gZXZlbnRzO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuXG5cbmZ1bmN0aW9uIGV4ZWMgKGNtZCwgYXJncyA9IFtdLCBvcHRzID0ge30pIHtcbiAgLy8gZ2V0IGEgcXVvdGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21tYW5kIGZvciBlcnJvciBzdHJpbmdzXG4gIGxldCByZXAgPSBxdW90ZShbY21kXS5jb25jYXQoYXJncykpO1xuXG4gIC8vIGV4dGVuZCBkZWZhdWx0IG9wdGlvbnM7IHdlJ3JlIGJhc2ljYWxseSByZS1pbXBsZW1lbnRpbmcgZXhlYydzIG9wdGlvbnNcbiAgLy8gZm9yIHVzZSBoZXJlIHdpdGggc3Bhd24gdW5kZXIgdGhlIGhvb2RcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHRpbWVvdXQ6IG51bGwsXG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBraWxsU2lnbmFsOiAnU0lHVEVSTScsXG4gICAgY3dkOiB1bmRlZmluZWQsXG4gICAgZW52OiBwcm9jZXNzLmVudixcbiAgICBpZ25vcmVPdXRwdXQ6IGZhbHNlLFxuICAgIHN0ZGlvOiBcImluaGVyaXRcIixcbiAgICBpc0J1ZmZlcjogZmFsc2UsXG4gICAgc2hlbGw6IHVuZGVmaW5lZCxcbiAgfSwgb3B0cyk7XG5cbiAgLy8gdGhpcyBpcyBhbiBhc3luYyBmdW5jdGlvbiwgc28gcmV0dXJuIGEgcHJvbWlzZVxuICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIHNwYXduIHRoZSBjaGlsZCBwcm9jZXNzIHdpdGggb3B0aW9uczsgd2UgZG9uJ3QgY3VycmVudGx5IGV4cG9zZSBhbnkgb2ZcbiAgICAvLyB0aGUgb3RoZXIgJ3NwYXduJyBvcHRpb25zIHRocm91Z2ggdGhlIEFQSVxuICAgIGxldCBwcm9jID0gc3Bhd24oY21kLCBhcmdzLCB7Y3dkOiBvcHRzLmN3ZCwgZW52OiBvcHRzLmVudiwgc2hlbGw6IG9wdHMuc2hlbGx9KTtcbiAgICBsZXQgc3Rkb3V0QXJyID0gW10sIHN0ZGVyckFyciA9IFtdLCB0aW1lciA9IG51bGw7XG5cbiAgICAvLyBpZiB0aGUgcHJvY2VzcyBlcnJvcnMgb3V0LCByZWplY3QgdGhlIHByb21pc2VcbiAgICBwcm9jLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGxldCBtc2cgPSBgQ29tbWFuZCAnJHtyZXB9JyBlcnJvcmVkIG91dDogJHtlcnIuc3RhY2t9YDtcbiAgICAgIGlmIChlcnIuZXJybm8gPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIG1zZyA9IGBDb21tYW5kICcke2NtZH0nIG5vdCBmb3VuZC4gSXMgaXQgaW5zdGFsbGVkP2A7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEVycm9yKG1zZykpO1xuICAgIH0pO1xuICAgIGlmIChwcm9jLnN0ZGluKSB7XG4gICAgICBwcm9jLnN0ZGluLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgU3RhbmRhcmQgaW5wdXQgJyR7ZXJyLnN5c2NhbGx9JyBlcnJvcjogJHtlcnIuc3RhY2t9YCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwcm9jLnN0ZG91dCkge1xuICAgICAgcHJvYy5zdGRvdXQub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBTdGFuZGFyZCBvdXRwdXQgJyR7ZXJyLnN5c2NhbGx9JyBlcnJvcjogJHtlcnIuc3RhY2t9YCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwcm9jLnN0ZGVycikge1xuICAgICAgcHJvYy5zdGRlcnIub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBTdGFuZGFyZCBlcnJvciAnJHtlcnIuc3lzY2FsbH0nIGVycm9yOiAke2Vyci5zdGFja31gKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHN0ZG91dC9zdGRlcnIgaWYgd2UgaGF2ZW4ndCBzYWlkIG5vdCB0b1xuICAgIGlmICghb3B0cy5pZ25vcmVPdXRwdXQpIHtcbiAgICAgIGlmIChwcm9jLnN0ZG91dCkge1xuICAgICAgICBwcm9jLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgc3Rkb3V0QXJyLnB1c2goZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Muc3RkZXJyKSB7XG4gICAgICAgIHByb2Muc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBzdGRlcnJBcnIucHVzaChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RkaW8gKGlzQnVmZmVyKSB7XG4gICAgICBsZXQgc3Rkb3V0LCBzdGRlcnI7XG4gICAgICBpZiAoaXNCdWZmZXIpIHtcbiAgICAgICAgc3Rkb3V0ID0gQnVmZmVyLmNvbmNhdChzdGRvdXRBcnIpO1xuICAgICAgICBzdGRlcnIgPSBCdWZmZXIuY29uY2F0KHN0ZGVyckFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGRvdXQgPSBCdWZmZXIuY29uY2F0KHN0ZG91dEFycikudG9TdHJpbmcob3B0cy5lbmNvZGluZyk7XG4gICAgICAgIHN0ZGVyciA9IEJ1ZmZlci5jb25jYXQoc3RkZXJyQXJyKS50b1N0cmluZyhvcHRzLmVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7c3Rkb3V0LCBzdGRlcnJ9O1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBwcm9jZXNzIGVuZHMsIGVpdGhlciByZXNvbHZlIG9yIHJlamVjdCB0aGUgcHJvbWlzZSBiYXNlZCBvbiB0aGVcbiAgICAvLyBleGl0IGNvZGUgb2YgdGhlIHByb2Nlc3MuIGVpdGhlciB3YXksIGF0dGFjaCBzdGRvdXQsIHN0ZGVyciwgYW5kIGNvZGUuXG4gICAgLy8gQWxzbyBjbGVhbiB1cCB0aGUgdGltZXIgaWYgaXQgZXhpc3RzXG4gICAgcHJvYy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgICBsZXQge3N0ZG91dCwgc3RkZXJyfSA9IGdldFN0ZGlvKG9wdHMuaXNCdWZmZXIpO1xuICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZSh7c3Rkb3V0LCBzdGRlcnIsIGNvZGV9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoYENvbW1hbmQgJyR7cmVwfScgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCk7XG4gICAgICAgIGVyciA9IE9iamVjdC5hc3NpZ24oZXJyLCB7c3Rkb3V0LCBzdGRlcnIsIGNvZGV9KTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB3ZSBzZXQgYSB0aW1lb3V0IG9uIHRoZSBjaGlsZCBwcm9jZXNzLCBjdXQgaW50byB0aGUgZXhlY3V0aW9uIGFuZFxuICAgIC8vIHJlamVjdCBpZiB0aGUgdGltZW91dCBpcyByZWFjaGVkLiBBdHRhY2ggdGhlIHN0ZG91dC9zdGRlcnIgd2UgY3VycmVudGx5XG4gICAgLy8gaGF2ZSBpbiBjYXNlIGl0J3MgaGVscGZ1bCBpbiBkZWJ1Z2dpbmdcbiAgICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQge3N0ZG91dCwgc3RkZXJyfSA9IGdldFN0ZGlvKG9wdHMuaXNCdWZmZXIpO1xuICAgICAgICBsZXQgZXJyID0gbmV3IEVycm9yKGBDb21tYW5kICcke3JlcH0nIHRpbWVkIG91dCBhZnRlciAke29wdHMudGltZW91dH1tc2ApO1xuICAgICAgICBlcnIgPSBPYmplY3QuYXNzaWduKGVyciwge3N0ZG91dCwgc3RkZXJyLCBjb2RlOiBudWxsfSk7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAvLyByZWplY3QgYW5kIFRIRU4ga2lsbCB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgd2l0aCB0aGUgaGFuZGxlcnNcbiAgICAgICAgLy8gYWJvdmVcbiAgICAgICAgcHJvYy5raWxsKG9wdHMua2lsbFNpZ25hbCk7XG4gICAgICB9LCBvcHRzLnRpbWVvdXQpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNsYXNzIFN1YlByb2Nlc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoY21kLCBhcmdzID0gW10sIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFjbWQpIHRocm93IG5ldyBFcnJvcihcIkNvbW1hbmQgaXMgcmVxdWlyZWRcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICBpZiAodHlwZW9mIGNtZCAhPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWFuZCBtdXN0IGJlIGEgc3RyaW5nXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgaWYgKCEoYXJncyBpbnN0YW5jZW9mIEFycmF5KSkgdGhyb3cgbmV3IEVycm9yKFwiQXJncyBtdXN0IGJlIGFuIGFycmF5XCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgdGhpcy5jbWQgPSBjbWQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5leHBlY3RpbmdFeGl0ID0gZmFsc2U7XG4gIH1cblxuICBnZXQgaXNSdW5uaW5nICgpIHtcbiAgICAvLyBwcmVzZW5jZSBvZiBgcHJvY2AgbWVhbnMgd2UgaGF2ZSBjb25uZWN0ZWQgYW5kIHN0YXJ0ZWRcbiAgICByZXR1cm4gISF0aGlzLnByb2M7XG4gIH1cblxuICBlbWl0TGluZXMgKHN0cmVhbSwgbGluZXMpIHtcbiAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICB0aGlzLmVtaXQoJ3N0cmVhbS1saW5lJywgYFske3N0cmVhbS50b1VwcGVyQ2FzZSgpfV0gJHtsaW5lfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNwYXduIHRoZSBzdWJwcm9jZXNzIGFuZCByZXR1cm4gY29udHJvbCB3aGVuZXZlciB3ZSBkZWVtIHRoYXQgaXQgaGFzIGZ1bGx5XG4gIC8vIFwic3RhcnRlZFwiXG4gIGFzeW5jIHN0YXJ0IChzdGFydERldGVjdG9yID0gbnVsbCwgdGltZW91dE1zID0gbnVsbCkge1xuICAgIGxldCBzdGFydERlbGF5ID0gMTA7XG5cbiAgICAvLyB0aGUgZGVmYXVsdCBzdGFydCBkZXRlY3RvciBzaW1wbHkgcmV0dXJucyB0cnVlIHdoZW4gd2UgZ2V0IGFueSBvdXRwdXRcbiAgICBpZiAoc3RhcnREZXRlY3RvciA9PT0gbnVsbCkge1xuICAgICAgc3RhcnREZXRlY3RvciA9IChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICByZXR1cm4gc3Rkb3V0IHx8IHN0ZGVycjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHVzZXIgcGFzc2VzIGEgbnVtYmVyLCB0aGVuIHdlIHNpbXBseSBkZWxheSBhIGNlcnRhaW4gYW1vdW50IG9mXG4gICAgLy8gdGltZSBiZWZvcmUgcmV0dXJuaW5nIGNvbnRyb2wsIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGEgY29uZGl0aW9uXG4gICAgaWYgKHR5cGVvZiBzdGFydERldGVjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgc3RhcnREZWxheSA9IHN0YXJ0RGV0ZWN0b3I7XG4gICAgICBzdGFydERldGVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gYSBwcm9taXNlIHNvIHdlIGNhbiB3cmFwIHRoZSBhc3luYyBiZWhhdmlvclxuICAgIHJldHVybiBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBhY3R1YWxseSBzcGF3biB0aGUgc3VicHJvY1xuICAgICAgdGhpcy5wcm9jID0gc3Bhd24odGhpcy5jbWQsIHRoaXMuYXJncywgdGhpcy5vcHRzKTtcblxuICAgICAgaWYgKHRoaXMucHJvYy5zdGRvdXQpIHtcbiAgICAgICAgdGhpcy5wcm9jLnN0ZG91dC5zZXRFbmNvZGluZyh0aGlzLm9wdHMuZW5jb2RpbmcgfHwgJ3V0ZjgnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByb2Muc3RkZXJyKSB7XG4gICAgICAgIHRoaXMucHJvYy5zdGRlcnIuc2V0RW5jb2RpbmcodGhpcy5vcHRzLmVuY29kaW5nIHx8ICd1dGY4Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RMaW5lUG9ydGlvbiA9IHtzdGRvdXQ6IFwiXCIsIHN0ZGVycjogXCJcIn07XG5cbiAgICAgIC8vIHRoaXMgZnVuY3Rpb24gaGFuZGxlcyBvdXRwdXQgdGhhdCB3ZSBjb2xsZWN0IGZyb20gdGhlIHN1YnByb2NcbiAgICAgIGNvbnN0IGhhbmRsZU91dHB1dCA9IChkYXRhKSA9PiB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBzdGFydERldGVjdG9yLCBydW4gaXQgb24gdGhlIG91dHB1dCBzbyB3ZSBjYW4gcmVzb2x2ZS9cbiAgICAgICAgLy8gcmVqZWN0IGFuZCBtb3ZlIG9uIGZyb20gc3RhcnRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3RhcnREZXRlY3RvciAmJiBzdGFydERldGVjdG9yKGRhdGEuc3Rkb3V0LCBkYXRhLnN0ZGVycikpIHtcbiAgICAgICAgICAgIHN0YXJ0RGV0ZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgdGhlIGFjdHVhbCBvdXRwdXQgZm9yIHdob21ldmVyJ3MgbGlzdGVuaW5nXG4gICAgICAgIHRoaXMuZW1pdCgnb3V0cHV0JywgZGF0YS5zdGRvdXQsIGRhdGEuc3RkZXJyKTtcblxuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gZW1pdCBsaW5lcywgYnV0IGl0J3MgbW9yZSBjb21wbGV4IHNpbmNlIG91dHB1dFxuICAgICAgICAvLyBjb21lcyBpbiBjaHVua3MgYW5kIGEgbGluZSBjb3VsZCBjb21lIGluIHR3byBkaWZmZXJlbnQgY2h1bmtzLCBzb1xuICAgICAgICAvLyB3ZSBoYXZlIGxvZ2ljIHRvIGhhbmRsZSB0aGF0IGNhc2UgKHVzaW5nIHRoaXMubGFzdExpbmVQb3J0aW9uIHRvXG4gICAgICAgIC8vIHJlbWVtYmVyIGEgbGluZSB0aGF0IHN0YXJ0ZWQgYnV0IGRpZCBub3QgZmluaXNoIGluIHRoZSBsYXN0IGNodW5rKVxuICAgICAgICBmb3IgKGxldCBzdHJlYW0gb2YgWydzdGRvdXQnLCAnc3RkZXJyJ10pIHtcbiAgICAgICAgICBpZiAoIWRhdGFbc3RyZWFtXSkgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhW3N0cmVhbV0uc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCByZXRMaW5lcyA9IGxpbmVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIHJldExpbmVzWzBdID0gdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSArIHJldExpbmVzWzBdO1xuICAgICAgICAgICAgdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGBsaW5lcy0ke3N0cmVhbX1gLCByZXRMaW5lcyk7XG4gICAgICAgICAgICB0aGlzLmVtaXRMaW5lcyhzdHJlYW0sIHJldExpbmVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSArPSBsaW5lc1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGlmIHdlIGdldCBhbiBlcnJvciBzcGF3bmluZyB0aGUgcHJvYywgcmVqZWN0IGFuZCBjbGVhbiB1cCB0aGUgcHJvY1xuICAgICAgdGhpcy5wcm9jLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgIHRoaXMucHJvYy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2V4aXQnKTtcbiAgICAgICAgdGhpcy5wcm9jLmtpbGwoJ1NJR0lOVCcpO1xuXG4gICAgICAgIGlmIChlcnIuZXJybm8gPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgZXJyID0gbmV3IEVycm9yKGBDb21tYW5kICcke3RoaXMuY21kfScgbm90IGZvdW5kLiBJcyBpdCBpbnN0YWxsZWQ/YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucHJvYy5zdGRvdXQpIHtcbiAgICAgICAgdGhpcy5wcm9jLnN0ZG91dC5waXBlKHRocm91Z2goc3Rkb3V0ID0+IHtcbiAgICAgICAgICBoYW5kbGVPdXRwdXQoe3N0ZG91dCwgc3RkZXJyOiAnJ30pO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb2Muc3RkZXJyKSB7XG4gICAgICAgIHRoaXMucHJvYy5zdGRlcnIucGlwZSh0aHJvdWdoKHN0ZGVyciA9PiB7XG4gICAgICAgICAgaGFuZGxlT3V0cHV0KHtzdGRvdXQ6ICcnLCBzdGRlcnJ9KTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHRoZSBwcm9jIGV4aXRzLCB3ZSBtaWdodCBzdGlsbCBoYXZlIGEgYnVmZmVyIG9mIGxpbmVzIHdlIHdlcmVcbiAgICAgIC8vIHdhaXRpbmcgb24gbW9yZSBjaHVua3MgdG8gY29tcGxldGUuIEdvIGFoZWFkIGFuZCBlbWl0IHRob3NlLCB0aGVuXG4gICAgICAvLyByZS1lbWl0IHRoZSBleGl0IHNvIGEgbGlzdGVuZXIgY2FuIGhhbmRsZSB0aGUgcG9zc2libHktdW5leHBlY3RlZCBleGl0XG4gICAgICB0aGlzLnByb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlTGFzdExpbmVzKCk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdleGl0JywgY29kZSwgc2lnbmFsKTtcblxuICAgICAgICAvLyBpbiBhZGRpdGlvbiB0byB0aGUgYmFyZSBleGl0IGV2ZW50LCBhbHNvIGVtaXQgb25lIG9mIHRocmVlIG90aGVyXG4gICAgICAgIC8vIGV2ZW50cyB0aGF0IGNvbnRhaW4gbW9yZSBoZWxwZnVsIGluZm9ybWF0aW9uOlxuICAgICAgICAvLyAnc3RvcCc6IHdlIHN0b3BwZWQgdGhpc1xuICAgICAgICAvLyAnZGllJzogdGhlIHByb2Nlc3MgZW5kZWQgb3V0IG9mIG91ciBjb250cm9sIHdpdGggYSBub24temVybyBleGl0XG4gICAgICAgIC8vICdlbmQnOiB0aGUgcHJvY2VzcyBlbmRlZCBvdXQgb2Ygb3VyIGNvbnRyb2wgd2l0aCBhIHplcm8gZXhpdFxuICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLmV4cGVjdGluZ0V4aXQgPyAnc3RvcCcgOiAnZGllJztcbiAgICAgICAgaWYgKCF0aGlzLmV4cGVjdGluZ0V4aXQgJiYgY29kZSA9PT0gMCkge1xuICAgICAgICAgIGV2ZW50ID0gJ2VuZCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCBjb2RlLCBzaWduYWwpO1xuXG4gICAgICAgIC8vIGZpbmFsbHkgY2xlYW4gdXAgdGhlIHByb2MgYW5kIG1ha2Ugc3VyZSB0byByZXNldCBvdXIgZXhpdFxuICAgICAgICAvLyBleHBlY3RhdGlvbnNcbiAgICAgICAgdGhpcy5wcm9jID0gbnVsbDtcbiAgICAgICAgdGhpcy5leHBlY3RpbmdFeGl0ID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgdGhlIHVzZXIgaGFzbid0IGdpdmVuIHVzIGEgc3RhcnREZXRlY3RvciwgaW5zdGVhZCBqdXN0IHJlc29sdmVcbiAgICAgIC8vIHdoZW4gc3RhcnREZWxheSBtcyBoYXZlIHBhc3NlZFxuICAgICAgaWYgKCFzdGFydERldGVjdG9yKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyByZXNvbHZlKCk7IH0sIHN0YXJ0RGVsYXkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgdXNlciBoYXMgZ2l2ZW4gdXMgYSB0aW1lb3V0LCBzdGFydCB0aGUgY2xvY2sgZm9yIHJlamVjdGluZ1xuICAgICAgLy8gdGhlIHByb21pc2UgaWYgd2UgdGFrZSB0b28gbG9uZyB0byBzdGFydFxuICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0TXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRoZSBwcm9jZXNzIGRpZCBub3Qgc3RhcnQgaW4gdGhlIGFsbG90dGVkIHRpbWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYCgke3RpbWVvdXRNc31tcylgKSk7XG4gICAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVMYXN0TGluZXMgKCkge1xuICAgIGZvciAobGV0IHN0cmVhbSBvZiBbJ3N0ZG91dCcsICdzdGRlcnInXSkge1xuICAgICAgaWYgKHRoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV0pIHtcbiAgICAgICAgY29uc3QgbGFzdExpbmVzID0gW3RoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV1dO1xuICAgICAgICB0aGlzLmVtaXQoYGxpbmVzLSR7c3RyZWFtfWAsIGxhc3RMaW5lcyk7XG4gICAgICAgIHRoaXMuZW1pdExpbmVzKHN0cmVhbSwgbGFzdExpbmVzKTtcbiAgICAgICAgdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0b3AgKHNpZ25hbCA9ICdTSUdURVJNJywgdGltZW91dCA9IDEwMDAwKSB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdG9wIHByb2Nlc3M7IGl0J3Mgbm90IGN1cnJlbnRseSBydW5uaW5nIChjbWQ6ICcke3RoaXMuY21kfScpYCk7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0byBlbWl0IGFueSBkYXRhIGluIG91ciBsaW5lcyBidWZmZXIgd2hlbmV2ZXIgd2UncmUgZG9uZSB3aXRoXG4gICAgLy8gdGhlIHByb2NcbiAgICB0aGlzLmhhbmRsZUxhc3RMaW5lcygpO1xuICAgIHJldHVybiBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnByb2Mub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gICAgICB0aGlzLmV4cGVjdGluZ0V4aXQgPSB0cnVlO1xuICAgICAgdGhpcy5wcm9jLmtpbGwoc2lnbmFsKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBQcm9jZXNzIGRpZG4ndCBlbmQgYWZ0ZXIgJHt0aW1lb3V0fW1zYCkpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBqb2luIChhbGxvd2VkRXhpdENvZGVzID0gWzBdKSB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgam9pbiBwcm9jZXNzOyBpdCdzIG5vdCBjdXJyZW50bHkgcnVubmluZ1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKGFsbG93ZWRFeGl0Q29kZXMuaW5kZXhPZihjb2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBQcm9jZXNzIGVuZGVkIHdpdGggZXhpdGNvZGUgJHtjb2RlfWApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBleGVjLCBzcGF3biwgU3ViUHJvY2VzcyB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
