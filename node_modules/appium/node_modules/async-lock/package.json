{
  "_args": [
    [
      {
        "raw": "async-lock@https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
        "scope": null,
        "escapedName": "async-lock",
        "name": "async-lock",
        "rawSpec": "https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
        "spec": "https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
        "type": "remote"
      },
      "/Users/saxenan3/myprojects/uiAutomation/mytest_project/node_modules/appium"
    ]
  ],
  "_from": "async-lock@https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
  "_id": "async-lock@1.1.2",
  "_inCache": true,
  "_location": "/appium/async-lock",
  "_phantomChildren": {},
  "_requested": {
    "raw": "async-lock@https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
    "scope": null,
    "escapedName": "async-lock",
    "name": "async-lock",
    "rawSpec": "https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
    "spec": "https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/appium",
    "/appium/appium-xcuitest-driver",
    "/appium/appium-xcuitest-driver/appium-ios-simulator"
  ],
  "_resolved": "https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
  "_shasum": "d552b3f8fe93018bf917efcf66d3154b9035282a",
  "_shrinkwrap": null,
  "_spec": "async-lock@https://registry.npmjs.org/async-lock/-/async-lock-1.1.2.tgz",
  "_where": "/Users/saxenan3/myprojects/uiAutomation/mytest_project/node_modules/appium",
  "author": {
    "name": "Rogier Schouten",
    "email": "github@workingcode.ninja",
    "url": "https://github.com/rogierschouten/"
  },
  "bugs": {
    "url": "https://github.com/rogierschouten/async-lock/issues"
  },
  "contributors": [
    {
      "name": "rain1017",
      "url": "https://github.com/rain1017"
    },
    {
      "name": "JonathanPicques",
      "url": "https://github.com/JonathanPicques"
    },
    {
      "name": "Rogier Schouten",
      "url": "https://github.com/rogierschouten"
    },
    {
      "name": "erikvold",
      "url": "https://github.com/erikvold"
    },
    {
      "name": "Christian Passet",
      "url": "https://github.com/thePunIssuer"
    },
    {
      "name": "Tanguy Krotoff",
      "url": "https://github.com/tkrotoff"
    }
  ],
  "dependencies": {},
  "description": "Lock on asynchronous code",
  "devDependencies": {
    "bluebird": "~3.5.0",
    "grunt": "^1.0.1",
    "grunt-cli": "~1.2.0",
    "grunt-contrib-clean": "~1.1.0",
    "grunt-contrib-jshint": "~1.1.0",
    "grunt-contrib-watch": "~1.0.0",
    "grunt-env": "~0.4.4",
    "grunt-mocha-test": "~0.13.2",
    "load-grunt-tasks": "~3.5.2",
    "lodash": "~4.17.2",
    "mocha": "^3.2.0",
    "q": "~1.5.0",
    "should": "~11.2.1"
  },
  "engines": {},
  "homepage": "https://github.com/rogierschouten/async-lock",
  "keywords": [
    "lock",
    "async",
    "concurrency",
    "critical",
    "section",
    "mutex"
  ],
  "license": "MIT",
  "name": "async-lock",
  "optionalDependencies": {},
  "private": false,
  "readme": "# async-lock\n\nLock on asynchronous code\n\n[![Build Status](https://travis-ci.org/rogierschouten/async-lock.svg?branch=master)](https://travis-ci.org/rogierschouten/async-lock)\n\n* ES6 promise supported\n* Multiple keys lock supported\n* Timeout supported\n* Pending task limit supported\n* Domain reentrant supported\n* 100% code coverage\n\n## Disclaimer\n\nI did not create this package, and I will not add any features to it myself. I was granted the ownership because it was no longer being\nmaintained, and I volunteered to fix a bug.\n\nIf you have a new feature you would like to have incorporated, please send me a PR and I will be happy to work with you and get it merged.\nFor any bugs, PRs are most welcome but when possible I will try to get them resolved as soon as possible.\n\n## Why do you need locking on single threaded nodejs?\n\nNodejs is single threaded, and the code execution never gets interrupted inside an event loop, so locking is unnecessary? This is true ONLY IF your critical section can be executed inside a single event loop.\nHowever, if you have any async code inside your critical section (it can be simply triggered by any I/O operation, or timer), your critical logic will across multiple event loops, therefore it's not concurrency safe!\n\nConsider the following code\n```js\nredis.get('key', function(err, value) {\n\tredis.set('key', value * 2);\n});\n```\nThe above code simply multiply a redis key by 2.\nHowever, if two users run concurrency, the execution order may like this\n```\nuser1: redis.get('key') -> 1\nuser2: redis.get('key') -> 1\nuser1: redis.set('key', 1 x 2) -> 2\nuser2: redis.set('key', 1 x 2) -> 2\n```\nObviously it's not what you expected\n\n\nWith asyncLock, you can easily write your async critical section\n```js\nlock.acquire('key', function(cb) {\n\t// Concurrency safe\n\tredis.get('key', function(err, value) {\n\t\tredis.set('key', value * 2, cb);\n\t});\n}, function(err, ret) {\n});\n```\n\n## Get Started\n\n```js\nvar AsyncLock = require('async-lock');\nvar lock = new AsyncLock();\n\n/**\n * @param {String|Array} key \tresource key or keys to lock\n * @param {function} fn \texecute function\n * @param {function} cb \t(optional) callback function, otherwise will return a promise\n * @param {Object} opts \t(optional) options\n */\nlock.acquire(key, function(done) {\n\t// async work\n\tdone(err, ret);\n}, function(err, ret) {\n\t// lock released\n}, opts);\n\n// Promise mode\nlock.acquire(key, function() {\n\t// return value or promise\n}, opts).then(function() {\n\t// lock released\n});\n```\n\n## Error Handling\n\n```js\n// Callback mode\nlock.acquire(key, function(done) {\n\tdone(new Error('error'));\n}, function(err, ret) {\n\tconsole.log(err.message) // output: error\n});\n\n// Promise mode\nlock.acquire(key, function() {\n\tthrow new Error('error');\n}).catch(function(err) {\n\tconsole.log(err.message) // output: error\n});\n```\n\n## Acquire multiple keys\n\n```js\nlock.acquire([key1, key2], fn, cb);\n```\n\n## Domain reentrant lock\n\nLock is reentrant in the same domain\n\n```js\nvar domain = require('domain');\nvar lock = new AsyncLock({domainReentrant : true});\n\nvar d = domain.create();\nd.run(function() {\n\tlock.acquire('key', function() {\n\t\t//Enter lock\n\t\treturn lock.acquire('key', function() {\n\t\t\t//Enter same lock twice\n\t\t});\n\t});\n});\n```\n\n## Options\n\n```js\n// Specify timeout\nvar lock = new AsyncLock({timeout: 5000});\nlock.acquire(key, fn, function(err, ret) {\n\t// timed out error will be returned here if lock not acquired in given time\n});\n\n// Set max pending tasks\nvar lock = new AsyncLock({maxPending: 1000});\nlock.acquire(key, fn, function(err, ret) {\n\t// Handle too much pending error\n})\n\n// Whether there is any running or pending async function\nlock.isBusy();\n\n// Use your own promise library instead of the global Promise variable\nvar lock = new AsyncLock({Promise: require('bluebird')}); // Bluebird\nvar lock = new AsyncLock({Promise: require('q')}); // Q\n\n// Add a task to the front of the queue waiting for a given lock\nlock.acquire(key, fn1, cb); // runs immediately\nlock.acquire(key, fn2, cb); // added to queue\nlock.acquire(key, priorityFn, cb, {skipQueue: true}); // jumps queue and runs before fn2\n```\n\n## Changelog\n\nSee [Changelog](./History.md)\n\n## Issues\n\nSee [isse tracker](https://github.com/rogierschouten/async-lock/issues).\n\n## License\n\nMIT, see [LICENSE](./LICENSE)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rogierschouten/async-lock.git"
  },
  "scripts": {
    "postinstall": "",
    "start": "grunt",
    "test": "grunt test"
  },
  "version": "1.1.2"
}
