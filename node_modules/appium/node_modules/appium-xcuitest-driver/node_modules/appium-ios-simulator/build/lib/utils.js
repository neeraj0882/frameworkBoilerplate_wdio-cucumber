'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _appiumXcode = require('appium-xcode');

var _nodeSimctl = require('node-simctl');

var _appiumSupport = require('appium-support');

var _certificate = require('./certificate');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _simulatorXcode6 = require('./simulator-xcode-6');

var _simulatorXcode62 = _interopRequireDefault(_simulatorXcode6);

var _fkill = require('fkill');

var _fkill2 = _interopRequireDefault(_fkill);

var DEFAULT_SIM_SHUTDOWN_TIMEOUT = 30000;

// pgrep/pkill exit codes:
// 0       One or more processes were matched.
// 1       No processes were matched.
// 2       Invalid options were specified on the command line.
// 3       An internal error occurred.

function pkill(appName) {
  var forceKill = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var args;
  return _regeneratorRuntime.async(function pkill$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = forceKill ? ['-9'] : [];

        args.push('-x', appName);
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', args));

      case 5:
        return context$1$0.abrupt('return', 0);

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](2);

        if (_lodash2['default'].isUndefined(context$1$0.t0.code)) {
          context$1$0.next = 12;
          break;
        }

        throw new Error('Cannot forcefully terminate ' + appName + '. pkill error code: ' + context$1$0.t0.code);

      case 12:
        _logger2['default'].error('Received unexpected error while trying to kill ' + appName + ': ' + context$1$0.t0.message);
        throw context$1$0.t0;

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 8]]);
}

function killAllSimulators() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_SIM_SHUTDOWN_TIMEOUT : arguments[0];

  var xcodeVersion, appName, pids, _ref, stdout, _ref2, uniquePids, remainingDevices, allSimsAreDown, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, device;

  return _regeneratorRuntime.async(function killAllSimulators$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        allSimsAreDown = function allSimsAreDown() {
          var devices;
          return _regeneratorRuntime.async(function allSimsAreDown$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                remainingDevices = [];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

              case 3:
                devices = context$2$0.sent;

                devices = _lodash2['default'].flatten(_lodash2['default'].values(devices));
                return context$2$0.abrupt('return', _lodash2['default'].every(devices, function (sim) {
                  var state = sim.state.toLowerCase();
                  var done = state === 'shutdown' || state === 'unavailable' || state === 'disconnected';
                  if (!done) {
                    remainingDevices.push(sim.name + ' (' + sim.sdk + ', udid: ' + sim.udid + ') is still in state \'' + state + '\'');
                  }
                  return done;
                }));

              case 6:
              case 'end':
                return context$2$0.stop();
            }
          }, null, this);
        };

        _logger2['default'].debug('Killing all iOS Simulators');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _appiumXcode.getVersion)(true));

      case 4:
        xcodeVersion = context$1$0.sent;
        appName = xcodeVersion.major >= 7 ? 'Simulator' : 'iOS Simulator';

        // later versions are slower to close
        timeout = timeout * (xcodeVersion.major >= 8 ? 2 : 1);

        context$1$0.prev = 7;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcrun', ['simctl', 'shutdown', xcodeVersion.major > 8 ? 'all' : 'booted'], { timeout: timeout }));

      case 10:
        context$1$0.next = 14;
        break;

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](7);

      case 14:
        pids = [];
        context$1$0.prev = 15;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('osascript', ['-e', 'tell application "System Events" to unix id of processes whose bundle identifier is "com.apple.iphonesimulator"']));

      case 18:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;

        if (stdout.trim()) {
          pids.push.apply(pids, _toConsumableArray(stdout.trim().split(/\s+/)));
        }
        context$1$0.next = 25;
        break;

      case 23:
        context$1$0.prev = 23;
        context$1$0.t1 = context$1$0['catch'](15);

      case 25:
        context$1$0.prev = 25;
        context$1$0.next = 28;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pgrep', ['-x', appName]));

      case 28:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;

        if (stdout.trim()) {
          pids.push.apply(pids, _toConsumableArray(stdout.trim().split('\n')));
        }
        context$1$0.next = 39;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t2 = context$1$0['catch'](25);

        if (!(context$1$0.t2.code === 1 && !pids.length)) {
          context$1$0.next = 38;
          break;
        }

        _logger2['default'].debug(appName + ' is not running. Continuing...');
        return context$1$0.abrupt('return');

      case 38:
        if (!pids.length) {
          _logger2['default'].warn('pgrep error ' + context$1$0.t2.code + ' while detecting whether ' + appName + ' is running. Trying to kill anyway.');
        }

      case 39:
        if (!pids.length) {
          context$1$0.next = 49;
          break;
        }

        uniquePids = _lodash2['default'].uniq(pids);

        _logger2['default'].debug('Using fkill to kill processes: ' + uniquePids.join(', '));
        context$1$0.prev = 42;
        context$1$0.next = 45;
        return _regeneratorRuntime.awrap((0, _fkill2['default'])(uniquePids, { force: true }));

      case 45:
        context$1$0.next = 49;
        break;

      case 47:
        context$1$0.prev = 47;
        context$1$0.t3 = context$1$0['catch'](42);

      case 49:

        _logger2['default'].debug('Using pkill to kill application: ' + appName);
        context$1$0.prev = 50;
        context$1$0.next = 53;
        return _regeneratorRuntime.awrap(pkill(appName, true));

      case 53:
        context$1$0.next = 57;
        break;

      case 55:
        context$1$0.prev = 55;
        context$1$0.t4 = context$1$0['catch'](50);

      case 57:
        remainingDevices = [];
        context$1$0.prev = 58;
        context$1$0.next = 61;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(allSimsAreDown, {
          waitMs: timeout,
          intervalMs: 200
        }));

      case 61:
        context$1$0.next = 87;
        break;

      case 63:
        context$1$0.prev = 63;
        context$1$0.t5 = context$1$0['catch'](58);

        if (!(remainingDevices.length > 0)) {
          context$1$0.next = 86;
          break;
        }

        _logger2['default'].warn('The following devices are still not in the correct state after ' + timeout + ' ms:');
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 70;
        for (_iterator = _getIterator(remainingDevices); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          device = _step.value;

          _logger2['default'].warn('    ' + device);
        }
        context$1$0.next = 78;
        break;

      case 74:
        context$1$0.prev = 74;
        context$1$0.t6 = context$1$0['catch'](70);
        _didIteratorError = true;
        _iteratorError = context$1$0.t6;

      case 78:
        context$1$0.prev = 78;
        context$1$0.prev = 79;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 81:
        context$1$0.prev = 81;

        if (!_didIteratorError) {
          context$1$0.next = 84;
          break;
        }

        throw _iteratorError;

      case 84:
        return context$1$0.finish(81);

      case 85:
        return context$1$0.finish(78);

      case 86:
        throw context$1$0.t5;

      case 87:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 12], [15, 23], [25, 33], [42, 47], [50, 55], [58, 63], [70, 74, 78, 86], [79,, 81, 85]]);
}

function endAllSimulatorDaemons() {
  var _arr, _i, servicePattern, launchCtlCommand, stopCmd, removeCmd;

  return _regeneratorRuntime.async(function endAllSimulatorDaemons$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Ending all simulator daemons');
        _arr = ['com.apple.iphonesimulator', 'com.apple.CoreSimulator'];
        _i = 0;

      case 3:
        if (!(_i < _arr.length)) {
          context$1$0.next = 28;
          break;
        }

        servicePattern = _arr[_i];

        _logger2['default'].debug('Killing any other ' + servicePattern + ' daemons');
        launchCtlCommand = 'launchctl list | grep ' + servicePattern + ' | cut -f 3 | xargs -n 1 launchctl';
        context$1$0.prev = 7;
        stopCmd = launchCtlCommand + ' stop';
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', stopCmd]));

      case 11:
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](7);

        _logger2['default'].warn('Could not stop ' + servicePattern + ' daemons, carrying on anyway!');

      case 16:
        context$1$0.prev = 16;
        removeCmd = launchCtlCommand + ' remove';
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', removeCmd]));

      case 20:
        context$1$0.next = 25;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t1 = context$1$0['catch'](16);

        _logger2['default'].warn('Could not remove ' + servicePattern + ' daemons, carrying on anyway!');

      case 25:
        _i++;
        context$1$0.next = 3;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          var _ref3, stdout;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', 'ps -e  | grep launchd_sim | grep -v bash | grep -v grep | awk {\'print$1\'}']));

              case 2:
                _ref3 = context$2$0.sent;
                stdout = _ref3.stdout;
                return context$2$0.abrupt('return', stdout.trim().length === 0);

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, { waitMs: 5000, intervalMs: 500 }));

      case 31:
        context$1$0.next = 36;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t2 = context$1$0['catch'](28);

        _logger2['default'].warn('Could not end all simulator daemons, carrying on!');

      case 36:
        _logger2['default'].debug('Finishing ending all simulator daemons');

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 13], [16, 22], [28, 33]]);
}

function simExists(udid) {
  var devices;
  return _regeneratorRuntime.async(function simExists$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

      case 2:
        devices = context$1$0.sent;

        devices = _lodash2['default'].toPairs(devices).map(function (pair) {
          return pair[1];
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
        return context$1$0.abrupt('return', !!_lodash2['default'].find(devices, function (sim) {
          return sim.udid === udid;
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function safeRimRaf(delPath) {
  var tryNum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
  return _regeneratorRuntime.async(function safeRimRaf$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(delPath));

      case 3:
        context$1$0.next = 16;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(tryNum < 20)) {
          context$1$0.next = 16;
          break;
        }

        if (!(context$1$0.t0.message.indexOf('ENOTEMPTY') !== -1)) {
          context$1$0.next = 13;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\' was not empty during delete; retrying');
        return context$1$0.abrupt('return', safeRimRaf(delPath, tryNum + 1));

      case 13:
        if (!(context$1$0.t0.message.indexOf('ENOENT') !== -1)) {
          context$1$0.next = 16;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\'\' did not exist when we tried to delete, ignoring');
        return context$1$0.abrupt('return', safeRimRaf(delPath, tryNum + 1));

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

/**
 * Install an SSL certificate to a device with given udid
 * @param {string} pemText SSL pem text
 * @param {string} udid Identifier of the Simulator
 */
function installSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function installSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('openssl'));

      case 3:
        context$1$0.next = 9;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('customSSLCert requires openssl to be available on path');
        _logger2['default'].errorAndThrow('Command \'openssl\' not found');

      case 9:
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('sqlite3'));

      case 12:
        context$1$0.next = 18;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t1 = context$1$0['catch'](9);

        _logger2['default'].debug('customSSLCert requires sqlite3 to be available on path');
        _logger2['default'].errorAndThrow('Command \'sqlite3\' not found');

      case 18:
        context$1$0.t2 = _path2['default'];
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 21:
        context$1$0.t3 = context$1$0.sent;
        tempFileName = context$1$0.t2.resolve.call(context$1$0.t2, context$1$0.t3, 'temp-ssl-cert.pem');
        pathToKeychain = new _simulatorXcode62['default'](udid).getDir();
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 26:
        context$1$0.prev = 26;
        context$1$0.next = 29;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(pathToKeychain));

      case 29:
        context$1$0.next = 35;
        break;

      case 31:
        context$1$0.prev = 31;
        context$1$0.t4 = context$1$0['catch'](26);

        _logger2['default'].debug('Could not install SSL certificate. No simulator with udid \'' + udid + '\'');
        _logger2['default'].errorAndThrow(context$1$0.t4);

      case 35:
        certificate = new _certificate.Certificate(tempFileName);

        _logger2['default'].debug('Installing certificate to ' + pathToKeychain);
        context$1$0.next = 39;
        return _regeneratorRuntime.awrap(certificate.add(pathToKeychain));

      case 39:
        context$1$0.next = 41;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 41:
        return context$1$0.abrupt('return', certificate);

      case 42:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5], [9, 14], [26, 31]]);
}

function uninstallSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function uninstallSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        tempFileName = _path2['default'].resolve(__dirname, 'temp-ssl-cert.pem');
        pathToKeychain = _path2['default'].resolve(new _simulatorXcode62['default'](udid).getDir());
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 5:
        certificate = new _certificate.Certificate(tempFileName);
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(certificate.remove(pathToKeychain));

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 10:
        return context$1$0.abrupt('return', certificate);

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('Could not uninstall SSL certificate. No simulator with udid \'' + udid + '\'');
        _logger2['default'].errorAndThrow(context$1$0.t0);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 13]]);
}

/**
 * Check if the Simulator already has this SSL certificate
 * @param {string} pemText PEM text of SSL cert
 * @param {string} udid Identifier of the Simulator
 */
function hasSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function hasSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = _path2['default'];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 3:
        context$1$0.t1 = context$1$0.sent;
        tempFileName = context$1$0.t0.resolve.call(context$1$0.t0, context$1$0.t1, 'temp-ssl-cert.pem');
        pathToKeychain = new _simulatorXcode62['default'](udid).getDir();
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 8:
        certificate = new _certificate.Certificate(tempFileName);
        return context$1$0.abrupt('return', certificate.has(pathToKeychain));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Runs a command line sqlite3 query
 */
function execSQLiteQuery(db, query) {
  for (var _len = arguments.length, queryParams = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    queryParams[_key - 2] = arguments[_key];
  }

  var queryTokens, formattedQuery;
  return _regeneratorRuntime.async(function execSQLiteQuery$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        queryTokens = query.split('?');
        formattedQuery = [];

        queryParams.forEach(function (param, i) {
          formattedQuery.push(queryTokens[i]);
          formattedQuery.push(param.replace(/'/g, "''"));
        });
        formattedQuery.push(queryTokens[queryTokens.length - 1]);

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('sqlite3', ['-line', db, formattedQuery.join('')]));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

exports.killAllSimulators = killAllSimulators;
exports.endAllSimulatorDaemons = endAllSimulatorDaemons;
exports.safeRimRaf = safeRimRaf;
exports.simExists = simExists;
exports.installSSLCert = installSSLCert;
exports.uninstallSSLCert = uninstallSSLCert;
exports.hasSSLCert = hasSSLCert;
exports.execSQLiteQuery = execSQLiteQuery;

// wait for all the devices to be shutdown before Continuing
// but only print out the failed ones when they are actually fully failed

// waiting until the simulator service has died.

// see the README for github.com/appium/node-simctl for example output of getDevices()

// Check that openssl is installed on the path

// Check that sqlite3 is installed on the path

// Create a temporary file to store PEM text
// (a temp file is necessary to run `openssl` shell commands, can't be done in memory)

// Do the certificate installation

// Remove the temporary file
//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUMsRUFBSztBQUNoQyx3QkFBYyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQyx3QkFBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ2hELENBQUMsQ0FBQztBQUNILHNCQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozt5Q0FFNUMsd0JBQUssU0FBUyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Q0FDckU7O1FBR0MsaUJBQWlCLEdBQWpCLGlCQUFpQjtRQUNqQixzQkFBc0IsR0FBdEIsc0JBQXNCO1FBQ3RCLFVBQVUsR0FBVixVQUFVO1FBQ1YsU0FBUyxHQUFULFNBQVM7UUFDVCxjQUFjLEdBQWQsY0FBYztRQUNkLGdCQUFnQixHQUFoQixnQkFBZ0I7UUFDaEIsVUFBVSxHQUFWLFVBQVU7UUFDVixlQUFlLEdBQWYsZUFBZSIsImZpbGUiOiJsaWIvdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBnZXRWZXJzaW9uIH0gZnJvbSAnYXBwaXVtLXhjb2RlJztcbmltcG9ydCB7IGdldERldmljZXMgfSBmcm9tICdub2RlLXNpbWN0bCc7XG5pbXBvcnQgeyBmcywgdGVtcERpciB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IENlcnRpZmljYXRlIH0gZnJvbSAnLi9jZXJ0aWZpY2F0ZSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBTaW11bGF0b3IgZnJvbSAnLi9zaW11bGF0b3IteGNvZGUtNic7XG5pbXBvcnQgZmtpbGwgZnJvbSAnZmtpbGwnO1xuXG5cbmNvbnN0IERFRkFVTFRfU0lNX1NIVVRET1dOX1RJTUVPVVQgPSAzMDAwMDtcblxuLy8gcGdyZXAvcGtpbGwgZXhpdCBjb2Rlczpcbi8vIDAgICAgICAgT25lIG9yIG1vcmUgcHJvY2Vzc2VzIHdlcmUgbWF0Y2hlZC5cbi8vIDEgICAgICAgTm8gcHJvY2Vzc2VzIHdlcmUgbWF0Y2hlZC5cbi8vIDIgICAgICAgSW52YWxpZCBvcHRpb25zIHdlcmUgc3BlY2lmaWVkIG9uIHRoZSBjb21tYW5kIGxpbmUuXG4vLyAzICAgICAgIEFuIGludGVybmFsIGVycm9yIG9jY3VycmVkLlxuXG5hc3luYyBmdW5jdGlvbiBwa2lsbCAoYXBwTmFtZSwgZm9yY2VLaWxsID0gZmFsc2UpIHtcbiAgbGV0IGFyZ3MgPSBmb3JjZUtpbGwgPyBbJy05J10gOiBbXTtcbiAgYXJncy5wdXNoKCcteCcsIGFwcE5hbWUpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWMoJ3BraWxsJywgYXJncyk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlcnIuY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZvcmNlZnVsbHkgdGVybWluYXRlICR7YXBwTmFtZX0uIHBraWxsIGVycm9yIGNvZGU6ICR7ZXJyLmNvZGV9YCk7XG4gICAgfVxuICAgIGxvZy5lcnJvcihgUmVjZWl2ZWQgdW5leHBlY3RlZCBlcnJvciB3aGlsZSB0cnlpbmcgdG8ga2lsbCAke2FwcE5hbWV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBraWxsQWxsU2ltdWxhdG9ycyAodGltZW91dCA9IERFRkFVTFRfU0lNX1NIVVRET1dOX1RJTUVPVVQpIHtcbiAgbG9nLmRlYnVnKCdLaWxsaW5nIGFsbCBpT1MgU2ltdWxhdG9ycycpO1xuICBjb25zdCB4Y29kZVZlcnNpb24gPSBhd2FpdCBnZXRWZXJzaW9uKHRydWUpO1xuICBjb25zdCBhcHBOYW1lID0geGNvZGVWZXJzaW9uLm1ham9yID49IDcgPyAnU2ltdWxhdG9yJyA6ICdpT1MgU2ltdWxhdG9yJztcblxuICAvLyBsYXRlciB2ZXJzaW9ucyBhcmUgc2xvd2VyIHRvIGNsb3NlXG4gIHRpbWVvdXQgPSB0aW1lb3V0ICogKHhjb2RlVmVyc2lvbi5tYWpvciA+PSA4ID8gMiA6IDEpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYygneGNydW4nLCBbJ3NpbWN0bCcsICdzaHV0ZG93bicsIHhjb2RlVmVyc2lvbi5tYWpvciA+IDggPyAnYWxsJyA6ICdib290ZWQnXSwge3RpbWVvdXR9KTtcbiAgfSBjYXRjaCAoaWduKSB7fVxuXG4gIGNvbnN0IHBpZHMgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ29zYXNjcmlwdCcsXG4gICAgICBbJy1lJywgYHRlbGwgYXBwbGljYXRpb24gXCJTeXN0ZW0gRXZlbnRzXCIgdG8gdW5peCBpZCBvZiBwcm9jZXNzZXMgd2hvc2UgYnVuZGxlIGlkZW50aWZpZXIgaXMgXCJjb20uYXBwbGUuaXBob25lc2ltdWxhdG9yXCJgXSk7XG4gICAgaWYgKHN0ZG91dC50cmltKCkpIHtcbiAgICAgIHBpZHMucHVzaCguLi4oc3Rkb3V0LnRyaW0oKS5zcGxpdCgvXFxzKy8pKSk7XG4gICAgfVxuICB9IGNhdGNoIChpZ24pIHt9XG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdwZ3JlcCcsIFsnLXgnLCBhcHBOYW1lXSk7XG4gICAgaWYgKHN0ZG91dC50cmltKCkpIHtcbiAgICAgIHBpZHMucHVzaCguLi4oc3Rkb3V0LnRyaW0oKS5zcGxpdCgnXFxuJykpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlID09PSAxICYmICFwaWRzLmxlbmd0aCkge1xuICAgICAgbG9nLmRlYnVnKGAke2FwcE5hbWV9IGlzIG5vdCBydW5uaW5nLiBDb250aW51aW5nLi4uYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGlkcy5sZW5ndGgpIHtcbiAgICAgIGxvZy53YXJuKGBwZ3JlcCBlcnJvciAke2UuY29kZX0gd2hpbGUgZGV0ZWN0aW5nIHdoZXRoZXIgJHthcHBOYW1lfSBpcyBydW5uaW5nLiBUcnlpbmcgdG8ga2lsbCBhbnl3YXkuYCk7XG4gICAgfVxuICB9XG4gIGlmIChwaWRzLmxlbmd0aCkge1xuICAgIGNvbnN0IHVuaXF1ZVBpZHMgPSBfLnVuaXEocGlkcyk7XG4gICAgbG9nLmRlYnVnKGBVc2luZyBma2lsbCB0byBraWxsIHByb2Nlc3NlczogJHt1bmlxdWVQaWRzLmpvaW4oJywgJyl9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZraWxsKHVuaXF1ZVBpZHMsIHtmb3JjZTogdHJ1ZX0pO1xuICAgIH0gY2F0Y2ggKGlnbikge31cbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgVXNpbmcgcGtpbGwgdG8ga2lsbCBhcHBsaWNhdGlvbjogJHthcHBOYW1lfWApO1xuICB0cnkge1xuICAgIGF3YWl0IHBraWxsKGFwcE5hbWUsIHRydWUpO1xuICB9IGNhdGNoIChpZ24pIHt9XG5cbiAgLy8gd2FpdCBmb3IgYWxsIHRoZSBkZXZpY2VzIHRvIGJlIHNodXRkb3duIGJlZm9yZSBDb250aW51aW5nXG4gIC8vIGJ1dCBvbmx5IHByaW50IG91dCB0aGUgZmFpbGVkIG9uZXMgd2hlbiB0aGV5IGFyZSBhY3R1YWxseSBmdWxseSBmYWlsZWRcbiAgbGV0IHJlbWFpbmluZ0RldmljZXMgPSBbXTtcbiAgYXN5bmMgZnVuY3Rpb24gYWxsU2ltc0FyZURvd24gKCkge1xuICAgIHJlbWFpbmluZ0RldmljZXMgPSBbXTtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXMoKTtcbiAgICBkZXZpY2VzID0gXy5mbGF0dGVuKF8udmFsdWVzKGRldmljZXMpKTtcbiAgICByZXR1cm4gXy5ldmVyeShkZXZpY2VzLCAoc2ltKSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBzaW0uc3RhdGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGxldCBkb25lID0gc3RhdGUgPT09ICdzaHV0ZG93bicgfHxcbiAgICAgICAgICAgICAgICAgc3RhdGUgPT09ICd1bmF2YWlsYWJsZScgfHxcbiAgICAgICAgICAgICAgICAgc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgIHJlbWFpbmluZ0RldmljZXMucHVzaChgJHtzaW0ubmFtZX0gKCR7c2ltLnNka30sIHVkaWQ6ICR7c2ltLnVkaWR9KSBpcyBzdGlsbCBpbiBzdGF0ZSAnJHtzdGF0ZX0nYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9uZTtcbiAgICB9KTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYWxsU2ltc0FyZURvd24sIHtcbiAgICAgIHdhaXRNczogdGltZW91dCxcbiAgICAgIGludGVydmFsTXM6IDIwMFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAocmVtYWluaW5nRGV2aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2cud2FybihgVGhlIGZvbGxvd2luZyBkZXZpY2VzIGFyZSBzdGlsbCBub3QgaW4gdGhlIGNvcnJlY3Qgc3RhdGUgYWZ0ZXIgJHt0aW1lb3V0fSBtczpgKTtcbiAgICAgIGZvciAobGV0IGRldmljZSBvZiByZW1haW5pbmdEZXZpY2VzKSB7XG4gICAgICAgIGxvZy53YXJuKGAgICAgJHtkZXZpY2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBlbmRBbGxTaW11bGF0b3JEYWVtb25zICgpIHtcbiAgbG9nLmRlYnVnKCdFbmRpbmcgYWxsIHNpbXVsYXRvciBkYWVtb25zJyk7XG4gIGZvciAobGV0IHNlcnZpY2VQYXR0ZXJuIG9mIFsnY29tLmFwcGxlLmlwaG9uZXNpbXVsYXRvcicsICdjb20uYXBwbGUuQ29yZVNpbXVsYXRvciddKSB7XG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIGFueSBvdGhlciAke3NlcnZpY2VQYXR0ZXJufSBkYWVtb25zYCk7XG4gICAgbGV0IGxhdW5jaEN0bENvbW1hbmQgPSBgbGF1bmNoY3RsIGxpc3QgfCBncmVwICR7c2VydmljZVBhdHRlcm59IHwgY3V0IC1mIDMgfCB4YXJncyAtbiAxIGxhdW5jaGN0bGA7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBzdG9wQ21kID0gYCR7bGF1bmNoQ3RsQ29tbWFuZH0gc3RvcGA7XG4gICAgICBhd2FpdCBleGVjKCdiYXNoJywgWyctYycsIHN0b3BDbWRdKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBDb3VsZCBub3Qgc3RvcCAke3NlcnZpY2VQYXR0ZXJufSBkYWVtb25zLCBjYXJyeWluZyBvbiBhbnl3YXkhYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVtb3ZlQ21kID0gYCR7bGF1bmNoQ3RsQ29tbWFuZH0gcmVtb3ZlYDtcbiAgICAgIGF3YWl0IGV4ZWMoJ2Jhc2gnLCBbJy1jJywgcmVtb3ZlQ21kXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgQ291bGQgbm90IHJlbW92ZSAke3NlcnZpY2VQYXR0ZXJufSBkYWVtb25zLCBjYXJyeWluZyBvbiBhbnl3YXkhYCk7XG4gICAgfVxuICB9XG4gIC8vIHdhaXRpbmcgdW50aWwgdGhlIHNpbXVsYXRvciBzZXJ2aWNlIGhhcyBkaWVkLlxuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLFxuICAgICAgICBgcHMgLWUgIHwgZ3JlcCBsYXVuY2hkX3NpbSB8IGdyZXAgLXYgYmFzaCB8IGdyZXAgLXYgZ3JlcCB8IGF3ayB7J3ByaW50JDEnfWBdKTtcbiAgICAgIHJldHVybiBzdGRvdXQudHJpbSgpLmxlbmd0aCA9PT0gMDtcbiAgICB9LCB7d2FpdE1zOiA1MDAwLCBpbnRlcnZhbE1zOiA1MDB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYENvdWxkIG5vdCBlbmQgYWxsIHNpbXVsYXRvciBkYWVtb25zLCBjYXJyeWluZyBvbiFgKTtcbiAgfVxuICBsb2cuZGVidWcoJ0ZpbmlzaGluZyBlbmRpbmcgYWxsIHNpbXVsYXRvciBkYWVtb25zJyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNpbUV4aXN0cyAodWRpZCkge1xuICAvLyBzZWUgdGhlIFJFQURNRSBmb3IgZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS1zaW1jdGwgZm9yIGV4YW1wbGUgb3V0cHV0IG9mIGdldERldmljZXMoKVxuICBsZXQgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXMoKTtcblxuICBkZXZpY2VzID0gXy50b1BhaXJzKGRldmljZXMpLm1hcCgocGFpcikgPT4ge1xuICAgIHJldHVybiBwYWlyWzFdO1xuICB9KS5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH0sIFtdKTtcbiAgcmV0dXJuICEhXy5maW5kKGRldmljZXMsIChzaW0pID0+IHtcbiAgICByZXR1cm4gc2ltLnVkaWQgPT09IHVkaWQ7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzYWZlUmltUmFmIChkZWxQYXRoLCB0cnlOdW0gPSAwKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMucmltcmFmKGRlbFBhdGgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHJ5TnVtIDwgMjApIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdFTk9URU1QVFknKSAhPT0gLTEpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBQYXRoICcke2RlbFBhdGh9JyB3YXMgbm90IGVtcHR5IGR1cmluZyBkZWxldGU7IHJldHJ5aW5nYCk7XG4gICAgICAgIHJldHVybiBzYWZlUmltUmFmKGRlbFBhdGgsIHRyeU51bSArIDEpO1xuICAgICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdFTk9FTlQnKSAhPT0gLTEpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBQYXRoICcke2RlbFBhdGh9JycgZGlkIG5vdCBleGlzdCB3aGVuIHdlIHRyaWVkIHRvIGRlbGV0ZSwgaWdub3JpbmdgKTtcbiAgICAgICAgcmV0dXJuIHNhZmVSaW1SYWYoZGVsUGF0aCwgdHJ5TnVtICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5zdGFsbCBhbiBTU0wgY2VydGlmaWNhdGUgdG8gYSBkZXZpY2Ugd2l0aCBnaXZlbiB1ZGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVtVGV4dCBTU0wgcGVtIHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIElkZW50aWZpZXIgb2YgdGhlIFNpbXVsYXRvclxuICovXG5hc3luYyBmdW5jdGlvbiBpbnN0YWxsU1NMQ2VydCAocGVtVGV4dCwgdWRpZCkge1xuICAvLyBDaGVjayB0aGF0IG9wZW5zc2wgaXMgaW5zdGFsbGVkIG9uIHRoZSBwYXRoXG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud2hpY2goJ29wZW5zc2wnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhgY3VzdG9tU1NMQ2VydCByZXF1aXJlcyBvcGVuc3NsIHRvIGJlIGF2YWlsYWJsZSBvbiBwYXRoYCk7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvbW1hbmQgJ29wZW5zc2wnIG5vdCBmb3VuZGApO1xuICB9XG5cbiAgLy8gQ2hlY2sgdGhhdCBzcWxpdGUzIGlzIGluc3RhbGxlZCBvbiB0aGUgcGF0aFxuICB0cnkge1xuICAgIGF3YWl0IGZzLndoaWNoKCdzcWxpdGUzJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZGVidWcoYGN1c3RvbVNTTENlcnQgcmVxdWlyZXMgc3FsaXRlMyB0byBiZSBhdmFpbGFibGUgb24gcGF0aGApO1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb21tYW5kICdzcWxpdGUzJyBub3QgZm91bmRgKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBmaWxlIHRvIHN0b3JlIFBFTSB0ZXh0XG4gIC8vIChhIHRlbXAgZmlsZSBpcyBuZWNlc3NhcnkgdG8gcnVuIGBvcGVuc3NsYCBzaGVsbCBjb21tYW5kcywgY2FuJ3QgYmUgZG9uZSBpbiBtZW1vcnkpXG4gIGxldCB0ZW1wRmlsZU5hbWUgPSBwYXRoLnJlc29sdmUoYXdhaXQgdGVtcERpci5vcGVuRGlyKCksICd0ZW1wLXNzbC1jZXJ0LnBlbScpO1xuICBsZXQgcGF0aFRvS2V5Y2hhaW4gPSBuZXcgU2ltdWxhdG9yKHVkaWQpLmdldERpcigpO1xuICBhd2FpdCBmcy53cml0ZUZpbGUodGVtcEZpbGVOYW1lLCBwZW1UZXh0KTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5zdGF0KHBhdGhUb0tleWNoYWluKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhgQ291bGQgbm90IGluc3RhbGwgU1NMIGNlcnRpZmljYXRlLiBObyBzaW11bGF0b3Igd2l0aCB1ZGlkICcke3VkaWR9J2ApO1xuICAgIGxvZy5lcnJvckFuZFRocm93KGUpO1xuICB9XG5cbiAgLy8gRG8gdGhlIGNlcnRpZmljYXRlIGluc3RhbGxhdGlvblxuICBsZXQgY2VydGlmaWNhdGUgPSBuZXcgQ2VydGlmaWNhdGUodGVtcEZpbGVOYW1lKTtcbiAgbG9nLmRlYnVnKGBJbnN0YWxsaW5nIGNlcnRpZmljYXRlIHRvICR7cGF0aFRvS2V5Y2hhaW59YCk7XG4gIGF3YWl0IGNlcnRpZmljYXRlLmFkZChwYXRoVG9LZXljaGFpbik7XG5cbiAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgZmlsZVxuICBhd2FpdCBmcy51bmxpbmsodGVtcEZpbGVOYW1lKTtcblxuICByZXR1cm4gY2VydGlmaWNhdGU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVuaW5zdGFsbFNTTENlcnQgKHBlbVRleHQsIHVkaWQpIHtcbiAgdHJ5IHtcbiAgICBsZXQgdGVtcEZpbGVOYW1lID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJ3RlbXAtc3NsLWNlcnQucGVtJyk7XG4gICAgbGV0IHBhdGhUb0tleWNoYWluID0gcGF0aC5yZXNvbHZlKG5ldyBTaW11bGF0b3IodWRpZCkuZ2V0RGlyKCkpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0ZW1wRmlsZU5hbWUsIHBlbVRleHQpO1xuICAgIGxldCBjZXJ0aWZpY2F0ZSA9IG5ldyBDZXJ0aWZpY2F0ZSh0ZW1wRmlsZU5hbWUpO1xuICAgIGF3YWl0IGNlcnRpZmljYXRlLnJlbW92ZShwYXRoVG9LZXljaGFpbik7XG4gICAgYXdhaXQgZnMudW5saW5rKHRlbXBGaWxlTmFtZSk7XG4gICAgcmV0dXJuIGNlcnRpZmljYXRlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBDb3VsZCBub3QgdW5pbnN0YWxsIFNTTCBjZXJ0aWZpY2F0ZS4gTm8gc2ltdWxhdG9yIHdpdGggdWRpZCAnJHt1ZGlkfSdgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBTaW11bGF0b3IgYWxyZWFkeSBoYXMgdGhpcyBTU0wgY2VydGlmaWNhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwZW1UZXh0IFBFTSB0ZXh0IG9mIFNTTCBjZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCBJZGVudGlmaWVyIG9mIHRoZSBTaW11bGF0b3JcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFzU1NMQ2VydCAocGVtVGV4dCwgdWRpZCkge1xuICBjb25zdCB0ZW1wRmlsZU5hbWUgPSBwYXRoLnJlc29sdmUoYXdhaXQgdGVtcERpci5vcGVuRGlyKCksICd0ZW1wLXNzbC1jZXJ0LnBlbScpO1xuICBjb25zdCBwYXRoVG9LZXljaGFpbiA9IG5ldyBTaW11bGF0b3IodWRpZCkuZ2V0RGlyKCk7XG4gIGF3YWl0IGZzLndyaXRlRmlsZSh0ZW1wRmlsZU5hbWUsIHBlbVRleHQpO1xuICBjb25zdCBjZXJ0aWZpY2F0ZSA9IG5ldyBDZXJ0aWZpY2F0ZSh0ZW1wRmlsZU5hbWUpO1xuICByZXR1cm4gY2VydGlmaWNhdGUuaGFzKHBhdGhUb0tleWNoYWluKTtcbn1cblxuLyoqXG4gKiBSdW5zIGEgY29tbWFuZCBsaW5lIHNxbGl0ZTMgcXVlcnlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhlY1NRTGl0ZVF1ZXJ5IChkYiwgcXVlcnksIC4uLnF1ZXJ5UGFyYW1zKSB7XG4gIGxldCBxdWVyeVRva2VucyA9IHF1ZXJ5LnNwbGl0KCc/Jyk7XG4gIGxldCBmb3JtYXR0ZWRRdWVyeSA9IFtdO1xuICBxdWVyeVBhcmFtcy5mb3JFYWNoKChwYXJhbSwgaSkgPT4ge1xuICAgIGZvcm1hdHRlZFF1ZXJ5LnB1c2gocXVlcnlUb2tlbnNbaV0pO1xuICAgIGZvcm1hdHRlZFF1ZXJ5LnB1c2gocGFyYW0ucmVwbGFjZSgvJy9nLCBcIicnXCIpKTtcbiAgfSk7XG4gIGZvcm1hdHRlZFF1ZXJ5LnB1c2gocXVlcnlUb2tlbnNbcXVlcnlUb2tlbnMubGVuZ3RoIC0gMV0pO1xuXG4gIHJldHVybiBhd2FpdCBleGVjKCdzcWxpdGUzJywgWyctbGluZScsIGRiLCBmb3JtYXR0ZWRRdWVyeS5qb2luKCcnKV0pO1xufVxuXG5leHBvcnQge1xuICBraWxsQWxsU2ltdWxhdG9ycyxcbiAgZW5kQWxsU2ltdWxhdG9yRGFlbW9ucyxcbiAgc2FmZVJpbVJhZixcbiAgc2ltRXhpc3RzLFxuICBpbnN0YWxsU1NMQ2VydCxcbiAgdW5pbnN0YWxsU1NMQ2VydCxcbiAgaGFzU1NMQ2VydCxcbiAgZXhlY1NRTGl0ZVF1ZXJ5XG59O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
