'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _appiumIosDriver = require('appium-ios-driver');

var _teen_process = require('teen_process');

var _appiumXcode = require('appium-xcode');

var _appiumXcode2 = _interopRequireDefault(_appiumXcode);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var DEFAULT_TIMEOUT_KEY = 'default';

function detectUdid() {
  var cmd, args, udid, _ref, stdout, udids;

  return _regeneratorRuntime.async(function detectUdid$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Auto-detecting real device udid...');
        cmd = undefined, args = [];
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('idevice_id'));

      case 5:
        cmd = context$1$0.sent;

        args.push('-l');
        _logger2['default'].debug('Using idevice_id');
        context$1$0.next = 14;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](2);

        _logger2['default'].debug('Using udidetect');
        cmd = require.resolve('udidetect');

      case 14:
        udid = undefined;
        context$1$0.prev = 15;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args, { timeout: 3000 }));

      case 18:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        udids = _lodash2['default'].filter(stdout.split('\n'), Boolean);

        udid = _lodash2['default'].last(udids);
        if (udids.length > 1) {
          _logger2['default'].warn('Multiple devices found: ' + udids.join(', '));
          _logger2['default'].warn('Choosing \'' + udid + '\'. If this is wrong, manually set with \'udid\' desired capability');
        }
        context$1$0.next = 28;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t1 = context$1$0['catch'](15);

        _logger2['default'].errorAndThrow('Error detecting udid: ' + context$1$0.t1.message);

      case 28:
        if (!(!udid || udid.length <= 2)) {
          context$1$0.next = 30;
          break;
        }

        throw new Error('Could not detect udid.');

      case 30:
        _logger2['default'].debug('Detected real device udid: \'' + udid + '\'');
        return context$1$0.abrupt('return', udid);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 10], [15, 25]]);
}

function getAndCheckXcodeVersion() {
  var version;
  return _regeneratorRuntime.async(function getAndCheckXcodeVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        version = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getVersion(true));

      case 4:
        version = context$1$0.sent;
        context$1$0.next = 11;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].debug(context$1$0.t0);
        _logger2['default'].errorAndThrow('Could not determine Xcode version: ' + context$1$0.t0.message);

      case 11:
        if (version.toolsVersion) {
          context$1$0.next = 20;
          break;
        }

        context$1$0.prev = 12;
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getCommandLineToolsVersion());

      case 15:
        version.toolsVersion = context$1$0.sent;
        context$1$0.next = 20;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t1 = context$1$0['catch'](12);

      case 20:

        // we do not support Xcodes < 7.3,
        if (version.versionFloat < 7.3) {
          _logger2['default'].errorAndThrow('Xcode version \'' + version.versionString + '\'. Support for ' + ('Xcode ' + version.versionString + ' is not supported. ') + 'Please upgrade to version 7.3 or higher');
        }
        return context$1$0.abrupt('return', version);

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7], [12, 18]]);
}

function getAndCheckIosSdkVersion() {
  var versionNumber;
  return _regeneratorRuntime.async(function getAndCheckIosSdkVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        versionNumber = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getMaxIOSSDK());

      case 4:
        versionNumber = context$1$0.sent;
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].errorAndThrow('Could not determine iOS SDK version: ' + context$1$0.t0.message);

      case 10:
        return context$1$0.abrupt('return', versionNumber);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
}

function translateDeviceName(xcodeVersion, platformVersion) {
  var devName = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
  var deviceName, namesMapping;
  return _regeneratorRuntime.async(function translateDeviceName$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        deviceName = devName;
        context$1$0.t0 = devName.toLowerCase().trim();
        context$1$0.next = context$1$0.t0 === 'iphone simulator' ? 4 : context$1$0.t0 === 'ipad simulator' ? 6 : context$1$0.t0 === 'iphone 8' ? 8 : context$1$0.t0 === 'iphone 8 plus' ? 8 : context$1$0.t0 === 'iphone x' ? 8 : 10;
        break;

      case 4:
        deviceName = 'iPhone 6';
        return context$1$0.abrupt('break', 10);

      case 6:
        // no need to worry about floating point comparison because of the
        //   nature of the numbers being compared
        // iPad Retina is no longer available for ios 10.3
        //   so we pick another iPad to use as default
        deviceName = parseFloat(platformVersion) < 10.3 ? 'iPad Retina' : 'iPad Air';
        return context$1$0.abrupt('break', 10);

      case 8:
        // Xcode 9.0(.0) mis-named the new devices
        if (xcodeVersion.major === 9 && xcodeVersion.minor === 0 && (!_appiumSupport.util.hasValue(xcodeVersion.patch) || xcodeVersion.patch === 0)) {
          namesMapping = {
            'iphone 8': 'iPhone2017-A',
            'iphone 8 plus': 'iPhone2017-B',
            'iphone x': 'iPhone2017-C'
          };

          deviceName = namesMapping[devName.toLowerCase().trim()];
        }
        return context$1$0.abrupt('break', 10);

      case 10:

        if (deviceName !== devName) {
          _logger2['default'].debug('Changing deviceName from \'' + devName + '\' to \'' + deviceName + '\'');
        }
        return context$1$0.abrupt('return', deviceName);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

// This map contains derived data attachment folders as keys
// and values are stacks of permssion masks
// It is used to synchronize permissions change
// on shared folders
var derivedDataPermissionsStacks = new _Map();

function adjustWDAAttachmentsPermissions(wda, perms) {
  var attachmentsFolder, permsStack;
  return _regeneratorRuntime.async(function adjustWDAAttachmentsPermissions$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to set permissions on WDA attachments folder');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        attachmentsFolder = context$1$0.t1.join.call(context$1$0.t1, context$1$0.t2, 'Logs/Test/Attachments');
        permsStack = derivedDataPermissionsStacks.get(attachmentsFolder) || [];

        if (!permsStack.length) {
          context$1$0.next = 23;
          break;
        }

        if (!(_lodash2['default'].last(permsStack) === perms)) {
          context$1$0.next = 19;
          break;
        }

        permsStack.push(perms);
        _logger2['default'].info('Not changing permissions of \'' + attachmentsFolder + '\' to \'' + perms + '\', because they were already set by the other session');
        return context$1$0.abrupt('return');

      case 19:
        if (!(permsStack.length > 1)) {
          context$1$0.next = 23;
          break;
        }

        permsStack.pop();
        _logger2['default'].info('Not changing permissions of \'' + attachmentsFolder + '\' to \'' + perms + '\', because the other session does not expect them to be changed');
        return context$1$0.abrupt('return');

      case 23:
        derivedDataPermissionsStacks.set(attachmentsFolder, [perms]);

        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(attachmentsFolder));

      case 26:
        if (!context$1$0.sent) {
          context$1$0.next = 31;
          break;
        }

        _logger2['default'].info('Setting \'' + perms + '\' permissions to \'' + attachmentsFolder + '\' folder');
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.chmod(attachmentsFolder, perms));

      case 30:
        return context$1$0.abrupt('return');

      case 31:
        _logger2['default'].info('There is no ' + attachmentsFolder + ' folder, so not changing permissions');

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

// This map contains derived data logs folders as keys
// and values are the count of times the particular
// folder has been scheduled for removal
var derivedDataCleanupMarkers = new _Map();

function markSystemFilesForCleanup(wda) {
  var logsRoot, markersCount;
  return _regeneratorRuntime.async(function markSystemFilesForCleanup$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to mark system files for cleanup');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        logsRoot = context$1$0.t1.resolve.call(context$1$0.t1, context$1$0.t2, 'Logs');
        markersCount = 0;

        if (derivedDataCleanupMarkers.has(logsRoot)) {
          markersCount = derivedDataCleanupMarkers.get(logsRoot);
        }
        derivedDataCleanupMarkers.set(logsRoot, ++markersCount);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function clearSystemFiles(wda) {
  var logsRoot, markersCount, cleanupCmd, cleanupTask;
  return _regeneratorRuntime.async(function clearSystemFiles$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to clear system files');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        logsRoot = context$1$0.t1.resolve.call(context$1$0.t1, context$1$0.t2, 'Logs');

        if (!derivedDataCleanupMarkers.has(logsRoot)) {
          context$1$0.next = 19;
          break;
        }

        markersCount = derivedDataCleanupMarkers.get(logsRoot);

        derivedDataCleanupMarkers.set(logsRoot, --markersCount);

        if (!(markersCount > 0)) {
          context$1$0.next = 19;
          break;
        }

        _logger2['default'].info('Not cleaning \'' + logsRoot + '\' folder, because the other session does not expect it to be cleaned');
        return context$1$0.abrupt('return');

      case 19:
        derivedDataCleanupMarkers.set(logsRoot, 0);

        // Cleaning up big temporary files created by XCTest: https://github.com/appium/appium/issues/9410
        cleanupCmd = 'find -E /private/var/folders ' + '-regex \'.*/Session-WebDriverAgentRunner.*\\.log$|.*/StandardOutputAndStandardError\\.txt$\' ' + '-type f -exec sh -c \'echo "" > "{}"\' \\;';
        cleanupTask = new _teen_process.SubProcess('bash', ['-c', cleanupCmd], {
          detached: true,
          stdio: ['ignore', 'pipe', 'pipe']
        });
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(cleanupTask.start(0));

      case 24:
        // Do not wait for the task to be completed, since it might take a lot of time
        // We keep it running after Appium process is killed
        cleanupTask.proc.unref();
        _logger2['default'].debug('Started background XCTest logs cleanup: ' + cleanupCmd);

        context$1$0.next = 28;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(logsRoot));

      case 28:
        if (!context$1$0.sent) {
          context$1$0.next = 33;
          break;
        }

        _logger2['default'].info('Cleaning test logs in \'' + logsRoot + '\' folder');
        context$1$0.next = 32;
        return _regeneratorRuntime.awrap(_appiumIosDriver.utils.clearLogs([logsRoot]));

      case 32:
        return context$1$0.abrupt('return');

      case 33:
        _logger2['default'].info('There is no ' + logsRoot + ' folder, so not cleaning files');

      case 34:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function checkAppPresent(app) {
  return _regeneratorRuntime.async(function checkAppPresent$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Checking whether app \'' + app + '\' is actually present on file system');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(app));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        _logger2['default'].errorAndThrow('Could not find app at \'' + app + '\'');

      case 5:
        _logger2['default'].debug('App is present');

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getDriverInfo() {
  var stat, built, pkg, version, info;
  return _regeneratorRuntime.async(function getDriverInfo$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(_path2['default'].resolve(__dirname, '..')));

      case 2:
        stat = context$1$0.sent;
        built = stat.mtime.getTime();
        pkg = require(__filename.indexOf('build/lib/utils') !== -1 ? '../../package.json' : '../package.json');
        version = pkg.version;
        info = {
          built: built,
          version: version
        };
        return context$1$0.abrupt('return', info);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function normalizeCommandTimeouts(value) {
  // The value is normalized already
  if (typeof value !== 'string') {
    return value;
  }

  var result = {};
  // Use as default timeout for all commands if a single integer value is provided
  if (!isNaN(value)) {
    result[DEFAULT_TIMEOUT_KEY] = _lodash2['default'].toInteger(value);
    return result;
  }

  // JSON object has been provided. Let's parse it
  try {
    result = JSON.parse(value);
    if (!_lodash2['default'].isPlainObject(result)) {
      throw new Error();
    }
  } catch (err) {
    _logger2['default'].errorAndThrow('"commandTimeouts" capability should be a valid JSON object. "' + value + '" was given instead');
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(_lodash2['default'].toPairs(result)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2);

      var cmd = _step$value[0];
      var timeout = _step$value[1];

      if (!_lodash2['default'].isInteger(timeout) || timeout <= 0) {
        _logger2['default'].errorAndThrow('The timeout for "' + cmd + '" should be a valid natural number of milliseconds. "' + timeout + '" was given instead');
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

/**
 * Get the process id of the most recent running application
 * having the particular command line pattern.
 *
 * @param {string} pgrepPattern - pgrep-compatible search pattern.
 * @return {string} Either a process id or null if no matches were found.
 */
function getPidUsingPattern(pgrepPattern) {
  var args, _ref2, stdout, pid;

  return _regeneratorRuntime.async(function getPidUsingPattern$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['-nif', pgrepPattern];
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pgrep', args));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        pid = parseInt(stdout, 10);

        if (!isNaN(pid)) {
          context$1$0.next = 10;
          break;
        }

        _logger2['default'].debug('Cannot parse process id from \'pgrep ' + args.join(' ') + '\' output: ' + stdout);
        return context$1$0.abrupt('return', null);

      case 10:
        return context$1$0.abrupt('return', '' + pid);

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].debug('\'pgrep ' + args.join(' ') + '\' didn\'t detect any matching processes. Return code: ' + context$1$0.t0.code);
        return context$1$0.abrupt('return', null);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 13]]);
}

/**
 * Kill a process having the particular command line pattern.
 * This method tries to send SIGINT, SIGTERM and SIGKILL to the
 * matched processes in this order if the process is still running.
 *
 * @param {string} pgrepPattern - pgrep-compatible search pattern.
 */
function killAppUsingPattern(pgrepPattern) {
  var _arr, _i, signal, args;

  return _regeneratorRuntime.async(function killAppUsingPattern$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _arr = [2, 15, 9];
        _i = 0;

      case 2:
        if (!(_i < _arr.length)) {
          context$1$0.next = 22;
          break;
        }

        signal = _arr[_i];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(getPidUsingPattern(pgrepPattern));

      case 6:
        if (context$1$0.sent) {
          context$1$0.next = 8;
          break;
        }

        return context$1$0.abrupt('return');

      case 8:
        args = ['-' + signal, '-if', pgrepPattern];
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', args));

      case 12:
        context$1$0.next = 17;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t0 = context$1$0['catch'](9);

        _logger2['default'].debug('pkill ' + args.join(' ') + ' -> ' + context$1$0.t0.message);

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_bluebird2['default'].delay(100));

      case 19:
        _i++;
        context$1$0.next = 2;
        break;

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 14]]);
}

/**
 * Kills running XCTest processes for the particular device.
 *
 * @param {string} udid - The device UDID.
 * @param {boolean} isSimulator - Equals to true if the current device is a Simulator
 * @param {object} opts - Additional options mapping. Possible keys are:
 *   - {string|number} wdaLocalPort: The number of local port WDA is listening on.
 */
function resetXCTestProcesses(udid, isSimulator) {
  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var processPatterns, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, pgrepPattern;

  return _regeneratorRuntime.async(function resetXCTestProcesses$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        processPatterns = ['xcodebuild.*' + udid];

        if (opts.wdaLocalPort) {
          processPatterns.push('iproxy ' + opts.wdaLocalPort);
        } else if (!isSimulator) {
          processPatterns.push('iproxy.*' + udid);
        }
        if (isSimulator) {
          processPatterns.push(udid + '.*XCTRunner');
        }
        _logger2['default'].debug('Killing running processes \'' + processPatterns.join(', ') + '\' for the device ' + udid + '...');
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 7;
        _iterator2 = _getIterator(processPatterns);

      case 9:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 16;
          break;
        }

        pgrepPattern = _step2.value;
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(killAppUsingPattern(pgrepPattern));

      case 13:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 9;
        break;

      case 16:
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](7);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t0;

      case 22:
        context$1$0.prev = 22;
        context$1$0.prev = 23;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 25:
        context$1$0.prev = 25;

        if (!_didIteratorError2) {
          context$1$0.next = 28;
          break;
        }

        throw _iteratorError2;

      case 28:
        return context$1$0.finish(25);

      case 29:
        return context$1$0.finish(22);

      case 30:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 18, 22, 30], [23,, 25, 29]]);
}

function printUser() {
  var _ref3, stdout;

  return _regeneratorRuntime.async(function printUser$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('whoami'));

      case 3:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;

        _logger2['default'].debug('Current user: \'' + stdout.trim() + '\'');
        context$1$0.next = 11;
        break;

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('Unable to get username running server: ' + context$1$0.t0.message);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 8]]);
}

function printLibimobiledeviceInfo() {
  var _ref4, stdout, match;

  return _regeneratorRuntime.async(function printLibimobiledeviceInfo$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('brew', ['info', 'libimobiledevice']));

      case 3:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;
        match = /libimobiledevice:(.+)/.exec(stdout);

        if (match && match[1]) {
          _logger2['default'].debug('Current version of libimobiledevice: ' + match[1].trim());
        }
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('Unable to get version of libimobiledevice: ' + context$1$0.t0.message);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 9]]);
}

/**
 * Get the IDs of processes listening on the particular system port.
 * It is also possible to apply additional filtering based on the
 * process command line.
 *
 * @param {string|number} port - The port number.
 * @param {?Function} filteringFunc - Optional lambda function, which
 *                                    receives command line string of the particular process
 *                                    listening on given port, and is expected to return
 *                                    either true or false to include/exclude the corresponding PID
 *                                    from the resulting array.
 * @returns {Array<string>} - the list of matched process ids.
 */
function getPIDsListeningOnPort(port) {
  var filteringFunc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var result, _ref5,
  // This only works since Mac OS X El Capitan
  stdout;

  return _regeneratorRuntime.async(function getPIDsListeningOnPort$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        result = [];
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('lsof', ['-ti', 'tcp:' + port]));

      case 4:
        _ref5 = context$1$0.sent;
        stdout = _ref5.stdout;

        result.push.apply(result, _toConsumableArray(stdout.trim().split(/\n+/)));
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](1);
        return context$1$0.abrupt('return', result);

      case 12:
        if (_lodash2['default'].isFunction(filteringFunc)) {
          context$1$0.next = 14;
          break;
        }

        return context$1$0.abrupt('return', result);

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(_bluebird2['default'].filter(result, function callee$1$0(x) {
          var _ref6, stdout;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('ps', ['-p', x, '-o', 'command']));

              case 2:
                _ref6 = context$2$0.sent;
                stdout = _ref6.stdout;
                context$2$0.next = 6;
                return _regeneratorRuntime.awrap(filteringFunc(stdout));

              case 6:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 7:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 16:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 9]]);
}

/**
 * @typedef {Object} UploadOptions
 *
 * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 */

/**
 * Encodes the given local file to base64 and returns the resulting string
 * or uploads it to a remote server using http/https or ftp protocols
 * if `remotePath` is set
 *
 * @param {string} localFile - The path to an existing local file
 * @param {?string} remotePath - The path to the remote location, where
 *                               this file should be uploaded
 * @param {?UploadOptions} uploadOptions - Set of upload options
 * @returns {string} Either an empty string if the upload was successful or
 * base64-encoded file representation if `remotePath` is falsy
 * @throws {Error} If there was upload failure or the file content is too big
 * to fit in the available process memory.
 */
function encodeBase64OrUpload(localFile) {
  var remotePath = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var uploadOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _ref7, size, memoryUsage, maxMemoryLimit, content, remoteUrl, options, user, pass, method;

  return _regeneratorRuntime.async(function encodeBase64OrUpload$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(localFile));

      case 2:
        if (context$1$0.sent) {
          context$1$0.next = 4;
          break;
        }

        _logger2['default'].errorAndThrow('The file at \'' + localFile + '\' does not exist or is not accessible');

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(localFile));

      case 6:
        _ref7 = context$1$0.sent;
        size = _ref7.size;

        _logger2['default'].debug('The size of the file is ' + _appiumSupport.util.toReadableSizeString(size));

        if (!_lodash2['default'].isEmpty(remotePath)) {
          context$1$0.next = 18;
          break;
        }

        memoryUsage = process.memoryUsage();
        maxMemoryLimit = (memoryUsage.heapTotal - memoryUsage.heapUsed) / 2;

        if (!(size >= maxMemoryLimit)) {
          context$1$0.next = 14;
          break;
        }

        throw new Error('Cannot read \'' + localFile + '\' to the memory, because the file is too large ' + ('(' + _appiumSupport.util.toReadableSizeString(size) + ' >= ' + _appiumSupport.util.toReadableSizeString(maxMemoryLimit) + '). ') + 'Try to provide a link to a remote writable location instead.');

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(localFile));

      case 16:
        content = context$1$0.sent;
        return context$1$0.abrupt('return', content.toString('base64'));

      case 18:
        remoteUrl = _url2['default'].parse(remotePath);
        options = {};
        user = uploadOptions.user;
        pass = uploadOptions.pass;
        method = uploadOptions.method;

        if (remoteUrl.protocol.startsWith('http')) {
          options = {
            url: remoteUrl.href,
            method: method || 'PUT',
            multipart: [{ body: _fs3['default'].createReadStream(localFile) }]
          };
          if (user && pass) {
            options.auth = { user: user, pass: pass };
          }
        } else if (remoteUrl.protocol === 'ftp:') {
          options = {
            host: remoteUrl.hostname,
            port: remoteUrl.port || 21
          };
          if (user && pass) {
            options.user = user;
            options.pass = pass;
          }
        }
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.net.uploadFile(localFile, remotePath, options));

      case 26:
        return context$1$0.abrupt('return', '');

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

exports.detectUdid = detectUdid;
exports.getAndCheckXcodeVersion = getAndCheckXcodeVersion;
exports.getAndCheckIosSdkVersion = getAndCheckIosSdkVersion;
exports.adjustWDAAttachmentsPermissions = adjustWDAAttachmentsPermissions;
exports.checkAppPresent = checkAppPresent;
exports.getDriverInfo = getDriverInfo;
exports.clearSystemFiles = clearSystemFiles;
exports.translateDeviceName = translateDeviceName;
exports.normalizeCommandTimeouts = normalizeCommandTimeouts;
exports.DEFAULT_TIMEOUT_KEY = DEFAULT_TIMEOUT_KEY;
exports.resetXCTestProcesses = resetXCTestProcesses;
exports.getPidUsingPattern = getPidUsingPattern;
exports.markSystemFilesForCleanup = markSystemFilesForCleanup;
exports.printUser = printUser;
exports.printLibimobiledeviceInfo = printLibimobiledeviceInfo;
exports.getPIDsListeningOnPort = getPIDsListeningOnPort;
exports.encodeBase64OrUpload = encodeBase64OrUpload;

// only want to clear the system files for the particular WDA xcode run

// get the package.json and the version from it
//# sourceMappingURL=data:application/json;charset=utf8;base64,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c0NvbnRlbnQiOlsiaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgZnMsIHV0aWwsIG5ldCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgdXRpbHMgYXMgaW9zVXRpbHMgfSBmcm9tICdhcHBpdW0taW9zLWRyaXZlcic7XG5pbXBvcnQgeyBTdWJQcm9jZXNzLCBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB4Y29kZSBmcm9tICdhcHBpdW0teGNvZGUnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IF9mcyBmcm9tICdmcyc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5cbmNvbnN0IERFRkFVTFRfVElNRU9VVF9LRVkgPSAnZGVmYXVsdCc7XG5cblxuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0VWRpZCAoKSB7XG4gIGxvZy5kZWJ1ZygnQXV0by1kZXRlY3RpbmcgcmVhbCBkZXZpY2UgdWRpZC4uLicpO1xuICBsZXQgIGNtZCwgYXJncyA9IFtdO1xuICB0cnkge1xuICAgIGNtZCA9IGF3YWl0IGZzLndoaWNoKCdpZGV2aWNlX2lkJyk7XG4gICAgYXJncy5wdXNoKCctbCcpO1xuICAgIGxvZy5kZWJ1ZygnVXNpbmcgaWRldmljZV9pZCcpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZGVidWcoJ1VzaW5nIHVkaWRldGVjdCcpO1xuICAgIGNtZCA9IHJlcXVpcmUucmVzb2x2ZSgndWRpZGV0ZWN0Jyk7XG4gIH1cbiAgbGV0IHVkaWQ7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIGFyZ3MsIHt0aW1lb3V0OiAzMDAwfSk7XG4gICAgbGV0IHVkaWRzID0gXy5maWx0ZXIoc3Rkb3V0LnNwbGl0KCdcXG4nKSwgQm9vbGVhbik7XG4gICAgdWRpZCA9IF8ubGFzdCh1ZGlkcyk7XG4gICAgaWYgKHVkaWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxvZy53YXJuKGBNdWx0aXBsZSBkZXZpY2VzIGZvdW5kOiAke3VkaWRzLmpvaW4oJywgJyl9YCk7XG4gICAgICBsb2cud2FybihgQ2hvb3NpbmcgJyR7dWRpZH0nLiBJZiB0aGlzIGlzIHdyb25nLCBtYW51YWxseSBzZXQgd2l0aCAndWRpZCcgZGVzaXJlZCBjYXBhYmlsaXR5YCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgZGV0ZWN0aW5nIHVkaWQ6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbiAgaWYgKCF1ZGlkIHx8IHVkaWQubGVuZ3RoIDw9IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlY3QgdWRpZC4nKTtcbiAgfVxuICBsb2cuZGVidWcoYERldGVjdGVkIHJlYWwgZGV2aWNlIHVkaWQ6ICcke3VkaWR9J2ApO1xuICByZXR1cm4gdWRpZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0QW5kQ2hlY2tYY29kZVZlcnNpb24gKCkge1xuICBsZXQgdmVyc2lvbjtcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uID0gYXdhaXQgeGNvZGUuZ2V0VmVyc2lvbih0cnVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGVycik7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvdWxkIG5vdCBkZXRlcm1pbmUgWGNvZGUgdmVyc2lvbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuXG4gIGlmICghdmVyc2lvbi50b29sc1ZlcnNpb24pIHtcbiAgICB0cnkge1xuICAgICAgdmVyc2lvbi50b29sc1ZlcnNpb24gPSBhd2FpdCB4Y29kZS5nZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbigpO1xuICAgIH0gY2F0Y2ggKGlnbikge31cbiAgfVxuXG4gIC8vIHdlIGRvIG5vdCBzdXBwb3J0IFhjb2RlcyA8IDcuMyxcbiAgaWYgKHZlcnNpb24udmVyc2lvbkZsb2F0IDwgNy4zKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFhjb2RlIHZlcnNpb24gJyR7dmVyc2lvbi52ZXJzaW9uU3RyaW5nfScuIFN1cHBvcnQgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBYY29kZSAke3ZlcnNpb24udmVyc2lvblN0cmluZ30gaXMgbm90IHN1cHBvcnRlZC4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYFBsZWFzZSB1cGdyYWRlIHRvIHZlcnNpb24gNy4zIG9yIGhpZ2hlcmApO1xuICB9XG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRBbmRDaGVja0lvc1Nka1ZlcnNpb24gKCkge1xuICBsZXQgdmVyc2lvbk51bWJlcjtcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uTnVtYmVyID0gYXdhaXQgeGNvZGUuZ2V0TWF4SU9TU0RLKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgZGV0ZXJtaW5lIGlPUyBTREsgdmVyc2lvbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gdmVyc2lvbk51bWJlcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdHJhbnNsYXRlRGV2aWNlTmFtZSAoeGNvZGVWZXJzaW9uLCBwbGF0Zm9ybVZlcnNpb24sIGRldk5hbWUgPSAnJykge1xuICBsZXQgZGV2aWNlTmFtZSA9IGRldk5hbWU7XG4gIHN3aXRjaCAoZGV2TmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKSkge1xuICAgIGNhc2UgJ2lwaG9uZSBzaW11bGF0b3InOlxuICAgICAgZGV2aWNlTmFtZSA9ICdpUGhvbmUgNic7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpcGFkIHNpbXVsYXRvcic6XG4gICAgICAvLyBubyBuZWVkIHRvIHdvcnJ5IGFib3V0IGZsb2F0aW5nIHBvaW50IGNvbXBhcmlzb24gYmVjYXVzZSBvZiB0aGVcbiAgICAgIC8vICAgbmF0dXJlIG9mIHRoZSBudW1iZXJzIGJlaW5nIGNvbXBhcmVkXG4gICAgICAvLyBpUGFkIFJldGluYSBpcyBubyBsb25nZXIgYXZhaWxhYmxlIGZvciBpb3MgMTAuM1xuICAgICAgLy8gICBzbyB3ZSBwaWNrIGFub3RoZXIgaVBhZCB0byB1c2UgYXMgZGVmYXVsdFxuICAgICAgZGV2aWNlTmFtZSA9IChwYXJzZUZsb2F0KHBsYXRmb3JtVmVyc2lvbikgPCAxMC4zKSA/ICdpUGFkIFJldGluYScgOiAnaVBhZCBBaXInO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaXBob25lIDgnOlxuICAgIGNhc2UgJ2lwaG9uZSA4IHBsdXMnOlxuICAgIGNhc2UgJ2lwaG9uZSB4JzpcbiAgICAgIC8vIFhjb2RlIDkuMCguMCkgbWlzLW5hbWVkIHRoZSBuZXcgZGV2aWNlc1xuICAgICAgaWYgKHhjb2RlVmVyc2lvbi5tYWpvciA9PT0gOSAmJlxuICAgICAgICAgIHhjb2RlVmVyc2lvbi5taW5vciA9PT0gMCAmJlxuICAgICAgICAgICghdXRpbC5oYXNWYWx1ZSh4Y29kZVZlcnNpb24ucGF0Y2gpIHx8IHhjb2RlVmVyc2lvbi5wYXRjaCA9PT0gMCkpIHtcbiAgICAgICAgY29uc3QgbmFtZXNNYXBwaW5nID0ge1xuICAgICAgICAgICdpcGhvbmUgOCc6ICdpUGhvbmUyMDE3LUEnLFxuICAgICAgICAgICdpcGhvbmUgOCBwbHVzJzogJ2lQaG9uZTIwMTctQicsXG4gICAgICAgICAgJ2lwaG9uZSB4JzogJ2lQaG9uZTIwMTctQydcbiAgICAgICAgfTtcbiAgICAgICAgZGV2aWNlTmFtZSA9IG5hbWVzTWFwcGluZ1tkZXZOYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKGRldmljZU5hbWUgIT09IGRldk5hbWUpIHtcbiAgICBsb2cuZGVidWcoYENoYW5naW5nIGRldmljZU5hbWUgZnJvbSAnJHtkZXZOYW1lfScgdG8gJyR7ZGV2aWNlTmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGRldmljZU5hbWU7XG59XG5cbi8vIFRoaXMgbWFwIGNvbnRhaW5zIGRlcml2ZWQgZGF0YSBhdHRhY2htZW50IGZvbGRlcnMgYXMga2V5c1xuLy8gYW5kIHZhbHVlcyBhcmUgc3RhY2tzIG9mIHBlcm1zc2lvbiBtYXNrc1xuLy8gSXQgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSBwZXJtaXNzaW9ucyBjaGFuZ2Vcbi8vIG9uIHNoYXJlZCBmb2xkZXJzXG5jb25zdCBkZXJpdmVkRGF0YVBlcm1pc3Npb25zU3RhY2tzID0gbmV3IE1hcCgpO1xuXG5hc3luYyBmdW5jdGlvbiBhZGp1c3RXREFBdHRhY2htZW50c1Blcm1pc3Npb25zICh3ZGEsIHBlcm1zKSB7XG4gIGlmICghd2RhIHx8ICFhd2FpdCB3ZGEucmV0cmlldmVEZXJpdmVkRGF0YVBhdGgoKSkge1xuICAgIGxvZy53YXJuKCdObyBXZWJEcml2ZXJBZ2VudCBkZXJpdmVkIGRhdGEgYXZhaWxhYmxlLCBzbyB1bmFibGUgdG8gc2V0IHBlcm1pc3Npb25zIG9uIFdEQSBhdHRhY2htZW50cyBmb2xkZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhdHRhY2htZW50c0ZvbGRlciA9IHBhdGguam9pbihhd2FpdCB3ZGEucmV0cmlldmVEZXJpdmVkRGF0YVBhdGgoKSwgJ0xvZ3MvVGVzdC9BdHRhY2htZW50cycpO1xuICBjb25zdCBwZXJtc1N0YWNrID0gZGVyaXZlZERhdGFQZXJtaXNzaW9uc1N0YWNrcy5nZXQoYXR0YWNobWVudHNGb2xkZXIpIHx8IFtdO1xuICBpZiAocGVybXNTdGFjay5sZW5ndGgpIHtcbiAgICBpZiAoXy5sYXN0KHBlcm1zU3RhY2spID09PSBwZXJtcykge1xuICAgICAgcGVybXNTdGFjay5wdXNoKHBlcm1zKTtcbiAgICAgIGxvZy5pbmZvKGBOb3QgY2hhbmdpbmcgcGVybWlzc2lvbnMgb2YgJyR7YXR0YWNobWVudHNGb2xkZXJ9JyB0byAnJHtwZXJtc30nLCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IHNldCBieSB0aGUgb3RoZXIgc2Vzc2lvbmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGVybXNTdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICBwZXJtc1N0YWNrLnBvcCgpO1xuICAgICAgbG9nLmluZm8oYE5vdCBjaGFuZ2luZyBwZXJtaXNzaW9ucyBvZiAnJHthdHRhY2htZW50c0ZvbGRlcn0nIHRvICcke3Blcm1zfScsIGJlY2F1c2UgdGhlIG90aGVyIHNlc3Npb24gZG9lcyBub3QgZXhwZWN0IHRoZW0gdG8gYmUgY2hhbmdlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBkZXJpdmVkRGF0YVBlcm1pc3Npb25zU3RhY2tzLnNldChhdHRhY2htZW50c0ZvbGRlciwgW3Blcm1zXSk7XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdHRhY2htZW50c0ZvbGRlcikpIHtcbiAgICBsb2cuaW5mbyhgU2V0dGluZyAnJHtwZXJtc30nIHBlcm1pc3Npb25zIHRvICcke2F0dGFjaG1lbnRzRm9sZGVyfScgZm9sZGVyYCk7XG4gICAgYXdhaXQgZnMuY2htb2QoYXR0YWNobWVudHNGb2xkZXIsIHBlcm1zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbG9nLmluZm8oYFRoZXJlIGlzIG5vICR7YXR0YWNobWVudHNGb2xkZXJ9IGZvbGRlciwgc28gbm90IGNoYW5naW5nIHBlcm1pc3Npb25zYCk7XG59XG5cbi8vIFRoaXMgbWFwIGNvbnRhaW5zIGRlcml2ZWQgZGF0YSBsb2dzIGZvbGRlcnMgYXMga2V5c1xuLy8gYW5kIHZhbHVlcyBhcmUgdGhlIGNvdW50IG9mIHRpbWVzIHRoZSBwYXJ0aWN1bGFyXG4vLyBmb2xkZXIgaGFzIGJlZW4gc2NoZWR1bGVkIGZvciByZW1vdmFsXG5jb25zdCBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzID0gbmV3IE1hcCgpO1xuXG5hc3luYyBmdW5jdGlvbiBtYXJrU3lzdGVtRmlsZXNGb3JDbGVhbnVwICh3ZGEpIHtcbiAgaWYgKCF3ZGEgfHwgIWF3YWl0IHdkYS5yZXRyaWV2ZURlcml2ZWREYXRhUGF0aCgpKSB7XG4gICAgbG9nLndhcm4oJ05vIFdlYkRyaXZlckFnZW50IGRlcml2ZWQgZGF0YSBhdmFpbGFibGUsIHNvIHVuYWJsZSB0byBtYXJrIHN5c3RlbSBmaWxlcyBmb3IgY2xlYW51cCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGxvZ3NSb290ID0gcGF0aC5yZXNvbHZlKGF3YWl0IHdkYS5yZXRyaWV2ZURlcml2ZWREYXRhUGF0aCgpLCAnTG9ncycpO1xuICBsZXQgbWFya2Vyc0NvdW50ID0gMDtcbiAgaWYgKGRlcml2ZWREYXRhQ2xlYW51cE1hcmtlcnMuaGFzKGxvZ3NSb290KSkge1xuICAgIG1hcmtlcnNDb3VudCA9IGRlcml2ZWREYXRhQ2xlYW51cE1hcmtlcnMuZ2V0KGxvZ3NSb290KTtcbiAgfVxuICBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLnNldChsb2dzUm9vdCwgKyttYXJrZXJzQ291bnQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjbGVhclN5c3RlbUZpbGVzICh3ZGEpIHtcbiAgLy8gb25seSB3YW50IHRvIGNsZWFyIHRoZSBzeXN0ZW0gZmlsZXMgZm9yIHRoZSBwYXJ0aWN1bGFyIFdEQSB4Y29kZSBydW5cbiAgaWYgKCF3ZGEgfHwgIWF3YWl0IHdkYS5yZXRyaWV2ZURlcml2ZWREYXRhUGF0aCgpKSB7XG4gICAgbG9nLndhcm4oJ05vIFdlYkRyaXZlckFnZW50IGRlcml2ZWQgZGF0YSBhdmFpbGFibGUsIHNvIHVuYWJsZSB0byBjbGVhciBzeXN0ZW0gZmlsZXMnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsb2dzUm9vdCA9IHBhdGgucmVzb2x2ZShhd2FpdCB3ZGEucmV0cmlldmVEZXJpdmVkRGF0YVBhdGgoKSwgJ0xvZ3MnKTtcbiAgaWYgKGRlcml2ZWREYXRhQ2xlYW51cE1hcmtlcnMuaGFzKGxvZ3NSb290KSkge1xuICAgIGxldCBtYXJrZXJzQ291bnQgPSBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLmdldChsb2dzUm9vdCk7XG4gICAgZGVyaXZlZERhdGFDbGVhbnVwTWFya2Vycy5zZXQobG9nc1Jvb3QsIC0tbWFya2Vyc0NvdW50KTtcbiAgICBpZiAobWFya2Vyc0NvdW50ID4gMCkge1xuICAgICAgbG9nLmluZm8oYE5vdCBjbGVhbmluZyAnJHtsb2dzUm9vdH0nIGZvbGRlciwgYmVjYXVzZSB0aGUgb3RoZXIgc2Vzc2lvbiBkb2VzIG5vdCBleHBlY3QgaXQgdG8gYmUgY2xlYW5lZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLnNldChsb2dzUm9vdCwgMCk7XG5cbiAgLy8gQ2xlYW5pbmcgdXAgYmlnIHRlbXBvcmFyeSBmaWxlcyBjcmVhdGVkIGJ5IFhDVGVzdDogaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzk0MTBcbiAgY29uc3QgY2xlYW51cENtZCA9IGBmaW5kIC1FIC9wcml2YXRlL3Zhci9mb2xkZXJzIGAgK1xuICAgIGAtcmVnZXggJy4qL1Nlc3Npb24tV2ViRHJpdmVyQWdlbnRSdW5uZXIuKlxcXFwubG9nJHwuKi9TdGFuZGFyZE91dHB1dEFuZFN0YW5kYXJkRXJyb3JcXFxcLnR4dCQnIGAgK1xuICAgIGAtdHlwZSBmIC1leGVjIHNoIC1jICdlY2hvIFwiXCIgPiBcInt9XCInIFxcXFw7YDtcbiAgY29uc3QgY2xlYW51cFRhc2sgPSBuZXcgU3ViUHJvY2VzcygnYmFzaCcsIFsnLWMnLCBjbGVhbnVwQ21kXSwge1xuICAgIGRldGFjaGVkOiB0cnVlLFxuICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnXSxcbiAgfSk7XG4gIGF3YWl0IGNsZWFudXBUYXNrLnN0YXJ0KDApO1xuICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhlIHRhc2sgdG8gYmUgY29tcGxldGVkLCBzaW5jZSBpdCBtaWdodCB0YWtlIGEgbG90IG9mIHRpbWVcbiAgLy8gV2Uga2VlcCBpdCBydW5uaW5nIGFmdGVyIEFwcGl1bSBwcm9jZXNzIGlzIGtpbGxlZFxuICBjbGVhbnVwVGFzay5wcm9jLnVucmVmKCk7XG4gIGxvZy5kZWJ1ZyhgU3RhcnRlZCBiYWNrZ3JvdW5kIFhDVGVzdCBsb2dzIGNsZWFudXA6ICR7Y2xlYW51cENtZH1gKTtcblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGxvZ3NSb290KSkge1xuICAgIGxvZy5pbmZvKGBDbGVhbmluZyB0ZXN0IGxvZ3MgaW4gJyR7bG9nc1Jvb3R9JyBmb2xkZXJgKTtcbiAgICBhd2FpdCBpb3NVdGlscy5jbGVhckxvZ3MoW2xvZ3NSb290XSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxvZy5pbmZvKGBUaGVyZSBpcyBubyAke2xvZ3NSb290fSBmb2xkZXIsIHNvIG5vdCBjbGVhbmluZyBmaWxlc2ApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja0FwcFByZXNlbnQgKGFwcCkge1xuICBsb2cuZGVidWcoYENoZWNraW5nIHdoZXRoZXIgYXBwICcke2FwcH0nIGlzIGFjdHVhbGx5IHByZXNlbnQgb24gZmlsZSBzeXN0ZW1gKTtcbiAgaWYgKCEoYXdhaXQgZnMuZXhpc3RzKGFwcCkpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvdWxkIG5vdCBmaW5kIGFwcCBhdCAnJHthcHB9J2ApO1xuICB9XG4gIGxvZy5kZWJ1ZygnQXBwIGlzIHByZXNlbnQnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0RHJpdmVySW5mbyAoKSB7XG4gIGxldCBzdGF0ID0gYXdhaXQgZnMuc3RhdChwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nKSk7XG4gIGxldCBidWlsdCA9IHN0YXQubXRpbWUuZ2V0VGltZSgpO1xuXG4gIC8vIGdldCB0aGUgcGFja2FnZS5qc29uIGFuZCB0aGUgdmVyc2lvbiBmcm9tIGl0XG4gIGxldCBwa2cgPSByZXF1aXJlKF9fZmlsZW5hbWUuaW5kZXhPZignYnVpbGQvbGliL3V0aWxzJykgIT09IC0xID8gJy4uLy4uL3BhY2thZ2UuanNvbicgOiAnLi4vcGFja2FnZS5qc29uJyk7XG4gIGxldCB2ZXJzaW9uID0gcGtnLnZlcnNpb247XG5cbiAgbGV0IGluZm8gPSB7XG4gICAgYnVpbHQsXG4gICAgdmVyc2lvbixcbiAgfTtcbiAgcmV0dXJuIGluZm87XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbW1hbmRUaW1lb3V0cyAodmFsdWUpIHtcbiAgLy8gVGhlIHZhbHVlIGlzIG5vcm1hbGl6ZWQgYWxyZWFkeVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSB7fTtcbiAgLy8gVXNlIGFzIGRlZmF1bHQgdGltZW91dCBmb3IgYWxsIGNvbW1hbmRzIGlmIGEgc2luZ2xlIGludGVnZXIgdmFsdWUgaXMgcHJvdmlkZWRcbiAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICByZXN1bHRbREVGQVVMVF9USU1FT1VUX0tFWV0gPSBfLnRvSW50ZWdlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIEpTT04gb2JqZWN0IGhhcyBiZWVuIHByb3ZpZGVkLiBMZXQncyBwYXJzZSBpdFxuICB0cnkge1xuICAgIHJlc3VsdCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFwiY29tbWFuZFRpbWVvdXRzXCIgY2FwYWJpbGl0eSBzaG91bGQgYmUgYSB2YWxpZCBKU09OIG9iamVjdC4gXCIke3ZhbHVlfVwiIHdhcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgZm9yIChsZXQgW2NtZCwgdGltZW91dF0gb2YgXy50b1BhaXJzKHJlc3VsdCkpIHtcbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHRpbWVvdXQpIHx8IHRpbWVvdXQgPD0gMCkge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coYFRoZSB0aW1lb3V0IGZvciBcIiR7Y21kfVwiIHNob3VsZCBiZSBhIHZhbGlkIG5hdHVyYWwgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gXCIke3RpbWVvdXR9XCIgd2FzIGdpdmVuIGluc3RlYWRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb2Nlc3MgaWQgb2YgdGhlIG1vc3QgcmVjZW50IHJ1bm5pbmcgYXBwbGljYXRpb25cbiAqIGhhdmluZyB0aGUgcGFydGljdWxhciBjb21tYW5kIGxpbmUgcGF0dGVybi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGdyZXBQYXR0ZXJuIC0gcGdyZXAtY29tcGF0aWJsZSBzZWFyY2ggcGF0dGVybi5cbiAqIEByZXR1cm4ge3N0cmluZ30gRWl0aGVyIGEgcHJvY2VzcyBpZCBvciBudWxsIGlmIG5vIG1hdGNoZXMgd2VyZSBmb3VuZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UGlkVXNpbmdQYXR0ZXJuIChwZ3JlcFBhdHRlcm4pIHtcbiAgY29uc3QgYXJncyA9IFsnLW5pZicsIHBncmVwUGF0dGVybl07XG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdwZ3JlcCcsIGFyZ3MpO1xuICAgIGNvbnN0IHBpZCA9IHBhcnNlSW50KHN0ZG91dCwgMTApO1xuICAgIGlmIChpc05hTihwaWQpKSB7XG4gICAgICBsb2cuZGVidWcoYENhbm5vdCBwYXJzZSBwcm9jZXNzIGlkIGZyb20gJ3BncmVwICR7YXJncy5qb2luKCcgJyl9JyBvdXRwdXQ6ICR7c3Rkb3V0fWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBgJHtwaWR9YDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGAncGdyZXAgJHthcmdzLmpvaW4oJyAnKX0nIGRpZG4ndCBkZXRlY3QgYW55IG1hdGNoaW5nIHByb2Nlc3Nlcy4gUmV0dXJuIGNvZGU6ICR7ZXJyLmNvZGV9YCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBLaWxsIGEgcHJvY2VzcyBoYXZpbmcgdGhlIHBhcnRpY3VsYXIgY29tbWFuZCBsaW5lIHBhdHRlcm4uXG4gKiBUaGlzIG1ldGhvZCB0cmllcyB0byBzZW5kIFNJR0lOVCwgU0lHVEVSTSBhbmQgU0lHS0lMTCB0byB0aGVcbiAqIG1hdGNoZWQgcHJvY2Vzc2VzIGluIHRoaXMgb3JkZXIgaWYgdGhlIHByb2Nlc3MgaXMgc3RpbGwgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGdyZXBQYXR0ZXJuIC0gcGdyZXAtY29tcGF0aWJsZSBzZWFyY2ggcGF0dGVybi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24ga2lsbEFwcFVzaW5nUGF0dGVybiAocGdyZXBQYXR0ZXJuKSB7XG4gIGZvciAoY29uc3Qgc2lnbmFsIG9mIFsyLCAxNSwgOV0pIHtcbiAgICBpZiAoIWF3YWl0IGdldFBpZFVzaW5nUGF0dGVybihwZ3JlcFBhdHRlcm4pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbYC0ke3NpZ25hbH1gLCAnLWlmJywgcGdyZXBQYXR0ZXJuXTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlYygncGtpbGwnLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgcGtpbGwgJHthcmdzLmpvaW4oJyAnKX0gLT4gJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgYXdhaXQgQi5kZWxheSgxMDApO1xuICB9XG59XG5cbi8qKlxuICogS2lsbHMgcnVubmluZyBYQ1Rlc3QgcHJvY2Vzc2VzIGZvciB0aGUgcGFydGljdWxhciBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIFVESUQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2ltdWxhdG9yIC0gRXF1YWxzIHRvIHRydWUgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIGEgU2ltdWxhdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLiBQb3NzaWJsZSBrZXlzIGFyZTpcbiAqICAgLSB7c3RyaW5nfG51bWJlcn0gd2RhTG9jYWxQb3J0OiBUaGUgbnVtYmVyIG9mIGxvY2FsIHBvcnQgV0RBIGlzIGxpc3RlbmluZyBvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzZXRYQ1Rlc3RQcm9jZXNzZXMgKHVkaWQsIGlzU2ltdWxhdG9yLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcHJvY2Vzc1BhdHRlcm5zID0gW2B4Y29kZWJ1aWxkLioke3VkaWR9YF07XG4gIGlmIChvcHRzLndkYUxvY2FsUG9ydCkge1xuICAgIHByb2Nlc3NQYXR0ZXJucy5wdXNoKGBpcHJveHkgJHtvcHRzLndkYUxvY2FsUG9ydH1gKTtcbiAgfSBlbHNlIGlmICghaXNTaW11bGF0b3IpIHtcbiAgICBwcm9jZXNzUGF0dGVybnMucHVzaChgaXByb3h5Lioke3VkaWR9YCk7XG4gIH1cbiAgaWYgKGlzU2ltdWxhdG9yKSB7XG4gICAgcHJvY2Vzc1BhdHRlcm5zLnB1c2goYCR7dWRpZH0uKlhDVFJ1bm5lcmApO1xuICB9XG4gIGxvZy5kZWJ1ZyhgS2lsbGluZyBydW5uaW5nIHByb2Nlc3NlcyAnJHtwcm9jZXNzUGF0dGVybnMuam9pbignLCAnKX0nIGZvciB0aGUgZGV2aWNlICR7dWRpZH0uLi5gKTtcbiAgZm9yIChjb25zdCBwZ3JlcFBhdHRlcm4gb2YgcHJvY2Vzc1BhdHRlcm5zKSB7XG4gICAgYXdhaXQga2lsbEFwcFVzaW5nUGF0dGVybihwZ3JlcFBhdHRlcm4pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByaW50VXNlciAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygnd2hvYW1pJyk7XG4gICAgbG9nLmRlYnVnKGBDdXJyZW50IHVzZXI6ICcke3N0ZG91dC50cmltKCl9J2ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZGVidWcoYFVuYWJsZSB0byBnZXQgdXNlcm5hbWUgcnVubmluZyBzZXJ2ZXI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJpbnRMaWJpbW9iaWxlZGV2aWNlSW5mbyAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygnYnJldycsIFsnaW5mbycsICdsaWJpbW9iaWxlZGV2aWNlJ10pO1xuICAgIGxldCBtYXRjaCA9IC9saWJpbW9iaWxlZGV2aWNlOiguKykvLmV4ZWMoc3Rkb3V0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQ3VycmVudCB2ZXJzaW9uIG9mIGxpYmltb2JpbGVkZXZpY2U6ICR7bWF0Y2hbMV0udHJpbSgpfWApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGBVbmFibGUgdG8gZ2V0IHZlcnNpb24gb2YgbGliaW1vYmlsZWRldmljZTogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgSURzIG9mIHByb2Nlc3NlcyBsaXN0ZW5pbmcgb24gdGhlIHBhcnRpY3VsYXIgc3lzdGVtIHBvcnQuXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGx5IGFkZGl0aW9uYWwgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZVxuICogcHJvY2VzcyBjb21tYW5kIGxpbmUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwb3J0IC0gVGhlIHBvcnQgbnVtYmVyLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGZpbHRlcmluZ0Z1bmMgLSBPcHRpb25hbCBsYW1iZGEgZnVuY3Rpb24sIHdoaWNoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVzIGNvbW1hbmQgbGluZSBzdHJpbmcgb2YgdGhlIHBhcnRpY3VsYXIgcHJvY2Vzc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5pbmcgb24gZ2l2ZW4gcG9ydCwgYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVyblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXIgdHJ1ZSBvciBmYWxzZSB0byBpbmNsdWRlL2V4Y2x1ZGUgdGhlIGNvcnJlc3BvbmRpbmcgUElEXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIHJlc3VsdGluZyBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSAtIHRoZSBsaXN0IG9mIG1hdGNoZWQgcHJvY2VzcyBpZHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFBJRHNMaXN0ZW5pbmdPblBvcnQgKHBvcnQsIGZpbHRlcmluZ0Z1bmMgPSBudWxsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB0cnkge1xuICAgIC8vIFRoaXMgb25seSB3b3JrcyBzaW5jZSBNYWMgT1MgWCBFbCBDYXBpdGFuXG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdsc29mJywgWyctdGknLCBgdGNwOiR7cG9ydH1gXSk7XG4gICAgcmVzdWx0LnB1c2goLi4uKHN0ZG91dC50cmltKCkuc3BsaXQoL1xcbisvKSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghXy5pc0Z1bmN0aW9uKGZpbHRlcmluZ0Z1bmMpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gYXdhaXQgQi5maWx0ZXIocmVzdWx0LCBhc3luYyAoeCkgPT4ge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygncHMnLCBbJy1wJywgeCwgJy1vJywgJ2NvbW1hbmQnXSk7XG4gICAgcmV0dXJuIGF3YWl0IGZpbHRlcmluZ0Z1bmMoc3Rkb3V0KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVXBsb2FkT3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdXNlciAtIFRoZSBuYW1lIG9mIHRoZSB1c2VyIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLiBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcGFzcyAtIFRoZSBwYXNzd29yZCBmb3IgdGhlIHJlbW90ZSBhdXRoZW50aWNhdGlvbi4gT25seSB3b3JrcyBpZiBgcmVtb3RlUGF0aGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG1ldGhvZCAtIFRoZSBodHRwIG11bHRpcGFydCB1cGxvYWQgbWV0aG9kIG5hbWUuIFRoZSAnUFVUJyBvbmUgaXMgdXNlZCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqL1xuXG5cbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gbG9jYWwgZmlsZSB0byBiYXNlNjQgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBzdHJpbmdcbiAqIG9yIHVwbG9hZHMgaXQgdG8gYSByZW1vdGUgc2VydmVyIHVzaW5nIGh0dHAvaHR0cHMgb3IgZnRwIHByb3RvY29sc1xuICogaWYgYHJlbW90ZVBhdGhgIGlzIHNldFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbEZpbGUgLSBUaGUgcGF0aCB0byBhbiBleGlzdGluZyBsb2NhbCBmaWxlXG4gKiBAcGFyYW0gez9zdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byB0aGUgcmVtb3RlIGxvY2F0aW9uLCB3aGVyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBmaWxlIHNob3VsZCBiZSB1cGxvYWRlZFxuICogQHBhcmFtIHs/VXBsb2FkT3B0aW9uc30gdXBsb2FkT3B0aW9ucyAtIFNldCBvZiB1cGxvYWQgb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gRWl0aGVyIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgdXBsb2FkIHdhcyBzdWNjZXNzZnVsIG9yXG4gKiBiYXNlNjQtZW5jb2RlZCBmaWxlIHJlcHJlc2VudGF0aW9uIGlmIGByZW1vdGVQYXRoYCBpcyBmYWxzeVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyB1cGxvYWQgZmFpbHVyZSBvciB0aGUgZmlsZSBjb250ZW50IGlzIHRvbyBiaWdcbiAqIHRvIGZpdCBpbiB0aGUgYXZhaWxhYmxlIHByb2Nlc3MgbWVtb3J5LlxuICovXG5hc3luYyBmdW5jdGlvbiBlbmNvZGVCYXNlNjRPclVwbG9hZCAobG9jYWxGaWxlLCByZW1vdGVQYXRoID0gbnVsbCwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKGxvY2FsRmlsZSkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIGZpbGUgYXQgJyR7bG9jYWxGaWxlfScgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGFjY2Vzc2libGVgKTtcbiAgfVxuXG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQobG9jYWxGaWxlKTtcbiAgbG9nLmRlYnVnKGBUaGUgc2l6ZSBvZiB0aGUgZmlsZSBpcyAke3V0aWwudG9SZWFkYWJsZVNpemVTdHJpbmcoc2l6ZSl9YCk7XG4gIGlmIChfLmlzRW1wdHkocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCBtZW1vcnlVc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICBjb25zdCBtYXhNZW1vcnlMaW1pdCA9IChtZW1vcnlVc2FnZS5oZWFwVG90YWwgLSBtZW1vcnlVc2FnZS5oZWFwVXNlZCkgLyAyO1xuICAgIGlmIChzaXplID49IG1heE1lbW9yeUxpbWl0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWFkICcke2xvY2FsRmlsZX0nIHRvIHRoZSBtZW1vcnksIGJlY2F1c2UgdGhlIGZpbGUgaXMgdG9vIGxhcmdlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAoJHt1dGlsLnRvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSA+PSAke3V0aWwudG9SZWFkYWJsZVNpemVTdHJpbmcobWF4TWVtb3J5TGltaXQpfSkuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBUcnkgdG8gcHJvdmlkZSBhIGxpbmsgdG8gYSByZW1vdGUgd3JpdGFibGUgbG9jYXRpb24gaW5zdGVhZC5gKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGxvY2FsRmlsZSk7XG4gICAgcmV0dXJuIGNvbnRlbnQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgcmVtb3RlVXJsID0gdXJsLnBhcnNlKHJlbW90ZVBhdGgpO1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBjb25zdCB7dXNlciwgcGFzcywgbWV0aG9kfSA9IHVwbG9hZE9wdGlvbnM7XG4gIGlmIChyZW1vdGVVcmwucHJvdG9jb2wuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHVybDogcmVtb3RlVXJsLmhyZWYsXG4gICAgICBtZXRob2Q6IG1ldGhvZCB8fCAnUFVUJyxcbiAgICAgIG11bHRpcGFydDogW3sgYm9keTogX2ZzLmNyZWF0ZVJlYWRTdHJlYW0obG9jYWxGaWxlKSB9XSxcbiAgICB9O1xuICAgIGlmICh1c2VyICYmIHBhc3MpIHtcbiAgICAgIG9wdGlvbnMuYXV0aCA9IHt1c2VyLCBwYXNzfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVtb3RlVXJsLnByb3RvY29sID09PSAnZnRwOicpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgaG9zdDogcmVtb3RlVXJsLmhvc3RuYW1lLFxuICAgICAgcG9ydDogcmVtb3RlVXJsLnBvcnQgfHwgMjEsXG4gICAgfTtcbiAgICBpZiAodXNlciAmJiBwYXNzKSB7XG4gICAgICBvcHRpb25zLnVzZXIgPSB1c2VyO1xuICAgICAgb3B0aW9ucy5wYXNzID0gcGFzcztcbiAgICB9XG4gIH1cbiAgYXdhaXQgbmV0LnVwbG9hZEZpbGUobG9jYWxGaWxlLCByZW1vdGVQYXRoLCBvcHRpb25zKTtcbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgeyBkZXRlY3RVZGlkLCBnZXRBbmRDaGVja1hjb2RlVmVyc2lvbiwgZ2V0QW5kQ2hlY2tJb3NTZGtWZXJzaW9uLFxuICAgICAgICAgYWRqdXN0V0RBQXR0YWNobWVudHNQZXJtaXNzaW9ucywgY2hlY2tBcHBQcmVzZW50LCBnZXREcml2ZXJJbmZvLFxuICAgICAgICAgY2xlYXJTeXN0ZW1GaWxlcywgdHJhbnNsYXRlRGV2aWNlTmFtZSwgbm9ybWFsaXplQ29tbWFuZFRpbWVvdXRzLFxuICAgICAgICAgREVGQVVMVF9USU1FT1VUX0tFWSwgcmVzZXRYQ1Rlc3RQcm9jZXNzZXMsIGdldFBpZFVzaW5nUGF0dGVybixcbiAgICAgICAgIG1hcmtTeXN0ZW1GaWxlc0ZvckNsZWFudXAsIHByaW50VXNlciwgcHJpbnRMaWJpbW9iaWxlZGV2aWNlSW5mbyxcbiAgICAgICAgIGdldFBJRHNMaXN0ZW5pbmdPblBvcnQsIGVuY29kZUJhc2U2NE9yVXBsb2FkIH07XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
