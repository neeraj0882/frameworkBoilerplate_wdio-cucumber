'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _appiumSupport = require('appium-support');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _appiumIosDriver = require('appium-ios-driver');

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _teen_process = require('teen_process');

var _nodeSimctl = require('node-simctl');

var CONTAINER_PATH_MARKER = '@';
// https://regex101.com/r/PLdB0G/2
var CONTAINER_PATH_PATTERN = new RegExp('^' + CONTAINER_PATH_MARKER + '([^/]+)/(.+)');

var commands = _appiumIosDriver.iosCommands.file;

function verifyIFusePresence() {
  return _regeneratorRuntime.async(function verifyIFusePresence$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('ifuse'));

      case 2:
        if (context$1$0.sent) {
          context$1$0.next = 4;
          break;
        }

        _logger2['default'].errorAndThrow('\'ifuse\' tool is required to be installed on the machine. ' + 'Install it using \'brew cask install osxfuse && brew install ifuse\' or check ' + 'if it is available in PATH environment variable if the tool is already installed. ' + ('Current PATH value: ' + process.env.PATH));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function mountDevice(device, iFuseArgs) {
  return _regeneratorRuntime.async(function mountDevice$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Starting ifuse with args \'' + iFuseArgs + '\'...');
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('ifuse', iFuseArgs));

      case 4:
        context$1$0.next = 9;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].errorAndThrow('Cannot mount the media folder of the device with UDID ' + device.udid + '. ' + 'Make sure osxfuse plugin has necessary permissions in System Preferences->Security & Privacy. ' + ('Error code: ' + context$1$0.t0.code + '; stderr output: ' + context$1$0.t0.stderr));

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 6]]);
}

function verifyIsSubPath(filePath, root) {
  var normalizedRoot = _path2['default'].normalize(root);
  var normalizedFilePath = _path2['default'].normalize(_path2['default'].dirname(filePath));
  if (!normalizedFilePath.startsWith(normalizedRoot)) {
    _logger2['default'].errorAndThrow('\'' + normalizedFilePath + '\' is expected to be a subpath of \'' + normalizedRoot + '\'');
  }
}

function parseContainerPath(remotePath, containerRootSupplier) {
  var match, containerRoot, resultPath;
  return _regeneratorRuntime.async(function parseContainerPath$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        match = CONTAINER_PATH_PATTERN.exec(remotePath);

        if (!match) {
          _logger2['default'].errorAndThrow('It is expected that package identifier is separated from the relative path with a single slash. ' + ('\'' + remotePath + '\' is given instead'));
        }

        if (!_lodash2['default'].isFunction(containerRootSupplier)) {
          context$1$0.next = 8;
          break;
        }

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(containerRootSupplier(match[1]));

      case 5:
        context$1$0.t0 = context$1$0.sent;
        context$1$0.next = 9;
        break;

      case 8:
        context$1$0.t0 = containerRootSupplier;

      case 9:
        containerRoot = context$1$0.t0;
        resultPath = _path2['default'].posix.resolve(containerRoot, match[2]);

        verifyIsSubPath(resultPath, containerRoot);
        return context$1$0.abrupt('return', [match[1], resultPath]);

      case 13:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Save the given base64 data chunk as a binary file on the Simulator under test.
 *
 * @param {Object} device - The device object, which represents the device under test.
 *                          This object is expected to have the `udid` property containing the
 *                          valid device ID.
 * @param {string} remotePath - The remote path on the device. This variable can be prefixed with
 *                              bundle id, so then the file will be uploaded to the corresponding
 *                              application container instead of the default media folder, for example
 *                              '@com.myapp.bla/RelativePathInContainer/111.png'. The '@' character at the
 *                              beginning of the argument is mandatory in such case.
 *                              The relative folder path is ignored if the file is going to be uploaded
 *                              to the default media folder and only the file name is considered important.
 * @param {string} base64Data - Base-64 encoded content of the file to be uploaded.
 */
function pushFileToSimulator(device, remotePath, base64Data) {
  var buffer, _ref, _ref2, bundleId, _dstPath, dstFolder, dstPath;

  return _regeneratorRuntime.async(function pushFileToSimulator$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        buffer = Buffer.from(base64Data, 'base64');

        if (!remotePath.startsWith(CONTAINER_PATH_MARKER)) {
          context$1$0.next = 18;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(parseContainerPath(remotePath, function callee$1$0(x) {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _nodeSimctl.getAppContainer)(device.udid, x));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 4:
        _ref = context$1$0.sent;
        _ref2 = _slicedToArray(_ref, 2);
        bundleId = _ref2[0];
        _dstPath = _ref2[1];

        _logger2['default'].info('Parsed bundle identifier \'' + bundleId + '\' from \'' + remotePath + '\'. ' + ('Will put the data into \'' + _dstPath + '\''));
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(_path2['default'].dirname(_dstPath)));

      case 11:
        if (context$1$0.sent) {
          context$1$0.next = 15;
          break;
        }

        _logger2['default'].debug('The destination folder \'' + _path2['default'].dirname(_dstPath) + '\' does not exist. Creating...');
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(_path2['default'].dirname(_dstPath)));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(_dstPath, buffer, 'binary'));

      case 17:
        return context$1$0.abrupt('return');

      case 18:
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 20:
        dstFolder = context$1$0.sent;
        dstPath = _path2['default'].resolve(dstFolder, _path2['default'].basename(remotePath));
        context$1$0.prev = 22;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dstPath, buffer, 'binary'));

      case 25:
        context$1$0.next = 27;
        return _regeneratorRuntime.awrap((0, _nodeSimctl.addMedia)(device.udid, dstPath));

      case 27:
        context$1$0.prev = 27;
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(dstFolder));

      case 30:
        return context$1$0.finish(27);

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[22,, 27, 31]]);
}

/**
 * Save the given base64 data chunk as a binary file on the device under test.
 * ifuse/osxfuse should be installed and configured on the target machine in order
 * for this function to work properly. Read https://github.com/libimobiledevice/ifuse
 * and https://github.com/osxfuse/osxfuse/wiki/FAQ for more details.
 *
 * @param {Object} device - The device object, which represents the device under test.
 *                          This object is expected to have the `udid` property containing the
 *                          valid device ID.
 * @param {string} remotePath - The remote path on the device. This variable can be prefixed with
 *                              bundle id, so then the file will be uploaded to the corresponding
 *                              application container instead of the default media folder, for example
 *                              '@com.myapp.bla/RelativePathInContainer/111.png'. The '@' character at the
 *                              beginning of the argument is mandatory in such case.
 * @param {string} base64Data - Base-64 encoded content of the file to be uploaded.
 */
function pushFileToRealDevice(device, remotePath, base64Data) {
  var mntRoot, isUnmountSuccessful, dstPath, ifuseArgs, _ref3, _ref32, bundleId, pathInContainer;

  return _regeneratorRuntime.async(function pushFileToRealDevice$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(verifyIFusePresence());

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 4:
        mntRoot = context$1$0.sent;
        isUnmountSuccessful = true;
        context$1$0.prev = 6;
        dstPath = _path2['default'].resolve(mntRoot, remotePath);
        ifuseArgs = ['-u', device.udid, mntRoot];

        if (!remotePath.startsWith(CONTAINER_PATH_MARKER)) {
          context$1$0.next = 21;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(parseContainerPath(remotePath, mntRoot));

      case 12:
        _ref3 = context$1$0.sent;
        _ref32 = _slicedToArray(_ref3, 2);
        bundleId = _ref32[0];
        pathInContainer = _ref32[1];

        dstPath = pathInContainer;
        _logger2['default'].info('Parsed bundle identifier \'' + bundleId + '\' from \'' + remotePath + '\'. ' + ('Will put the data into \'' + dstPath + '\''));
        ifuseArgs = ['-u', device.udid, '--container', bundleId, mntRoot];
        context$1$0.next = 22;
        break;

      case 21:
        verifyIsSubPath(dstPath, mntRoot);

      case 22:
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(mountDevice(device, ifuseArgs));

      case 24:
        isUnmountSuccessful = false;
        context$1$0.prev = 25;
        context$1$0.next = 28;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(_path2['default'].dirname(dstPath)));

      case 28:
        if (context$1$0.sent) {
          context$1$0.next = 32;
          break;
        }

        _logger2['default'].debug('The destination folder \'' + _path2['default'].dirname(dstPath) + '\' does not exist. Creating...');
        context$1$0.next = 32;
        return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(_path2['default'].dirname(dstPath)));

      case 32:
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dstPath, new Buffer(base64Data, 'base64').toString('binary'), 'binary'));

      case 34:
        context$1$0.prev = 34;
        context$1$0.next = 37;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('umount', [mntRoot]));

      case 37:
        isUnmountSuccessful = true;
        return context$1$0.finish(34);

      case 39:
        context$1$0.prev = 39;

        if (!isUnmountSuccessful) {
          context$1$0.next = 45;
          break;
        }

        context$1$0.next = 43;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(mntRoot));

      case 43:
        context$1$0.next = 46;
        break;

      case 45:
        _logger2['default'].warn('Umount has failed, so not removing \'' + mntRoot + '\'');

      case 46:
        return context$1$0.finish(39);

      case 47:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6,, 39, 47], [25,, 34, 39]]);
}

/**
 * Get the content of given file from iOS Simulator and return it as base-64 encoded string.
 *
 * @param {Object} device - The device object, which represents the device under test.
 *                          This object is expected to have the `udid` property containing the
 *                          valid device ID.
 * @param {string} remotePath - The path to a file, which exists in the corresponding application
 *                              container on Simulator. The expected format of this string:
 *                              @<app_bundle_id>/<path_to_the_file_inside_container>
 * @returns {string} Base-64 encoded content of the file.
 */
function pullFileFromSimulator(device, remotePath) {
  var _ref4, _ref42, bundleId, dstPath, data;

  return _regeneratorRuntime.async(function pullFileFromSimulator$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!remotePath.startsWith(CONTAINER_PATH_MARKER)) {
          _logger2['default'].errorAndThrow('Only pulling files from application containers is supported for iOS Simulator. ' + 'Provide the remote path in format @<bundle_id>/<path_to_the_file_in_its_container>');
        }
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(parseContainerPath(remotePath, function callee$1$0(x) {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _nodeSimctl.getAppContainer)(device.udid, x));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }));

      case 3:
        _ref4 = context$1$0.sent;
        _ref42 = _slicedToArray(_ref4, 2);
        bundleId = _ref42[0];
        dstPath = _ref42[1];

        _logger2['default'].info('Parsed bundle identifier \'' + bundleId + '\' from \'' + remotePath + '\'. ' + ('Will get the data from \'' + dstPath + '\''));
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(dstPath));

      case 10:
        if (context$1$0.sent) {
          context$1$0.next = 12;
          break;
        }

        _logger2['default'].errorAndThrow('The remote file at \'' + dstPath + '\' does not exist');

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(dstPath));

      case 14:
        data = context$1$0.sent;
        return context$1$0.abrupt('return', new Buffer(data).toString('base64'));

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Get the content of given file from the real device under test and return it as base-64 encoded string.
 *
 * @param {Object} device - The device object, which represents the device under test.
 *                          This object is expected to have the `udid` property containing the
 *                          valid device ID.
 * @param {string} remotePath - The path to an existing remote file on the device. This variable can be prefixed with
 *                              bundle id, so then the file will be downloaded from the corresponding
 *                              application container instead of the default media folder, for example
 *                              '@com.myapp.bla/RelativePathInContainer/111.png'. The '@' character at the
 *                              beginning of the argument is mandatory in such case.
 * @return {string} Base-64 encoded content of the remote file
 */
function pullFileFromRealDevice(device, remotePath) {
  var mntRoot, isUnmountSuccessful, dstPath, ifuseArgs, _ref5, _ref52, bundleId, pathInContainer, data;

  return _regeneratorRuntime.async(function pullFileFromRealDevice$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(verifyIFusePresence());

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 4:
        mntRoot = context$1$0.sent;
        isUnmountSuccessful = true;
        context$1$0.prev = 6;
        dstPath = _path2['default'].resolve(mntRoot, remotePath);
        ifuseArgs = ['-u', device.udid, mntRoot];

        if (!remotePath.startsWith(CONTAINER_PATH_MARKER)) {
          context$1$0.next = 21;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(parseContainerPath(remotePath, mntRoot));

      case 12:
        _ref5 = context$1$0.sent;
        _ref52 = _slicedToArray(_ref5, 2);
        bundleId = _ref52[0];
        pathInContainer = _ref52[1];

        dstPath = pathInContainer;
        _logger2['default'].info('Parsed bundle identifier \'' + bundleId + '\' from \'' + remotePath + '\'. ' + ('Will get the data from \'' + dstPath + '\''));
        ifuseArgs = ['-u', device.udid, '--container', bundleId, mntRoot];
        context$1$0.next = 22;
        break;

      case 21:
        verifyIsSubPath(dstPath, mntRoot);

      case 22:
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(mountDevice(device, ifuseArgs));

      case 24:
        isUnmountSuccessful = false;
        context$1$0.prev = 25;
        context$1$0.next = 28;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(dstPath));

      case 28:
        if (context$1$0.sent) {
          context$1$0.next = 30;
          break;
        }

        _logger2['default'].errorAndThrow('The remote file at \'' + dstPath + '\' does not exist');

      case 30:
        context$1$0.next = 32;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(dstPath));

      case 32:
        data = context$1$0.sent;
        return context$1$0.abrupt('return', new Buffer(data).toString('base64'));

      case 34:
        context$1$0.prev = 34;
        context$1$0.next = 37;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('umount', [mntRoot]));

      case 37:
        isUnmountSuccessful = true;
        return context$1$0.finish(34);

      case 39:
        context$1$0.prev = 39;

        if (!isUnmountSuccessful) {
          context$1$0.next = 45;
          break;
        }

        context$1$0.next = 43;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(mntRoot));

      case 43:
        context$1$0.next = 46;
        break;

      case 45:
        _logger2['default'].warn('Umount has failed, so not removing \'' + mntRoot + '\'');

      case 46:
        return context$1$0.finish(39);

      case 47:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6,, 39, 47], [25,, 34, 39]]);
}

commands.pushFile = function callee$0$0(remotePath, base64Data) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (remotePath.endsWith('/')) {
          _logger2['default'].errorAndThrow('It is expected that remote path points to a file and not to a folder. ' + ('\'' + remotePath + '\' is given instead'));
        }
        if (_lodash2['default'].isArray(base64Data)) {
          // some clients (ahem) java, send a byte array encoding utf8 characters
          // instead of a string, which would be infinitely better!
          base64Data = Buffer.from(base64Data).toString('utf8');
        }

        if (!this.isSimulator()) {
          context$1$0.next = 6;
          break;
        }

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(pushFileToSimulator(this.opts.device, remotePath, base64Data));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(pushFileToRealDevice(this.opts.device, remotePath, base64Data));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.pullFile = function callee$0$0(remotePath) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (remotePath.endsWith('/')) {
          _logger2['default'].errorAndThrow('It is expected that remote path points to a file and not to a folder. ' + ('\'' + remotePath + '\' is given instead'));
        }

        if (!this.isSimulator()) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(pullFileFromSimulator(this.opts.device, remotePath));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(pullFileFromRealDevice(this.opts.device, remotePath));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.getSimFileFullPath = function callee$0$0(remotePath) {
  var basePath, appName, appNameRegex, appNameMatches, findPath, _ref6, stdout, appRoot, subPath, fullPath;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        basePath = this.opts.device.getDir();
        appName = null;

        if (this.opts.app) {
          appNameRegex = new RegExp('\\' + _path2['default'].sep + '([\\w-]+\\.app)');
          appNameMatches = appNameRegex.exec(this.opts.app);

          if (appNameMatches) {
            appName = appNameMatches[1];
          }
        }
        // de-absolutize the path
        if (_appiumSupport.system.isWindows()) {
          if (remotePath.indexof('://') === 1) {
            remotePath = remotePath.slice(4);
          }
        } else {
          if (remotePath.indexOf('/') === 0) {
            remotePath = remotePath.slice(1);
          }
        }

        if (!(remotePath.indexOf(appName) === 0)) {
          context$1$0.next = 19;
          break;
        }

        findPath = basePath;

        if (this.opts.platformVersion >= 8) {
          // the .app file appears in /Containers/Data and /Containers/Bundle both. We only want /Bundle
          findPath = _path2['default'].resolve(basePath, 'Containers', 'Bundle');
        }
        findPath = findPath.replace(/\s/g, '\\ ');

        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('find', [findPath, '-name', appName]));

      case 10:
        _ref6 = context$1$0.sent;
        stdout = _ref6.stdout;
        appRoot = stdout.replace(/\n$/, '');
        subPath = remotePath.substring(appName.length + 1);
        fullPath = _path2['default'].resolve(appRoot, subPath);

        _logger2['default'].debug('Finding app-relative file: \'' + fullPath + '\'');
        return context$1$0.abrupt('return', fullPath);

      case 19:
        fullPath = _path2['default'].resolve(basePath, remotePath);

        _logger2['default'].debug('Finding sim-relative file: ' + fullPath);
        return context$1$0.abrupt('return', fullPath);

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

exports.commands = commands;
exports['default'] = commands;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7OzZCQUNzQixnQkFBZ0I7O29CQUMzQyxNQUFNOzs7OytCQUNLLG1CQUFtQjs7c0JBQy9CLFdBQVc7Ozs7NEJBQ04sY0FBYzs7MEJBQ08sYUFBYTs7QUFFdkQsSUFBTSxxQkFBcUIsR0FBRyxHQUFHLENBQUM7O0FBRWxDLElBQU0sc0JBQXNCLEdBQUcsSUFBSSxNQUFNLE9BQUsscUJBQXFCLGtCQUFlLENBQUM7O0FBR25GLElBQUksUUFBUSxHQUFHLDZCQUFZLElBQUksQ0FBQzs7QUFFaEMsU0FBZSxtQkFBbUI7Ozs7O3lDQUNyQixrQkFBRyxLQUFLLENBQUMsT0FBTyxDQUFDOzs7Ozs7OztBQUMxQiw0QkFBSSxhQUFhLENBQUMsZ0pBQzhFLHVGQUNNLDZCQUM3RCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBRSxDQUFDLENBQUM7Ozs7Ozs7Q0FFaEU7O0FBRUQsU0FBZSxXQUFXLENBQUUsTUFBTSxFQUFFLFNBQVM7Ozs7QUFDM0MsNEJBQUksS0FBSyxpQ0FBOEIsU0FBUyxXQUFPLENBQUM7Ozt5Q0FFaEQsd0JBQUssT0FBTyxFQUFFLFNBQVMsQ0FBQzs7Ozs7Ozs7OztBQUU5Qiw0QkFBSSxhQUFhLENBQUMsMkRBQXlELE1BQU0sQ0FBQyxJQUFJLDBHQUM0QixxQkFDakYsZUFBRSxJQUFJLHlCQUFvQixlQUFFLE1BQU0sQ0FBRSxDQUFDLENBQUM7Ozs7Ozs7Q0FFMUU7O0FBRUQsU0FBUyxlQUFlLENBQUUsUUFBUSxFQUFFLElBQUksRUFBRTtBQUN4QyxNQUFNLGNBQWMsR0FBRyxrQkFBSyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUMsTUFBTSxrQkFBa0IsR0FBRyxrQkFBSyxTQUFTLENBQUMsa0JBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDbEUsTUFBSSxDQUFDLGtCQUFrQixD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LGVBQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7QUFDbkMsZUFBTyxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDbEQsZ0JBQVEsR0FBRyxrQkFBSyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQzs7QUFDN0MsNEJBQUksS0FBSyxtQ0FBZ0MsUUFBUSxRQUFJLENBQUM7NENBQy9DLFFBQVE7OztBQUVYLGdCQUFRLEdBQUcsa0JBQUssT0FBTyxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUM7O0FBQ2pELDRCQUFJLEtBQUssaUNBQStCLFFBQVEsQ0FBRyxDQUFDOzRDQUM3QyxRQUFROzs7Ozs7O0NBRWxCLENBQUM7O1FBR08sUUFBUSxHQUFSLFFBQVE7cUJBQ0YsUUFBUSIsImZpbGUiOiJsaWIvY29tbWFuZHMvZmlsZS1tb3ZlbWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzLCB0ZW1wRGlyLCBta2RpcnAgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGlvc0NvbW1hbmRzIH0gZnJvbSAnYXBwaXVtLWlvcy1kcml2ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBhZGRNZWRpYSwgZ2V0QXBwQ29udGFpbmVyIH0gZnJvbSAnbm9kZS1zaW1jdGwnO1xuXG5jb25zdCBDT05UQUlORVJfUEFUSF9NQVJLRVIgPSAnQCc7XG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL1BMZEIwRy8yXG5jb25zdCBDT05UQUlORVJfUEFUSF9QQVRURVJOID0gbmV3IFJlZ0V4cChgXiR7Q09OVEFJTkVSX1BBVEhfTUFSS0VSfShbXi9dKykvKC4rKWApO1xuXG5cbmxldCBjb21tYW5kcyA9IGlvc0NvbW1hbmRzLmZpbGU7XG5cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUlGdXNlUHJlc2VuY2UgKCkge1xuICBpZiAoIWF3YWl0IGZzLndoaWNoKCdpZnVzZScpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYCdpZnVzZScgdG9vbCBpcyByZXF1aXJlZCB0byBiZSBpbnN0YWxsZWQgb24gdGhlIG1hY2hpbmUuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBJbnN0YWxsIGl0IHVzaW5nICdicmV3IGNhc2sgaW5zdGFsbCBvc3hmdXNlICYmIGJyZXcgaW5zdGFsbCBpZnVzZScgb3IgY2hlY2sgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYGlmIGl0IGlzIGF2YWlsYWJsZSBpbiBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIHRoZSB0b29sIGlzIGFscmVhZHkgaW5zdGFsbGVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgQ3VycmVudCBQQVRIIHZhbHVlOiAke3Byb2Nlc3MuZW52LlBBVEh9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbW91bnREZXZpY2UgKGRldmljZSwgaUZ1c2VBcmdzKSB7XG4gIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgaWZ1c2Ugd2l0aCBhcmdzICcke2lGdXNlQXJnc30nLi4uYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYygnaWZ1c2UnLCBpRnVzZUFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENhbm5vdCBtb3VudCB0aGUgbWVkaWEgZm9sZGVyIG9mIHRoZSBkZXZpY2Ugd2l0aCBVRElEICR7ZGV2aWNlLnVkaWR9LiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgTWFrZSBzdXJlIG9zeGZ1c2UgcGx1Z2luIGhhcyBuZWNlc3NhcnkgcGVybWlzc2lvbnMgaW4gU3lzdGVtIFByZWZlcmVuY2VzLT5TZWN1cml0eSAmIFByaXZhY3kuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBFcnJvciBjb2RlOiAke2UuY29kZX07IHN0ZGVyciBvdXRwdXQ6ICR7ZS5zdGRlcnJ9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmVyaWZ5SXNTdWJQYXRoIChmaWxlUGF0aCwgcm9vdCkge1xuICBjb25zdCBub3JtYWxpemVkUm9vdCA9IHBhdGgubm9ybWFsaXplKHJvb3QpO1xuICBjb25zdCBub3JtYWxpemVkRmlsZVBhdGggPSBwYXRoLm5vcm1hbGl6ZShwYXRoLmRpcm5hbWUoZmlsZVBhdGgpKTtcbiAgaWYgKCFub3JtYWxpemVkRmlsZVBhdGguc3RhcnRzV2l0aChub3JtYWxpemVkUm9vdCkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgJyR7bm9ybWFsaXplZEZpbGVQYXRofScgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdWJwYXRoIG9mICcke25vcm1hbGl6ZWRSb290fSdgKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbnRhaW5lclBhdGggKHJlbW90ZVBhdGgsIGNvbnRhaW5lclJvb3RTdXBwbGllcikge1xuICBjb25zdCBtYXRjaCA9IENPTlRBSU5FUl9QQVRIX1BBVFRFUk4uZXhlYyhyZW1vdGVQYXRoKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHBhY2thZ2UgaWRlbnRpZmllciBpcyBzZXBhcmF0ZWQgZnJvbSB0aGUgcmVsYXRpdmUgcGF0aCB3aXRoIGEgc2luZ2xlIHNsYXNoLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCBjb250YWluZXJSb290ID0gXy5pc0Z1bmN0aW9uKGNvbnRhaW5lclJvb3RTdXBwbGllcikgP1xuICAgIChhd2FpdCBjb250YWluZXJSb290U3VwcGxpZXIobWF0Y2hbMV0pKSA6XG4gICAgY29udGFpbmVyUm9vdFN1cHBsaWVyO1xuICBjb25zdCByZXN1bHRQYXRoID0gcGF0aC5wb3NpeC5yZXNvbHZlKGNvbnRhaW5lclJvb3QsIG1hdGNoWzJdKTtcbiAgdmVyaWZ5SXNTdWJQYXRoKHJlc3VsdFBhdGgsIGNvbnRhaW5lclJvb3QpO1xuICByZXR1cm4gW21hdGNoWzFdLCByZXN1bHRQYXRoXTtcbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSBjaHVuayBhcyBhIGJpbmFyeSBmaWxlIG9uIHRoZSBTaW11bGF0b3IgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLCBmb3IgZXhhbXBsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGNvbS5teWFwcC5ibGEvUmVsYXRpdmVQYXRoSW5Db250YWluZXIvMTExLnBuZycuIFRoZSAnQCcgY2hhcmFjdGVyIGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbm5pbmcgb2YgdGhlIGFyZ3VtZW50IGlzIG1hbmRhdG9yeSBpbiBzdWNoIGNhc2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSByZWxhdGl2ZSBmb2xkZXIgcGF0aCBpcyBpZ25vcmVkIGlmIHRoZSBmaWxlIGlzIGdvaW5nIHRvIGJlIHVwbG9hZGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlciBhbmQgb25seSB0aGUgZmlsZSBuYW1lIGlzIGNvbnNpZGVyZWQgaW1wb3J0YW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NERhdGEgLSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVzaEZpbGVUb1NpbXVsYXRvciAoZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEsICdiYXNlNjQnKTtcbiAgaWYgKHJlbW90ZVBhdGguc3RhcnRzV2l0aChDT05UQUlORVJfUEFUSF9NQVJLRVIpKSB7XG4gICAgY29uc3QgW2J1bmRsZUlkLCBkc3RQYXRoXSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKHgpID0+IGF3YWl0IGdldEFwcENvbnRhaW5lcihkZXZpY2UudWRpZCwgeCkpO1xuICAgIGxvZy5pbmZvKGBQYXJzZWQgYnVuZGxlIGlkZW50aWZpZXIgJyR7YnVuZGxlSWR9JyBmcm9tICcke3JlbW90ZVBhdGh9Jy4gYCArXG4gICAgICAgICAgICAgYFdpbGwgcHV0IHRoZSBkYXRhIGludG8gJyR7ZHN0UGF0aH0nYCk7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgICAgbG9nLmRlYnVnKGBUaGUgZGVzdGluYXRpb24gZm9sZGVyICcke3BhdGguZGlybmFtZShkc3RQYXRoKX0nIGRvZXMgbm90IGV4aXN0LiBDcmVhdGluZy4uLmApO1xuICAgICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIsICdiaW5hcnknKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZHN0Rm9sZGVyID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoZHN0Rm9sZGVyLCBwYXRoLmJhc2VuYW1lKHJlbW90ZVBhdGgpKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgYnVmZmVyLCAnYmluYXJ5Jyk7XG4gICAgYXdhaXQgYWRkTWVkaWEoZGV2aWNlLnVkaWQsIGRzdFBhdGgpO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZihkc3RGb2xkZXIpO1xuICB9XG59XG5cbi8qKlxuICogU2F2ZSB0aGUgZ2l2ZW4gYmFzZTY0IGRhdGEgY2h1bmsgYXMgYSBiaW5hcnkgZmlsZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiBpZnVzZS9vc3hmdXNlIHNob3VsZCBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQgb24gdGhlIHRhcmdldCBtYWNoaW5lIGluIG9yZGVyXG4gKiBmb3IgdGhpcyBmdW5jdGlvbiB0byB3b3JrIHByb3Blcmx5LiBSZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJpbW9iaWxlZGV2aWNlL2lmdXNlXG4gKiBhbmQgaHR0cHM6Ly9naXRodWIuY29tL29zeGZ1c2Uvb3N4ZnVzZS93aWtpL0ZBUSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIsIGZvciBleGFtcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAY29tLm15YXBwLmJsYS9SZWxhdGl2ZVBhdGhJbkNvbnRhaW5lci8xMTEucG5nJy4gVGhlICdAJyBjaGFyYWN0ZXIgYXQgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2lubmluZyBvZiB0aGUgYXJndW1lbnQgaXMgbWFuZGF0b3J5IGluIHN1Y2ggY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjREYXRhIC0gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlVG9SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgYXdhaXQgdmVyaWZ5SUZ1c2VQcmVzZW5jZSgpO1xuICBjb25zdCBtbnRSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIGxldCBpc1VubW91bnRTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBsZXQgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShtbnRSb290LCByZW1vdGVQYXRoKTtcbiAgICBsZXQgaWZ1c2VBcmdzID0gWyctdScsIGRldmljZS51ZGlkLCBtbnRSb290XTtcbiAgICBpZiAocmVtb3RlUGF0aC5zdGFydHNXaXRoKENPTlRBSU5FUl9QQVRIX01BUktFUikpIHtcbiAgICAgIGNvbnN0IFtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyXSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLCBtbnRSb290KTtcbiAgICAgIGRzdFBhdGggPSBwYXRoSW5Db250YWluZXI7XG4gICAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgICAgICAgICAgYFdpbGwgcHV0IHRoZSBkYXRhIGludG8gJyR7ZHN0UGF0aH0nYCk7XG4gICAgICBpZnVzZUFyZ3MgPSBbJy11JywgZGV2aWNlLnVkaWQsICctLWNvbnRhaW5lcicsIGJ1bmRsZUlkLCBtbnRSb290XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVyaWZ5SXNTdWJQYXRoKGRzdFBhdGgsIG1udFJvb3QpO1xuICAgIH1cbiAgICBhd2FpdCBtb3VudERldmljZShkZXZpY2UsIGlmdXNlQXJncyk7XG4gICAgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoLmRpcm5hbWUoZHN0UGF0aCkpKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgVGhlIGRlc3RpbmF0aW9uIGZvbGRlciAnJHtwYXRoLmRpcm5hbWUoZHN0UGF0aCl9JyBkb2VzIG5vdCBleGlzdC4gQ3JlYXRpbmcuLi5gKTtcbiAgICAgICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgbmV3IEJ1ZmZlcihiYXNlNjREYXRhLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGV4ZWMoJ3Vtb3VudCcsIFttbnRSb290XSk7XG4gICAgICBpc1VubW91bnRTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKGlzVW5tb3VudFN1Y2Nlc3NmdWwpIHtcbiAgICAgIGF3YWl0IGZzLnJpbXJhZihtbnRSb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLndhcm4oYFVtb3VudCBoYXMgZmFpbGVkLCBzbyBub3QgcmVtb3ZpbmcgJyR7bW50Um9vdH0nYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGdpdmVuIGZpbGUgZnJvbSBpT1MgU2ltdWxhdG9yIGFuZCByZXR1cm4gaXQgYXMgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYSBmaWxlLCB3aGljaCBleGlzdHMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgYXBwbGljYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyIG9uIFNpbXVsYXRvci4gVGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGlzIHN0cmluZzpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPi88cGF0aF90b190aGVfZmlsZV9pbnNpZGVfY29udGFpbmVyPlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGaWxlRnJvbVNpbXVsYXRvciAoZGV2aWNlLCByZW1vdGVQYXRoKSB7XG4gIGlmICghcmVtb3RlUGF0aC5zdGFydHNXaXRoKENPTlRBSU5FUl9QQVRIX01BUktFUikpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgT25seSBwdWxsaW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY29udGFpbmVycyBpcyBzdXBwb3J0ZWQgZm9yIGlPUyBTaW11bGF0b3IuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBQcm92aWRlIHRoZSByZW1vdGUgcGF0aCBpbiBmb3JtYXQgQDxidW5kbGVfaWQ+LzxwYXRoX3RvX3RoZV9maWxlX2luX2l0c19jb250YWluZXI+YCk7XG4gIH1cbiAgY29uc3QgW2J1bmRsZUlkLCBkc3RQYXRoXSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgIGFzeW5jICh4KSA9PiBhd2FpdCBnZXRBcHBDb250YWluZXIoZGV2aWNlLnVkaWQsIHgpKTtcbiAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgICAgICAgYFdpbGwgZ2V0IHRoZSBkYXRhIGZyb20gJyR7ZHN0UGF0aH0nYCk7XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKGRzdFBhdGgpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFRoZSByZW1vdGUgZmlsZSBhdCAnJHtkc3RQYXRofScgZG9lcyBub3QgZXhpc3RgKTtcbiAgfVxuICBjb25zdCBkYXRhID0gYXdhaXQgZnMucmVhZEZpbGUoZHN0UGF0aCk7XG4gIHJldHVybiBuZXcgQnVmZmVyKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbnRlbnQgb2YgZ2l2ZW4gZmlsZSBmcm9tIHRoZSByZWFsIGRldmljZSB1bmRlciB0ZXN0IGFuZCByZXR1cm4gaXQgYXMgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYW4gZXhpc3RpbmcgcmVtb3RlIGZpbGUgb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSBkb3dubG9hZGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLCBmb3IgZXhhbXBsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGNvbS5teWFwcC5ibGEvUmVsYXRpdmVQYXRoSW5Db250YWluZXIvMTExLnBuZycuIFRoZSAnQCcgY2hhcmFjdGVyIGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbm5pbmcgb2YgdGhlIGFyZ3VtZW50IGlzIG1hbmRhdG9yeSBpbiBzdWNoIGNhc2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSByZW1vdGUgZmlsZVxuICovXG5hc3luYyBmdW5jdGlvbiBwdWxsRmlsZUZyb21SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgpIHtcbiAgYXdhaXQgdmVyaWZ5SUZ1c2VQcmVzZW5jZSgpO1xuICBjb25zdCBtbnRSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIGxldCBpc1VubW91bnRTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBsZXQgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShtbnRSb290LCByZW1vdGVQYXRoKTtcbiAgICBsZXQgaWZ1c2VBcmdzID0gWyctdScsIGRldmljZS51ZGlkLCBtbnRSb290XTtcbiAgICBpZiAocmVtb3RlUGF0aC5zdGFydHNXaXRoKENPTlRBSU5FUl9QQVRIX01BUktFUikpIHtcbiAgICAgIGNvbnN0IFtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyXSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLCBtbnRSb290KTtcbiAgICAgIGRzdFBhdGggPSBwYXRoSW5Db250YWluZXI7XG4gICAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgICAgICAgICAgYFdpbGwgZ2V0IHRoZSBkYXRhIGZyb20gJyR7ZHN0UGF0aH0nYCk7XG4gICAgICBpZnVzZUFyZ3MgPSBbJy11JywgZGV2aWNlLnVkaWQsICctLWNvbnRhaW5lcicsIGJ1bmRsZUlkLCBtbnRSb290XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVyaWZ5SXNTdWJQYXRoKGRzdFBhdGgsIG1udFJvb3QpO1xuICAgIH1cbiAgICBhd2FpdCBtb3VudERldmljZShkZXZpY2UsIGlmdXNlQXJncyk7XG4gICAgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhkc3RQYXRoKSkge1xuICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIHJlbW90ZSBmaWxlIGF0ICcke2RzdFBhdGh9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGZzLnJlYWRGaWxlKGRzdFBhdGgpO1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBleGVjKCd1bW91bnQnLCBbbW50Um9vdF0pO1xuICAgICAgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpc1VubW91bnRTdWNjZXNzZnVsKSB7XG4gICAgICBhd2FpdCBmcy5yaW1yYWYobW50Um9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy53YXJuKGBVbW91bnQgaGFzIGZhaWxlZCwgc28gbm90IHJlbW92aW5nICcke21udFJvb3R9J2ApO1xuICAgIH1cbiAgfVxufVxuXG5jb21tYW5kcy5wdXNoRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIGlmIChfLmlzQXJyYXkoYmFzZTY0RGF0YSkpIHtcbiAgICAvLyBzb21lIGNsaWVudHMgKGFoZW0pIGphdmEsIHNlbmQgYSBieXRlIGFycmF5IGVuY29kaW5nIHV0ZjggY2hhcmFjdGVyc1xuICAgIC8vIGluc3RlYWQgb2YgYSBzdHJpbmcsIHdoaWNoIHdvdWxkIGJlIGluZmluaXRlbHkgYmV0dGVyIVxuICAgIGJhc2U2NERhdGEgPSBCdWZmZXIuZnJvbShiYXNlNjREYXRhKS50b1N0cmluZygndXRmOCcpO1xuICB9XG4gIGlmICh0aGlzLmlzU2ltdWxhdG9yKCkpIHtcbiAgICByZXR1cm4gYXdhaXQgcHVzaEZpbGVUb1NpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgcHVzaEZpbGVUb1JlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSk7XG59O1xuXG5jb21tYW5kcy5wdWxsRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoKSB7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIGlmICh0aGlzLmlzU2ltdWxhdG9yKCkpIHtcbiAgICByZXR1cm4gYXdhaXQgcHVsbEZpbGVGcm9tU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgpO1xuICB9XG4gIHJldHVybiBhd2FpdCBwdWxsRmlsZUZyb21SZWFsRGV2aWNlKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgpO1xufTtcblxuY29tbWFuZHMuZ2V0U2ltRmlsZUZ1bGxQYXRoID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgpIHtcbiAgbGV0IGJhc2VQYXRoID0gdGhpcy5vcHRzLmRldmljZS5nZXREaXIoKTtcbiAgbGV0IGFwcE5hbWUgPSBudWxsO1xuXG4gIGlmICh0aGlzLm9wdHMuYXBwKSB7XG4gICAgbGV0IGFwcE5hbWVSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFwke3BhdGguc2VwfShbXFxcXHctXStcXFxcLmFwcClgKTtcbiAgICBsZXQgYXBwTmFtZU1hdGNoZXMgPSBhcHBOYW1lUmVnZXguZXhlYyh0aGlzLm9wdHMuYXBwKTtcbiAgICBpZiAoYXBwTmFtZU1hdGNoZXMpIHtcbiAgICAgIGFwcE5hbWUgPSBhcHBOYW1lTWF0Y2hlc1sxXTtcbiAgICB9XG4gIH1cbiAgLy8gZGUtYWJzb2x1dGl6ZSB0aGUgcGF0aFxuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgaWYgKHJlbW90ZVBhdGguaW5kZXhvZignOi8vJykgPT09IDEpIHtcbiAgICAgIHJlbW90ZVBhdGggPSByZW1vdGVQYXRoLnNsaWNlKDQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocmVtb3RlUGF0aC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgIHJlbW90ZVBhdGggPSByZW1vdGVQYXRoLnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1vdGVQYXRoLmluZGV4T2YoYXBwTmFtZSkgPT09IDApIHtcbiAgICBsZXQgZmluZFBhdGggPSBiYXNlUGF0aDtcbiAgICBpZiAodGhpcy5vcHRzLnBsYXRmb3JtVmVyc2lvbiA+PSA4KSB7XG4gICAgICAvLyB0aGUgLmFwcCBmaWxlIGFwcGVhcnMgaW4gL0NvbnRhaW5lcnMvRGF0YSBhbmQgL0NvbnRhaW5lcnMvQnVuZGxlIGJvdGguIFdlIG9ubHkgd2FudCAvQnVuZGxlXG4gICAgICBmaW5kUGF0aCA9IHBhdGgucmVzb2x2ZShiYXNlUGF0aCwgJ0NvbnRhaW5lcnMnLCAnQnVuZGxlJyk7XG4gICAgfVxuICAgIGZpbmRQYXRoID0gIGZpbmRQYXRoLnJlcGxhY2UoL1xccy9nLCAnXFxcXCAnKTtcblxuICAgIGxldCB7IHN0ZG91dCB9ID0gYXdhaXQgZXhlYygnZmluZCcsIFtmaW5kUGF0aCwgJy1uYW1lJywgYXBwTmFtZV0pO1xuICAgIGxldCBhcHBSb290ID0gc3Rkb3V0LnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgbGV0IHN1YlBhdGggPSByZW1vdGVQYXRoLnN1YnN0cmluZyhhcHBOYW1lLmxlbmd0aCArIDEpO1xuICAgIGxldCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShhcHBSb290LCBzdWJQYXRoKTtcbiAgICBsb2cuZGVidWcoYEZpbmRpbmcgYXBwLXJlbGF0aXZlIGZpbGU6ICcke2Z1bGxQYXRofSdgKTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKGJhc2VQYXRoLCByZW1vdGVQYXRoKTtcbiAgICBsb2cuZGVidWcoYEZpbmRpbmcgc2ltLXJlbGF0aXZlIGZpbGU6ICR7ZnVsbFBhdGh9YCk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xuICB9XG59O1xuXG5cbmV4cG9ydCB7IGNvbW1hbmRzIH07XG5leHBvcnQgZGVmYXVsdCBjb21tYW5kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
