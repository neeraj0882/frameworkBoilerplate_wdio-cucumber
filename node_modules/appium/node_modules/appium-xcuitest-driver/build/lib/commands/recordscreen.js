'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _asyncbox = require('asyncbox');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _teen_process = require('teen_process');

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _utils = require('../utils');

var commands = {};

var RETRY_PAUSE = 1000;
var MAX_RECORDING_TIME_SEC = 60 * 10;
var DEFAULT_RECORDING_TIME_SEC = 60 * 3;
var PROCESS_SHUTDOWN_TIMEOUT_SEC = 5;
var REAL_DEVICE_BINARY = 'xrecord';
var REAL_DEVICE_PGREP_PATTERN = function REAL_DEVICE_PGREP_PATTERN(udid) {
  return REAL_DEVICE_BINARY + '.*' + udid;
};
var SIMULATOR_BINARY = 'xcrun';
var SIMULATOR_PGREP_PATTERN = function SIMULATOR_PGREP_PATTERN(udid) {
  return 'simctl io ' + udid + ' recordVideo';
};
var DEFAULT_EXT = '.mp4';

function extractCurrentRecordingPath(pid) {
  var _ref, output, pattern, matches;

  return _regeneratorRuntime.async(function extractCurrentRecordingPath$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('ps', ['o', 'command', '-p', pid]));

      case 2:
        _ref = context$1$0.sent;
        output = _ref.output;

        _logger2['default'].debug('Got the following output from ps: ' + output);
        pattern = new RegExp(/[\s="'](\/.*\.mp4)/);
        matches = pattern.exec(output);
        return context$1$0.abrupt('return', _lodash2['default'].isEmpty(matches) ? null : _lodash2['default'].last(matches));

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function finishScreenCapture(pid) {
  return _regeneratorRuntime.async(function finishScreenCapture$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('kill', ['-2', pid]));

      case 3:
        context$1$0.next = 8;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);
        return context$1$0.abrupt('return', true);

      case 8:
        context$1$0.prev = 8;
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('kill', ['-0', pid]));

              case 3:
                context$2$0.next = 8;
                break;

              case 5:
                context$2$0.prev = 5;
                context$2$0.t0 = context$2$0['catch'](0);
                return context$2$0.abrupt('return', true);

              case 8:
                return context$2$0.abrupt('return', false);

              case 9:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[0, 5]]);
        }, { waitMs: PROCESS_SHUTDOWN_TIMEOUT_SEC * 1000, intervalMs: 300 }));

      case 11:
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t1 = context$1$0['catch'](8);
        return context$1$0.abrupt('return', false);

      case 16:
        return context$1$0.abrupt('return', true);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5], [8, 13]]);
}

function uploadRecordedMedia(localFile) {
  var remotePath = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var uploadOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _regeneratorRuntime.async(function uploadRecordedMedia$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _utils.encodeBase64OrUpload)(localFile, remotePath, uploadOptions));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(localFile));

      case 7:
        return context$1$0.finish(4);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0,, 4, 8]]);
}

/**
 * @typedef {Object} StartRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the resulting video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 *                                  This option only has an effect if there is screen recording process in progreess
 *                                  and `forceRestart` parameter is not set to `true`.
 * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 * @property {?string} videoType - The format of the screen capture to be recorded.
 *                                 Available formats: "h264", "mp4" or "fmp4". Default is "mp4".
 *                                 Only works for Simulator.
 * @property {?string} videoQuality - The video encoding quality (low, medium, high, photo - defaults to medium).
 *                                    Only works for real devices.
 * @property {?boolean} forceRestart - Whether to try to catch and upload/return the currently running screen recording
 *                                     (`false`, the default setting) or ignore the result of it and start a new recording
 *                                     immediately.
 * @property {?string|number} timeLimit - The maximum recording time, in seconds.
 *                                        The default value is 180, the maximum value is 600 (10 minutes).
 */

/**
 * Record the display of devices running iOS Simulator since Xcode 8.3 or real devices since iOS 8
 * (xrecord utility is required: https://github.com/WPO-Foundation/xrecord).
 * It records screen activity to an MPEG-4 file. Audio is not recorded with the video file.
 * If screen recording has been already started then the command will stop it forcefully and start a new one.
 * The previously recorded video file will be deleted.
 *
 * @param {?StartRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if
 *                   any screen recording is currently running or an empty string.
 * @throws {Error} If screen recording has failed to start.
 */
commands.startRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var videoType, _options$timeLimit, timeLimit, _options$videoQuality, videoQuality, forceRestart, result, pgrepPattern, pid, localPath, binaryName, args;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        videoType = options.videoType;
        _options$timeLimit = options.timeLimit;
        timeLimit = _options$timeLimit === undefined ? DEFAULT_RECORDING_TIME_SEC : _options$timeLimit;
        _options$videoQuality = options.videoQuality;
        videoQuality = _options$videoQuality === undefined ? 'medium' : _options$videoQuality;
        forceRestart = options.forceRestart;
        result = '';

        if (forceRestart) {
          context$1$0.next = 12;
          break;
        }

        _logger2['default'].info('Checking if there is/was a previous screen recording. ' + 'Set \'forceRestart\' option to \'true\' if you\'d like to skip this step.');
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.stopRecordingScreen(options));

      case 11:
        result = context$1$0.sent;

      case 12:
        pgrepPattern = this.isRealDevice() ? REAL_DEVICE_PGREP_PATTERN : SIMULATOR_PGREP_PATTERN;
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap((0, _utils.getPidUsingPattern)(pgrepPattern(this.opts.device.udid)));

      case 15:
        pid = context$1$0.sent;

        if (_lodash2['default'].isEmpty(pid)) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.prev = 17;
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('kill', [pid]));

      case 20:
        context$1$0.next = 25;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](17);

        _logger2['default'].errorAndThrow('Unable to stop screen recording process: ' + context$1$0.t0.message);

      case 25:
        if (_lodash2['default'].isEmpty(this._recentScreenRecordingPath)) {
          context$1$0.next = 29;
          break;
        }

        context$1$0.next = 28;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(this._recentScreenRecordingPath));

      case 28:
        this._recentScreenRecordingPath = null;

      case 29:
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({
          prefix: 'appium_' + Math.random().toString(16).substring(2, 8),
          suffix: DEFAULT_EXT
        }));

      case 31:
        localPath = context$1$0.sent;
        binaryName = undefined;
        args = undefined;

        if (!this.isRealDevice()) {
          context$1$0.next = 45;
          break;
        }

        binaryName = REAL_DEVICE_BINARY;
        context$1$0.next = 38;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which(binaryName));

      case 38:
        if (context$1$0.sent) {
          context$1$0.next = 40;
          break;
        }

        _logger2['default'].errorAndThrow('\'' + binaryName + '\' binary is not found in PATH. Make sure it is present on the system. ' + 'Check https://github.com/WPO-Foundation/xrecord for more details.');

      case 40:
        args = ['--quicktime', '--id', this.opts.device.udid, '--out', localPath, '--force'];
        if (_appiumSupport.util.hasValue(timeLimit)) {
          args.push('--time', '' + timeLimit);
        }
        if (_appiumSupport.util.hasValue(videoQuality)) {
          args.push('--quality', '' + videoQuality);
        }
        context$1$0.next = 49;
        break;

      case 45:
        binaryName = SIMULATOR_BINARY;
        args = ['simctl', 'io', this.opts.device.udid, 'recordVideo'];
        if (_appiumSupport.util.hasValue(videoType)) {
          args.push('--type', videoType);
        }
        args.push(localPath);

      case 49:
        context$1$0.next = 51;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$1$0(resolve, reject) {
          var err, timeout;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            var _this2 = this;

            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                err = null;
                timeout = Math.floor(parseFloat(timeLimit) * 1000);

                if (!(timeout > MAX_RECORDING_TIME_SEC * 1000 || timeout <= 0)) {
                  context$2$0.next = 4;
                  break;
                }

                return context$2$0.abrupt('return', reject(new Error('The timeLimit value must be in range (0, ' + MAX_RECORDING_TIME_SEC + '] seconds. ' + ('The value of ' + timeLimit + ' has been passed instead.'))));

              case 4:
                _logger2['default'].debug('Beginning screen recording with command: \'' + binaryName + ' ' + args.join(' ') + '\'' + ('Will timeout in ' + timeout / 1000 + ' s'));
                if (this.isRealDevice()) {
                  // xrecord has its owen timer, so we only use this one as a safety precaution
                  // although simctl has no built-in timer and we have to be precise in such case
                  timeout += PROCESS_SHUTDOWN_TIMEOUT_SEC * 1000 * 2;
                }
                // do not await here, as the call runs in the background and we check for its product
                (0, _teen_process.exec)(binaryName, args, { timeout: timeout, killSignal: 'SIGINT' })['catch'](function (e) {
                  err = e;
                });

                // there is the delay time to start recording the screen for real devices, so, wait until it is ready.
                // the ready condition is
                //   1. check the movie file is created
                //   2. check the screen capture has been started
                //
                // simctl keeps the file in an internal buffer instead and only creates it when the recording is done.

                if (!this.isRealDevice()) {
                  context$2$0.next = 16;
                  break;
                }

                context$2$0.prev = 8;
                context$2$0.next = 11;
                return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(10, RETRY_PAUSE, function callee$2$0() {
                  var _ref2, size;

                  return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                    while (1) switch (context$3$0.prev = context$3$0.next) {
                      case 0:
                        if (!err) {
                          context$3$0.next = 2;
                          break;
                        }

                        return context$3$0.abrupt('return');

                      case 2:
                        context$3$0.next = 4;
                        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(localPath));

                      case 4:
                        _ref2 = context$3$0.sent;
                        size = _ref2.size;

                        if (!(size <= 32)) {
                          context$3$0.next = 8;
                          break;
                        }

                        throw new Error('Remote file \'' + localPath + '\' found but it is still too small: ' + size + ' bytes');

                      case 8:
                      case 'end':
                        return context$3$0.stop();
                    }
                  }, null, _this2);
                }));

              case 11:
                context$2$0.next = 16;
                break;

              case 13:
                context$2$0.prev = 13;
                context$2$0.t0 = context$2$0['catch'](8);

                err = context$2$0.t0;

              case 16:
                if (!err) {
                  context$2$0.next = 19;
                  break;
                }

                _logger2['default'].error('Error recording screen: ' + err.message);
                return context$2$0.abrupt('return', reject(err));

              case 19:
                this._recentScreenRecordingPath = localPath;
                resolve(result);

              case 21:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[8, 13]]);
        }));

      case 51:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 52:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[17, 22]]);
};

/**
 * @typedef {Object} StopRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the resulting video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 */

/**
 * Stop recording the screen. If no screen recording process is running then
 * the endpoint will try to get the recently recorded file.
 * If no previously recorded file is found and no active screen recording
 * processes are running then the method returns an empty string.
 *
 * @param {?StopRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if 'remotePath'
 *                   parameter is empty or null or an empty string.
 * @throws {Error} If there was an error while getting the name of a media file
 *                 or the file content cannot be uploaded to the remote location.
 */
commands.stopRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var remotePath, user, pass, method, pgrepPattern, pid, localPath, result;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        remotePath = options.remotePath;
        user = options.user;
        pass = options.pass;
        method = options.method;
        pgrepPattern = this.isRealDevice() ? REAL_DEVICE_PGREP_PATTERN : SIMULATOR_PGREP_PATTERN;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _utils.getPidUsingPattern)(pgrepPattern(this.opts.device.udid)));

      case 7:
        pid = context$1$0.sent;
        localPath = this._recentScreenRecordingPath;

        if (!_lodash2['default'].isEmpty(pid)) {
          context$1$0.next = 13;
          break;
        }

        _logger2['default'].info('Screen recording is not running. There is nothing to stop.');
        context$1$0.next = 27;
        break;

      case 13:
        context$1$0.t0 = localPath;

        if (context$1$0.t0) {
          context$1$0.next = 18;
          break;
        }

        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(extractCurrentRecordingPath(pid));

      case 17:
        context$1$0.t0 = context$1$0.sent;

      case 18:
        localPath = context$1$0.t0;
        context$1$0.prev = 19;

        if (_lodash2['default'].isEmpty(localPath)) {
          _logger2['default'].errorAndThrow('Cannot parse the path to the file created by ' + 'screen recorder process from \'ps\' output. ' + 'Did you start screen recording before?');
        }

      case 21:
        context$1$0.prev = 21;
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(finishScreenCapture(pid));

      case 24:
        if (context$1$0.sent) {
          context$1$0.next = 26;
          break;
        }

        _logger2['default'].warn('Unable to stop screen recording. Continuing anyway');

      case 26:
        return context$1$0.finish(21);

      case 27:
        result = '';

        if (_lodash2['default'].isEmpty(localPath)) {
          context$1$0.next = 36;
          break;
        }

        context$1$0.prev = 29;
        context$1$0.next = 32;
        return _regeneratorRuntime.awrap(uploadRecordedMedia(localPath, remotePath, { user: user, pass: pass, method: method }));

      case 32:
        result = context$1$0.sent;

      case 33:
        context$1$0.prev = 33;

        this._recentScreenRecordingPath = null;
        return context$1$0.finish(33);

      case 36:
        return context$1$0.abrupt('return', result);

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[19,, 21, 27], [29,, 33, 36]]);
};

exports.commands = commands;
exports['default'] = commands;

// wrap in a manual Promise so we can handle errors in exec operation
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9yZWNvcmRzY3JlZW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7O3dCQUMwQixVQUFVOzt3QkFDNUMsVUFBVTs7Ozs2QkFDVSxnQkFBZ0I7OzRCQUM3QixjQUFjOztzQkFDbkIsV0FBVzs7OztxQkFDOEIsVUFBVTs7QUFHbkUsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDOztBQUVsQixJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDekIsSUFBTSxzQkFBc0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBQ3ZDLElBQU0sMEJBQTBCLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMxQyxJQUFNLDRCQUE0QixHQUFHLENBQUMsQ0FBQztBQUN2QyxJQUFNLGtCQUFrQixHQUFHLFNBQVMsQ0FBQztBQUNyQyxJQUFNLHlCQUF5QixHQUFHLFNBQTVCLHlCQUF5QixDQUFJLElBQUk7U0FBUSxrQkFBa0IsVUFBSyxJQUFJO0NBQUUsQ0FBQztBQUM3RSxJQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQztBQUNqQyxJQUFNLHVCQUF1QixHQUFHLFNBQTFCLHVCQUF1QixDQUFJLElBQUk7d0JBQWtCLElBQUk7Q0FBYyxDQUFDO0FBQzFFLElBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQzs7QUFFM0IsU0FBZSwyQkFBMkIsQ0FBRSxHQUFHO1lBQ3RDLE1BQU0sRUFFUCxPQUFPLEVBQ1AsT0FBTzs7Ozs7O3lDQUhVLHdCQUFLLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDOzs7O0FBQXZELGNBQU0sUUFBTixNQUFNOztBQUNiLDRCQUFJLEtBQUssd0NBQXNDLE1BQU0sQ0FBRyxDQUFDO0FBQ25ELGVBQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQztBQUMxQyxlQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7NENBQzdCLG9CQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLEdBQUcsb0JBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQzs7Ozs7OztDQUNuRDs7QUFFRCxTQUFlLG1CQUFtQixDQUFFLEdBQUc7Ozs7Ozs7O3lDQUU3Qix3QkFBSyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7Ozs7Ozs7Ozs0Q0FFeEIsSUFBSTs7Ozs7eUNBR0wsZ0NBQWlCOzs7Ozs7aURBRWIsd0JBQUssTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7Ozs7b0RBRXhCLElBQUk7OztvREFFTixLQUFLOzs7Ozs7O1NBQ2IsRUFBRSxFQUFDLE1BQU0sRUFBRSw0QkFBNEIsR0FBRyxJQUFJLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBQyxDQUFDOzs7Ozs7Ozs7NENBRTNELEtBQUs7Ozs0Q0FFUCxJQUFJOzs7Ozs7O0NBQ1o7O0FBRUQsU0FBZSxtQkFBbUIsQ0FBRSxTQUFTO01BQUUsVUFBVSx5REFBRyxJQUFJO01BQUUsYUFBYSx5REFBRyxFQUFFOzs7Ozs7eUNBRW5FLGlDQUFxQixTQUFTLEVBQUUsVUFBVSxFQUFFLGFBQWEsQ0FBQzs7Ozs7Ozs7eUNBRWpFLGtCQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7Ozs7Ozs7Ozs7Q0FFN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUNELFFBQVEsQ0FBQyxvQkFBb0IsR0FBRztNQUFnQixPQUFPLHlEQUFHLEVBQUU7O01BQ25ELFNBQVMsc0JBQUUsU0FBUyx5QkFBNkIsWUFBWSxFQUNsRSxZQUFZLEVBRVYsTUFBTSxFQU9KLFlBQVksRUFDWixHQUFHLEVBYUgsU0FBUyxFQUtYLFVBQVUsRUFDVixJQUFJOzs7Ozs7O0FBOUJELGlCQUFTLEdBQ0UsT0FBTyxDQURsQixTQUFTOzZCQUNFLE9BQU8sQ0FEUCxTQUFTO0FBQVQsaUJBQVMsc0NBQUMsMEJBQTBCO2dDQUNwQyxPQUFPLENBRCtCLFlBQVk7QUFBWixvQkFBWSx5Q0FBQyxRQUFRO0FBQzNFLG9CQUFZLEdBQUksT0FBTyxDQUF2QixZQUFZO0FBRVYsY0FBTSxHQUFHLEVBQUU7O1lBQ1YsWUFBWTs7Ozs7QUFDZiw0QkFBSSxJQUFJLENBQUMsc0lBQ3NFLENBQUMsQ0FBQzs7eUNBQ2xFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUM7OztBQUFoRCxjQUFNOzs7QUFHRixvQkFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUI7O3lDQUM1RSwrQkFBbUIsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFBbkUsV0FBRzs7WUFDSixvQkFBRSxPQUFPLENBQUMsR0FBRyxDQUFDOzs7Ozs7O3lDQUVULHdCQUFLLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBRXpCLDRCQUFJLGFBQWEsK0NBQTZDLGVBQUksT0FBTyxDQUFHLENBQUM7OztZQUc1RSxvQkFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDOzs7Ozs7eUNBQ3ZDLGtCQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUM7OztBQUNoRCxZQUFJLENBQUMsMEJBQTBCLEdBQUcsSUFBSSxDQUFDOzs7O3lDQUdqQix1QkFBUSxJQUFJLENBQUM7QUFDbkMsZ0JBQU0sY0FBWSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEFBQUU7QUFDOUQsZ0JBQU0sRUFBRSxXQUFXO1NBQ3BCLENBQUM7OztBQUhJLGlCQUFTO0FBS1gsa0JBQVU7QUFDVixZQUFJOzthQUNKLElBQUksQ0FBQyxZQUFZLEVBQUU7Ozs7O0FBQ3JCLGtCQUFVLEdBQUcsa0JBQWtCLENBQUM7O3lDQUNyQixrQkFBRyxLQUFLLENBQUMsVUFBVSxDQUFDOzs7Ozs7OztBQUM3Qiw0QkFBSSxhQUFhLENBQUMsT0FBSSxVQUFVLGtKQUNxRCxDQUFDLENBQUM7OztBQUV6RixZQUFJLEdBQUcsQ0FDTCxhQUFhLEVBQ2IsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFDN0IsT0FBTyxFQUFFLFNBQVMsWUFFbkIsQ0FBQztBQUNGLFlBQUksb0JBQUssUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO0FBQzVCLGNBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxPQUFLLFNBQVMsQ0FBRyxDQUFDO1NBQ3JDO0FBQ0QsWUFBSSxvQkFBSyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQUU7QUFDL0IsY0FBSSxDQUFDLElBQUksQ0FBQyxXQUFXLE9BQUssWUFBWSxDQUFHLENBQUM7U0FDM0M7Ozs7O0FBRUQsa0JBQVUsR0FBRyxnQkFBZ0IsQ0FBQztBQUM5QixZQUFJLEdBQUcsQ0FDTCxRQUFRLEVBQ1IsSUFBSSxFQUNKLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFDckIsYUFBYSxDQUNkLENBQUM7QUFDRixZQUFJLG9CQUFLLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtBQUM1QixjQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUNoQztBQUNELFlBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7eUNBSVYsMEJBQU0sb0JBQU8sT0FBTyxFQUFFLE1BQU07Y0FDbkMsR0FBRyxFQUNILE9BQU87Ozs7OztBQURQLG1CQUFHLEdBQUcsSUFBSTtBQUNWLHVCQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDOztzQkFDbEQsT0FBTyxHQUFHLHNCQUFzQixHQUFHLElBQUksSUFBSSxPQUFPLElBQUksQ0FBQyxDQUFBOzs7OztvREFDbEQsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDhDQUE0QyxzQkFBc0Isc0NBQ2xELFNBQVMsK0JBQTJCLENBQUMsQ0FBQzs7O0FBRWhGLG9DQUFJLEtBQUssQ0FBQyxnREFBNkMsVUFBVSxTQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGdDQUN0RCxPQUFPLEdBQUcsSUFBSSxRQUFJLENBQUMsQ0FBQztBQUNqRCxvQkFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUU7OztBQUd2Qix5QkFBTyxJQUFJLDRCQUE0QixHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7aUJBQ3BEOztBQUVELHdDQUFLLFVBQVUsRUFBRSxJQUFJLEVBQUUsRUFBQyxPQUFPLEVBQVAsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUMsQ0FBQyxTQUFNLENBQUMsVUFBQyxDQUFDLEVBQUs7QUFDbkUscUJBQUcsR0FBRyxDQUFDLENBQUM7aUJBQ1QsQ0FBQyxDQUFDOzs7Ozs7Ozs7cUJBUUMsSUFBSSxDQUFDLFlBQVksRUFBRTs7Ozs7OztpREFFYiw2QkFBYyxFQUFFLEVBQUUsV0FBVyxFQUFFOzZCQUs1QixJQUFJOzs7Ozs2QkFKUCxHQUFHOzs7Ozs7Ozs7eURBSWMsa0JBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQzs7OztBQUFoQyw0QkFBSSxTQUFKLElBQUk7OzhCQUNQLElBQUksSUFBSSxFQUFFLENBQUE7Ozs7OzhCQUNOLElBQUksS0FBSyxvQkFBaUIsU0FBUyw0Q0FBc0MsSUFBSSxZQUFTOzs7Ozs7O2lCQUUvRixDQUFDOzs7Ozs7Ozs7O0FBRUYsbUJBQUcsaUJBQUksQ0FBQzs7O3FCQUlSLEdBQUc7Ozs7O0FBQ0wsb0NBQUksS0FBSyw4QkFBNEIsR0FBRyxDQUFDLE9BQU8sQ0FBRyxDQUFDO29EQUM3QyxNQUFNLENBQUMsR0FBRyxDQUFDOzs7QUFFcEIsb0JBQUksQ0FBQywwQkFBMEIsR0FBRyxTQUFTLENBQUM7QUFDNUMsdUJBQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7Ozs7OztTQUNqQixDQUFDOzs7Ozs7Ozs7O0NBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkYsUUFBUSxDQUFDLG1CQUFtQixHQUFHO01BQWdCLE9BQU8seURBQUcsRUFBRTtNQUNsRCxVQUFVLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBRS9CLFlBQVksRUFDWixHQUFHLEVBQ0wsU0FBUyxFQWtCVCxNQUFNOzs7O0FBdEJILGtCQUFVLEdBQXdCLE9BQU8sQ0FBekMsVUFBVTtBQUFFLFlBQUksR0FBa0IsT0FBTyxDQUE3QixJQUFJO0FBQUUsWUFBSSxHQUFZLE9BQU8sQ0FBdkIsSUFBSTtBQUFFLGNBQU0sR0FBSSxPQUFPLENBQWpCLE1BQU07QUFFL0Isb0JBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCOzt5Q0FDNUUsK0JBQW1CLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7O0FBQW5FLFdBQUc7QUFDTCxpQkFBUyxHQUFHLElBQUksQ0FBQywwQkFBMEI7O2FBQzNDLG9CQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUM7Ozs7O0FBQ2hCLDRCQUFJLElBQUksOERBQThELENBQUM7Ozs7O3lCQUUzRCxTQUFTOzs7Ozs7Ozt5Q0FBVSwyQkFBMkIsQ0FBQyxHQUFHLENBQUM7Ozs7OztBQUEvRCxpQkFBUzs7O0FBRVAsWUFBSSxvQkFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7QUFDeEIsOEJBQUksYUFBYSxDQUFDLGdHQUM0QywyQ0FDSixDQUFDLENBQUM7U0FDN0Q7Ozs7O3lDQUVVLG1CQUFtQixDQUFDLEdBQUcsQ0FBQzs7Ozs7Ozs7QUFDakMsNEJBQUksSUFBSSxzREFBc0QsQ0FBQzs7Ozs7O0FBS2pFLGNBQU0sR0FBRyxFQUFFOztZQUNWLG9CQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUM7Ozs7Ozs7eUNBRU4sbUJBQW1CLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxFQUFDLElBQUksRUFBSixJQUFJLEVBQUUsSUFBSSxFQUFKLElBQUksRUFBRSxNQUFNLEVBQU4sTUFBTSxFQUFDLENBQUM7OztBQUEvRSxjQUFNOzs7OztBQUVOLFlBQUksQ0FBQywwQkFBMEIsR0FBRyxJQUFJLENBQUM7Ozs7NENBR3BDLE1BQU07Ozs7Ozs7Q0FDZCxDQUFDOztRQUdPLFFBQVEsR0FBUixRQUFRO3FCQUNGLFFBQVEiLCJmaWxlIjoibGliL2NvbW1hbmRzL3JlY29yZHNjcmVlbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgdXRpbCwgZnMsIHRlbXBEaXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IGdldFBpZFVzaW5nUGF0dGVybiwgZW5jb2RlQmFzZTY0T3JVcGxvYWQgfSBmcm9tICcuLi91dGlscyc7XG5cblxubGV0IGNvbW1hbmRzID0ge307XG5cbmNvbnN0IFJFVFJZX1BBVVNFID0gMTAwMDtcbmNvbnN0IE1BWF9SRUNPUkRJTkdfVElNRV9TRUMgPSA2MCAqIDEwO1xuY29uc3QgREVGQVVMVF9SRUNPUkRJTkdfVElNRV9TRUMgPSA2MCAqIDM7XG5jb25zdCBQUk9DRVNTX1NIVVRET1dOX1RJTUVPVVRfU0VDID0gNTtcbmNvbnN0IFJFQUxfREVWSUNFX0JJTkFSWSA9ICd4cmVjb3JkJztcbmNvbnN0IFJFQUxfREVWSUNFX1BHUkVQX1BBVFRFUk4gPSAodWRpZCkgPT4gYCR7UkVBTF9ERVZJQ0VfQklOQVJZfS4qJHt1ZGlkfWA7XG5jb25zdCBTSU1VTEFUT1JfQklOQVJZID0gJ3hjcnVuJztcbmNvbnN0IFNJTVVMQVRPUl9QR1JFUF9QQVRURVJOID0gKHVkaWQpID0+IGBzaW1jdGwgaW8gJHt1ZGlkfSByZWNvcmRWaWRlb2A7XG5jb25zdCBERUZBVUxUX0VYVCA9ICcubXA0JztcblxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEN1cnJlbnRSZWNvcmRpbmdQYXRoIChwaWQpIHtcbiAgY29uc3Qge291dHB1dH0gPSBhd2FpdCBleGVjKCdwcycsIFsnbycsICdjb21tYW5kJywgJy1wJywgcGlkXSk7XG4gIGxvZy5kZWJ1ZyhgR290IHRoZSBmb2xsb3dpbmcgb3V0cHV0IGZyb20gcHM6ICR7b3V0cHV0fWApO1xuICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCgvW1xccz1cIiddKFxcLy4qXFwubXA0KS8pO1xuICBjb25zdCBtYXRjaGVzID0gcGF0dGVybi5leGVjKG91dHB1dCk7XG4gIHJldHVybiBfLmlzRW1wdHkobWF0Y2hlcykgPyBudWxsIDogXy5sYXN0KG1hdGNoZXMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5pc2hTY3JlZW5DYXB0dXJlIChwaWQpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKCdraWxsJywgWyctMicsIHBpZF0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGV4ZWMoJ2tpbGwnLCBbJy0wJywgcGlkXSk7XG4gICAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwge3dhaXRNczogUFJPQ0VTU19TSFVURE9XTl9USU1FT1VUX1NFQyAqIDEwMDAsIGludGVydmFsTXM6IDMwMH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRSZWNvcmRlZE1lZGlhIChsb2NhbEZpbGUsIHJlbW90ZVBhdGggPSBudWxsLCB1cGxvYWRPcHRpb25zID0ge30pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZW5jb2RlQmFzZTY0T3JVcGxvYWQobG9jYWxGaWxlLCByZW1vdGVQYXRoLCB1cGxvYWRPcHRpb25zKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYobG9jYWxGaWxlKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXJ0UmVjb3JkaW5nT3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIHRoZSByZW1vdGUgbG9jYXRpb24sIHdoZXJlIHRoZSByZXN1bHRpbmcgdmlkZW8gc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGZvbGxvd2luZyBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZDogaHR0cC9odHRwcywgZnRwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVsbCBvciBlbXB0eSBzdHJpbmcgdmFsdWUgKHRoZSBkZWZhdWx0IHNldHRpbmcpIG1lYW5zIHRoZSBjb250ZW50IG9mIHJlc3VsdGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSBzaG91bGQgYmUgZW5jb2RlZCBhcyBCYXNlNjQgYW5kIHBhc3NlZCBhcyB0aGUgZW5kcG91bnQgcmVzcG9uc2UgdmFsdWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gaWYgdGhlIGdlbmVyYXRlZCBtZWRpYSBmaWxlIGlzIHRvbyBiaWcgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpdCBpbnRvIHRoZSBhdmFpbGFibGUgcHJvY2VzcyBtZW1vcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9wdGlvbiBvbmx5IGhhcyBhbiBlZmZlY3QgaWYgdGhlcmUgaXMgc2NyZWVuIHJlY29yZGluZyBwcm9jZXNzIGluIHByb2dyZWVzc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGBmb3JjZVJlc3RhcnRgIHBhcmFtZXRlciBpcyBub3Qgc2V0IHRvIGB0cnVlYC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdXNlciAtIFRoZSBuYW1lIG9mIHRoZSB1c2VyIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLiBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcGFzcyAtIFRoZSBwYXNzd29yZCBmb3IgdGhlIHJlbW90ZSBhdXRoZW50aWNhdGlvbi4gT25seSB3b3JrcyBpZiBgcmVtb3RlUGF0aGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG1ldGhvZCAtIFRoZSBodHRwIG11bHRpcGFydCB1cGxvYWQgbWV0aG9kIG5hbWUuIFRoZSAnUFVUJyBvbmUgaXMgdXNlZCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdmlkZW9UeXBlIC0gVGhlIGZvcm1hdCBvZiB0aGUgc2NyZWVuIGNhcHR1cmUgdG8gYmUgcmVjb3JkZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSBmb3JtYXRzOiBcImgyNjRcIiwgXCJtcDRcIiBvciBcImZtcDRcIi4gRGVmYXVsdCBpcyBcIm1wNFwiLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGZvciBTaW11bGF0b3IuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHZpZGVvUXVhbGl0eSAtIFRoZSB2aWRlbyBlbmNvZGluZyBxdWFsaXR5IChsb3csIG1lZGl1bSwgaGlnaCwgcGhvdG8gLSBkZWZhdWx0cyB0byBtZWRpdW0pLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGZvciByZWFsIGRldmljZXMuXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBmb3JjZVJlc3RhcnQgLSBXaGV0aGVyIHRvIHRyeSB0byBjYXRjaCBhbmQgdXBsb2FkL3JldHVybiB0aGUgY3VycmVudGx5IHJ1bm5pbmcgc2NyZWVuIHJlY29yZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGBmYWxzZWAsIHRoZSBkZWZhdWx0IHNldHRpbmcpIG9yIGlnbm9yZSB0aGUgcmVzdWx0IG9mIGl0IGFuZCBzdGFydCBhIG5ldyByZWNvcmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5LlxuICogQHByb3BlcnR5IHs/c3RyaW5nfG51bWJlcn0gdGltZUxpbWl0IC0gVGhlIG1heGltdW0gcmVjb3JkaW5nIHRpbWUsIGluIHNlY29uZHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxODAsIHRoZSBtYXhpbXVtIHZhbHVlIGlzIDYwMCAoMTAgbWludXRlcykuXG4gKi9cblxuLyoqXG4gKiBSZWNvcmQgdGhlIGRpc3BsYXkgb2YgZGV2aWNlcyBydW5uaW5nIGlPUyBTaW11bGF0b3Igc2luY2UgWGNvZGUgOC4zIG9yIHJlYWwgZGV2aWNlcyBzaW5jZSBpT1MgOFxuICogKHhyZWNvcmQgdXRpbGl0eSBpcyByZXF1aXJlZDogaHR0cHM6Ly9naXRodWIuY29tL1dQTy1Gb3VuZGF0aW9uL3hyZWNvcmQpLlxuICogSXQgcmVjb3JkcyBzY3JlZW4gYWN0aXZpdHkgdG8gYW4gTVBFRy00IGZpbGUuIEF1ZGlvIGlzIG5vdCByZWNvcmRlZCB3aXRoIHRoZSB2aWRlbyBmaWxlLlxuICogSWYgc2NyZWVuIHJlY29yZGluZyBoYXMgYmVlbiBhbHJlYWR5IHN0YXJ0ZWQgdGhlbiB0aGUgY29tbWFuZCB3aWxsIHN0b3AgaXQgZm9yY2VmdWxseSBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICogVGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmlkZW8gZmlsZSB3aWxsIGJlIGRlbGV0ZWQuXG4gKlxuICogQHBhcmFtIHs/U3RhcnRSZWNvcmRpbmdPcHRpb25zfSBvcHRpb25zIC0gVGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgY29udGVudCBvZiB0aGUgcmVjb3JkZWQgbWVkaWEgZmlsZSBpZlxuICogICAgICAgICAgICAgICAgICAgYW55IHNjcmVlbiByZWNvcmRpbmcgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHRocm93cyB7RXJyb3J9IElmIHNjcmVlbiByZWNvcmRpbmcgaGFzIGZhaWxlZCB0byBzdGFydC5cbiAqL1xuY29tbWFuZHMuc3RhcnRSZWNvcmRpbmdTY3JlZW4gPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHt2aWRlb1R5cGUsIHRpbWVMaW1pdD1ERUZBVUxUX1JFQ09SRElOR19USU1FX1NFQywgdmlkZW9RdWFsaXR5PSdtZWRpdW0nLFxuICAgIGZvcmNlUmVzdGFydH0gPSBvcHRpb25zO1xuXG4gIGxldCByZXN1bHQgPSAnJztcbiAgaWYgKCFmb3JjZVJlc3RhcnQpIHtcbiAgICBsb2cuaW5mbyhgQ2hlY2tpbmcgaWYgdGhlcmUgaXMvd2FzIGEgcHJldmlvdXMgc2NyZWVuIHJlY29yZGluZy4gYCArXG4gICAgICAgICAgICAgYFNldCAnZm9yY2VSZXN0YXJ0JyBvcHRpb24gdG8gJ3RydWUnIGlmIHlvdSdkIGxpa2UgdG8gc2tpcCB0aGlzIHN0ZXAuYCk7XG4gICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zdG9wUmVjb3JkaW5nU2NyZWVuKG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgcGdyZXBQYXR0ZXJuID0gdGhpcy5pc1JlYWxEZXZpY2UoKSA/IFJFQUxfREVWSUNFX1BHUkVQX1BBVFRFUk4gOiBTSU1VTEFUT1JfUEdSRVBfUEFUVEVSTjtcbiAgY29uc3QgcGlkID0gYXdhaXQgZ2V0UGlkVXNpbmdQYXR0ZXJuKHBncmVwUGF0dGVybih0aGlzLm9wdHMuZGV2aWNlLnVkaWQpKTtcbiAgaWYgKCFfLmlzRW1wdHkocGlkKSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBleGVjKCdraWxsJywgW3BpZF0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coYFVuYWJsZSB0byBzdG9wIHNjcmVlbiByZWNvcmRpbmcgcHJvY2VzczogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFfLmlzRW1wdHkodGhpcy5fcmVjZW50U2NyZWVuUmVjb3JkaW5nUGF0aCkpIHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodGhpcy5fcmVjZW50U2NyZWVuUmVjb3JkaW5nUGF0aCk7XG4gICAgdGhpcy5fcmVjZW50U2NyZWVuUmVjb3JkaW5nUGF0aCA9IG51bGw7XG4gIH1cblxuICBjb25zdCBsb2NhbFBhdGggPSBhd2FpdCB0ZW1wRGlyLnBhdGgoe1xuICAgIHByZWZpeDogYGFwcGl1bV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygyLCA4KX1gLFxuICAgIHN1ZmZpeDogREVGQVVMVF9FWFRcbiAgfSk7XG5cbiAgbGV0IGJpbmFyeU5hbWU7XG4gIGxldCBhcmdzO1xuICBpZiAodGhpcy5pc1JlYWxEZXZpY2UoKSkge1xuICAgIGJpbmFyeU5hbWUgPSBSRUFMX0RFVklDRV9CSU5BUlk7XG4gICAgaWYgKCFhd2FpdCBmcy53aGljaChiaW5hcnlOYW1lKSkge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coYCcke2JpbmFyeU5hbWV9JyBiaW5hcnkgaXMgbm90IGZvdW5kIGluIFBBVEguIE1ha2Ugc3VyZSBpdCBpcyBwcmVzZW50IG9uIHRoZSBzeXN0ZW0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYENoZWNrIGh0dHBzOi8vZ2l0aHViLmNvbS9XUE8tRm91bmRhdGlvbi94cmVjb3JkIGZvciBtb3JlIGRldGFpbHMuYCk7XG4gICAgfVxuICAgIGFyZ3MgPSBbXG4gICAgICAnLS1xdWlja3RpbWUnLFxuICAgICAgJy0taWQnLCB0aGlzLm9wdHMuZGV2aWNlLnVkaWQsXG4gICAgICAnLS1vdXQnLCBsb2NhbFBhdGgsXG4gICAgICBgLS1mb3JjZWBcbiAgICBdO1xuICAgIGlmICh1dGlsLmhhc1ZhbHVlKHRpbWVMaW1pdCkpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS10aW1lJywgYCR7dGltZUxpbWl0fWApO1xuICAgIH1cbiAgICBpZiAodXRpbC5oYXNWYWx1ZSh2aWRlb1F1YWxpdHkpKSB7XG4gICAgICBhcmdzLnB1c2goJy0tcXVhbGl0eScsIGAke3ZpZGVvUXVhbGl0eX1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmluYXJ5TmFtZSA9IFNJTVVMQVRPUl9CSU5BUlk7XG4gICAgYXJncyA9IFtcbiAgICAgICdzaW1jdGwnLFxuICAgICAgJ2lvJyxcbiAgICAgIHRoaXMub3B0cy5kZXZpY2UudWRpZCxcbiAgICAgICdyZWNvcmRWaWRlbydcbiAgICBdO1xuICAgIGlmICh1dGlsLmhhc1ZhbHVlKHZpZGVvVHlwZSkpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS10eXBlJywgdmlkZW9UeXBlKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGxvY2FsUGF0aCk7XG4gIH1cblxuICAvLyB3cmFwIGluIGEgbWFudWFsIFByb21pc2Ugc28gd2UgY2FuIGhhbmRsZSBlcnJvcnMgaW4gZXhlYyBvcGVyYXRpb25cbiAgcmV0dXJuIGF3YWl0IG5ldyBCKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgdGltZW91dCA9IE1hdGguZmxvb3IocGFyc2VGbG9hdCh0aW1lTGltaXQpICogMTAwMCk7XG4gICAgaWYgKHRpbWVvdXQgPiBNQVhfUkVDT1JESU5HX1RJTUVfU0VDICogMTAwMCB8fCB0aW1lb3V0IDw9IDApIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBUaGUgdGltZUxpbWl0IHZhbHVlIG11c3QgYmUgaW4gcmFuZ2UgKDAsICR7TUFYX1JFQ09SRElOR19USU1FX1NFQ31dIHNlY29uZHMuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFRoZSB2YWx1ZSBvZiAke3RpbWVMaW1pdH0gaGFzIGJlZW4gcGFzc2VkIGluc3RlYWQuYCkpO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYEJlZ2lubmluZyBzY3JlZW4gcmVjb3JkaW5nIHdpdGggY29tbWFuZDogJyR7YmluYXJ5TmFtZX0gJHthcmdzLmpvaW4oJyAnKX0nYCArXG4gICAgICAgICAgICAgIGBXaWxsIHRpbWVvdXQgaW4gJHt0aW1lb3V0IC8gMTAwMH0gc2ApO1xuICAgIGlmICh0aGlzLmlzUmVhbERldmljZSgpKSB7XG4gICAgICAvLyB4cmVjb3JkIGhhcyBpdHMgb3dlbiB0aW1lciwgc28gd2Ugb25seSB1c2UgdGhpcyBvbmUgYXMgYSBzYWZldHkgcHJlY2F1dGlvblxuICAgICAgLy8gYWx0aG91Z2ggc2ltY3RsIGhhcyBubyBidWlsdC1pbiB0aW1lciBhbmQgd2UgaGF2ZSB0byBiZSBwcmVjaXNlIGluIHN1Y2ggY2FzZVxuICAgICAgdGltZW91dCArPSBQUk9DRVNTX1NIVVRET1dOX1RJTUVPVVRfU0VDICogMTAwMCAqIDI7XG4gICAgfVxuICAgIC8vIGRvIG5vdCBhd2FpdCBoZXJlLCBhcyB0aGUgY2FsbCBydW5zIGluIHRoZSBiYWNrZ3JvdW5kIGFuZCB3ZSBjaGVjayBmb3IgaXRzIHByb2R1Y3RcbiAgICBleGVjKGJpbmFyeU5hbWUsIGFyZ3MsIHt0aW1lb3V0LCBraWxsU2lnbmFsOiAnU0lHSU5UJ30pLmNhdGNoKChlKSA9PiB7XG4gICAgICBlcnIgPSBlO1xuICAgIH0pO1xuXG4gICAgLy8gdGhlcmUgaXMgdGhlIGRlbGF5IHRpbWUgdG8gc3RhcnQgcmVjb3JkaW5nIHRoZSBzY3JlZW4gZm9yIHJlYWwgZGV2aWNlcywgc28sIHdhaXQgdW50aWwgaXQgaXMgcmVhZHkuXG4gICAgLy8gdGhlIHJlYWR5IGNvbmRpdGlvbiBpc1xuICAgIC8vICAgMS4gY2hlY2sgdGhlIG1vdmllIGZpbGUgaXMgY3JlYXRlZFxuICAgIC8vICAgMi4gY2hlY2sgdGhlIHNjcmVlbiBjYXB0dXJlIGhhcyBiZWVuIHN0YXJ0ZWRcbiAgICAvL1xuICAgIC8vIHNpbWN0bCBrZWVwcyB0aGUgZmlsZSBpbiBhbiBpbnRlcm5hbCBidWZmZXIgaW5zdGVhZCBhbmQgb25seSBjcmVhdGVzIGl0IHdoZW4gdGhlIHJlY29yZGluZyBpcyBkb25lLlxuICAgIGlmICh0aGlzLmlzUmVhbERldmljZSgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCByZXRyeUludGVydmFsKDEwLCBSRVRSWV9QQVVTRSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KGxvY2FsUGF0aCk7XG4gICAgICAgICAgaWYgKHNpemUgPD0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtb3RlIGZpbGUgJyR7bG9jYWxQYXRofScgZm91bmQgYnV0IGl0IGlzIHN0aWxsIHRvbyBzbWFsbDogJHtzaXplfSBieXRlc2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycikge1xuICAgICAgbG9nLmVycm9yKGBFcnJvciByZWNvcmRpbmcgc2NyZWVuOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9yZWNlbnRTY3JlZW5SZWNvcmRpbmdQYXRoID0gbG9jYWxQYXRoO1xuICAgIHJlc29sdmUocmVzdWx0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0b3BSZWNvcmRpbmdPcHRpb25zXG4gKlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gdGhlIHJlbW90ZSBsb2NhdGlvbiwgd2hlcmUgdGhlIHJlc3VsdGluZyB2aWRlbyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHByb3RvY29scyBhcmUgc3VwcG9ydGVkOiBodHRwL2h0dHBzLCBmdHAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdWxsIG9yIGVtcHR5IHN0cmluZyB2YWx1ZSAodGhlIGRlZmF1bHQgc2V0dGluZykgbWVhbnMgdGhlIGNvbnRlbnQgb2YgcmVzdWx0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHNob3VsZCBiZSBlbmNvZGVkIGFzIEJhc2U2NCBhbmQgcGFzc2VkIGFzIHRoZSBlbmRwb3VudCByZXNwb25zZSB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBpZiB0aGUgZ2VuZXJhdGVkIG1lZGlhIGZpbGUgaXMgdG9vIGJpZyB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml0IGludG8gdGhlIGF2YWlsYWJsZSBwcm9jZXNzIG1lbW9yeS5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdXNlciAtIFRoZSBuYW1lIG9mIHRoZSB1c2VyIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLiBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcGFzcyAtIFRoZSBwYXNzd29yZCBmb3IgdGhlIHJlbW90ZSBhdXRoZW50aWNhdGlvbi4gT25seSB3b3JrcyBpZiBgcmVtb3RlUGF0aGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG1ldGhvZCAtIFRoZSBodHRwIG11bHRpcGFydCB1cGxvYWQgbWV0aG9kIG5hbWUuIFRoZSAnUFVUJyBvbmUgaXMgdXNlZCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqL1xuXG4vKipcbiAqIFN0b3AgcmVjb3JkaW5nIHRoZSBzY3JlZW4uIElmIG5vIHNjcmVlbiByZWNvcmRpbmcgcHJvY2VzcyBpcyBydW5uaW5nIHRoZW5cbiAqIHRoZSBlbmRwb2ludCB3aWxsIHRyeSB0byBnZXQgdGhlIHJlY2VudGx5IHJlY29yZGVkIGZpbGUuXG4gKiBJZiBubyBwcmV2aW91c2x5IHJlY29yZGVkIGZpbGUgaXMgZm91bmQgYW5kIG5vIGFjdGl2ZSBzY3JlZW4gcmVjb3JkaW5nXG4gKiBwcm9jZXNzZXMgYXJlIHJ1bm5pbmcgdGhlbiB0aGUgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7P1N0b3BSZWNvcmRpbmdPcHRpb25zfSBvcHRpb25zIC0gVGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgY29udGVudCBvZiB0aGUgcmVjb3JkZWQgbWVkaWEgZmlsZSBpZiAncmVtb3RlUGF0aCdcbiAqICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBpcyBlbXB0eSBvciBudWxsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgbmFtZSBvZiBhIG1lZGlhIGZpbGVcbiAqICAgICAgICAgICAgICAgICBvciB0aGUgZmlsZSBjb250ZW50IGNhbm5vdCBiZSB1cGxvYWRlZCB0byB0aGUgcmVtb3RlIGxvY2F0aW9uLlxuICovXG5jb21tYW5kcy5zdG9wUmVjb3JkaW5nU2NyZWVuID0gYXN5bmMgZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7cmVtb3RlUGF0aCwgdXNlciwgcGFzcywgbWV0aG9kfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgcGdyZXBQYXR0ZXJuID0gdGhpcy5pc1JlYWxEZXZpY2UoKSA/IFJFQUxfREVWSUNFX1BHUkVQX1BBVFRFUk4gOiBTSU1VTEFUT1JfUEdSRVBfUEFUVEVSTjtcbiAgY29uc3QgcGlkID0gYXdhaXQgZ2V0UGlkVXNpbmdQYXR0ZXJuKHBncmVwUGF0dGVybih0aGlzLm9wdHMuZGV2aWNlLnVkaWQpKTtcbiAgbGV0IGxvY2FsUGF0aCA9IHRoaXMuX3JlY2VudFNjcmVlblJlY29yZGluZ1BhdGg7XG4gIGlmIChfLmlzRW1wdHkocGlkKSkge1xuICAgIGxvZy5pbmZvKGBTY3JlZW4gcmVjb3JkaW5nIGlzIG5vdCBydW5uaW5nLiBUaGVyZSBpcyBub3RoaW5nIHRvIHN0b3AuYCk7XG4gIH0gZWxzZSB7XG4gICAgbG9jYWxQYXRoID0gbG9jYWxQYXRoIHx8IGF3YWl0IGV4dHJhY3RDdXJyZW50UmVjb3JkaW5nUGF0aChwaWQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoXy5pc0VtcHR5KGxvY2FsUGF0aCkpIHtcbiAgICAgICAgbG9nLmVycm9yQW5kVGhyb3coYENhbm5vdCBwYXJzZSB0aGUgcGF0aCB0byB0aGUgZmlsZSBjcmVhdGVkIGJ5IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgc2NyZWVuIHJlY29yZGVyIHByb2Nlc3MgZnJvbSAncHMnIG91dHB1dC4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGBEaWQgeW91IHN0YXJ0IHNjcmVlbiByZWNvcmRpbmcgYmVmb3JlP2ApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoIWF3YWl0IGZpbmlzaFNjcmVlbkNhcHR1cmUocGlkKSkge1xuICAgICAgICBsb2cud2FybihgVW5hYmxlIHRvIHN0b3Agc2NyZWVuIHJlY29yZGluZy4gQ29udGludWluZyBhbnl3YXlgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGlmICghXy5pc0VtcHR5KGxvY2FsUGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUmVjb3JkZWRNZWRpYShsb2NhbFBhdGgsIHJlbW90ZVBhdGgsIHt1c2VyLCBwYXNzLCBtZXRob2R9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fcmVjZW50U2NyZWVuUmVjb3JkaW5nUGF0aCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbmV4cG9ydCB7IGNvbW1hbmRzIH07XG5leHBvcnQgZGVmYXVsdCBjb21tYW5kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
