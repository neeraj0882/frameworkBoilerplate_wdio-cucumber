'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var MESSAGE_TYPES = ['error', 'no data', 'regular', 'chunk', 'last chunk'];

var UNKNOWN_ERROR = {
  status: 13,
  value: 'Error parsing socket data from instruments'
};

/*
 * Object to contain the data received from the UI Automation system.
 */

var UIAutoResponse = (function () {
  function UIAutoResponse() {
    _classCallCheck(this, UIAutoResponse);

    this.bufferedData = '';
    this.resultBuffer = '';
  }

  _createClass(UIAutoResponse, [{
    key: 'resetBuffer',
    value: function resetBuffer() {
      this.bufferedData = '';
    }
  }, {
    key: 'addData',
    value: function addData(data) {
      this.bufferedData += data;
    }
  }, {
    key: 'finalizeData',
    value: function finalizeData() {
      var data = this.bufferedData;
      this.bufferedData = '';

      // try to figure out what type of data we have, and return it
      var parsedData = undefined;
      try {
        parsedData = {
          type: MESSAGE_TYPES[parseInt(data[0], 10)]
        };
        if (parsedData.type !== 'no data') {
          // format is <one char message type>,<DATA>
          parsedData.result = data.substring(2);
        }
      } catch (err) {
        _logger2['default'].error('Could not parse data from socket: ' + err);
        _logger2['default'].error(data);
        parsedData = {
          type: 'error',
          error: UNKNOWN_ERROR
        };
      }

      return parsedData;
    }
  }, {
    key: 'getResult',
    value: function getResult() {
      var data = this.finalizeData();

      if (!_lodash2['default'].isUndefined(data.result) && data.result !== false) {
        // we have a result, try to make use of it
        if (data.result) {
          _logger2['default'].debug('Got result from instruments: ' + data.result.slice(0, 300));
        } else {
          _logger2['default'].debug('Got null result from instruments');
        }

        if (data.type && data.type.indexOf('chunk') !== -1) {
          // a "chunk" of data, so add to our buffer
          this.resultBuffer += data.result;
          _logger2['default'].debug('Got chunk data, current resultBuffer length: ' + this.resultBuffer.length);
          if (data.type === 'last chunk') {
            _logger2['default'].debug('This is the last data final length: ' + this.resultBuffer.length);
            // this is the last row, unpack and return response
            var result = undefined;
            try {
              result = JSON.parse(this.resultBuffer);
            } catch (err) {
              _logger2['default'].error('Could not parse result buffer: ' + err);
              result = UNKNOWN_ERROR;
            }
            this.resultBuffer = '';
            return result;
          } else {
            _logger2['default'].debug('Not the last chunk, trying to get more');
            return {
              needsMoreData: true
            };
          }
        } else {
          // not a "chunk", so parse and return
          var result = undefined;
          try {
            result = JSON.parse(data.result);
          } catch (err) {
            _logger2['default'].error('Could not parse result buffer: ' + err);
            result = UNKNOWN_ERROR;
          }
          return result;
        }
      } else {
        // we have no result
        return null;
      }
    }
  }]);

  return UIAutoResponse;
})();

exports['default'] = UIAutoResponse;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91aWF1dG8vdWlhdXRvLXJlc3BvbnNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztzQkFBbUIsVUFBVTs7OztzQkFDZixRQUFROzs7O0FBRXRCLElBQU0sYUFBYSxHQUFHLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDOztBQUU3RSxJQUFNLGFBQWEsR0FBRztBQUNwQixRQUFNLEVBQUUsRUFBRTtBQUNWLE9BQUssRUFBRSw0Q0FBNEM7Q0FDcEQsQ0FBQzs7Ozs7O0lBTUksY0FBYztBQUNOLFdBRFIsY0FBYyxHQUNIOzBCQURYLGNBQWM7O0FBRWhCLFFBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLFFBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0dBQ3hCOztlQUpHLGNBQWM7O1dBTU4sdUJBQUc7QUFDYixVQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztLQUN4Qjs7O1dBRU8saUJBQUMsSUFBSSxFQUFFO0FBQ2IsVUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUM7S0FDM0I7OztXQUVZLHdCQUFHO0FBQ2QsVUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztBQUM3QixVQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQzs7O0FBR3ZCLFVBQUksVUFBVSxZQUFBLENBQUM7QUFDZixVQUFJO0FBQ0Ysa0JBQVUsR0FBRztBQUNYLGNBQUksRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUMzQyxDQUFDO0FBQ0YsWUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTs7QUFFakMsb0JBQVUsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN2QztPQUNGLENBQUMsT0FBTyxHQUFHLEVBQUU7QUFDWiw0QkFBTyxLQUFLLHdDQUFzQyxHQUFHLENBQUcsQ0FBQztBQUN6RCw0QkFBTyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDbkIsa0JBQVUsR0FBRztBQUNYLGNBQUksRUFBRSxPQUFPO0FBQ2IsZUFBSyxFQUFFLGFBQWE7U0FDckIsQ0FBQztPQUNIOztBQUVELGFBQU8sVUFBVSxDQUFDO0tBQ25COzs7V0FFUyxxQkFBRztBQUNYLFVBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQzs7QUFFL0IsVUFBSSxDQUFDLG9CQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxLQUFLLEVBQUU7O0FBRXhELFlBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNmLDhCQUFPLEtBQUssbUNBQWlDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBRyxDQUFDO1NBQzNFLE1BQU07QUFDTCw4QkFBTyxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztTQUNsRDs7QUFFRCxZQUFJLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7O0FBRWxELGNBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUNqQyw4QkFBTyxLQUFLLG1EQUFpRCxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBRyxDQUFDO0FBQ3pGLGNBQUksSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLEVBQUU7QUFDOUIsZ0NBQU8sS0FBSywwQ0FBd0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUcsQ0FBQzs7QUFFaEYsZ0JBQUksTUFBTSxZQUFBLENBQUM7QUFDWCxnQkFBSTtBQUNGLG9CQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDeEMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtBQUNaLGtDQUFPLEtBQUsscUNBQW1DLEdBQUcsQ0FBRyxDQUFDO0FBQ3RELG9CQUFNLEdBQUcsYUFBYSxDQUFDO2FBQ3hCO0FBQ0QsZ0JBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLG1CQUFPLE1BQU0sQ0FBQztXQUNmLE1BQU07QUFDTCxnQ0FBTyxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztBQUN2RCxtQkFBTztBQUNMLDJCQUFhLEVBQUUsSUFBSTthQUNwQixDQUFDO1dBQ0g7U0FDRixNQUFNOztBQUVMLGNBQUksTUFBTSxZQUFBLENBQUM7QUFDWCxjQUFJO0FBQ0Ysa0JBQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztXQUNsQyxDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ1osZ0NBQU8sS0FBSyxxQ0FBbUMsR0FBRyxDQUFHLENBQUM7QUFDdEQsa0JBQU0sR0FBRyxhQUFhLENBQUM7V0FDeEI7QUFDRCxpQkFBTyxNQUFNLENBQUM7U0FDZjtPQUNGLE1BQU07O0FBRUwsZUFBTyxJQUFJLENBQUM7T0FDYjtLQUNGOzs7U0F4RkcsY0FBYzs7O3FCQTJGTCxjQUFjIiwiZmlsZSI6ImxpYi91aWF1dG8vdWlhdXRvLXJlc3BvbnNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCBNRVNTQUdFX1RZUEVTID0gWydlcnJvcicsICdubyBkYXRhJywgJ3JlZ3VsYXInLCAnY2h1bmsnLCAnbGFzdCBjaHVuayddO1xuXG5jb25zdCBVTktOT1dOX0VSUk9SID0ge1xuICBzdGF0dXM6IDEzLFxuICB2YWx1ZTogJ0Vycm9yIHBhcnNpbmcgc29ja2V0IGRhdGEgZnJvbSBpbnN0cnVtZW50cydcbn07XG5cblxuLypcbiAqIE9iamVjdCB0byBjb250YWluIHRoZSBkYXRhIHJlY2VpdmVkIGZyb20gdGhlIFVJIEF1dG9tYXRpb24gc3lzdGVtLlxuICovXG5jbGFzcyBVSUF1dG9SZXNwb25zZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkRGF0YSA9ICcnO1xuICAgIHRoaXMucmVzdWx0QnVmZmVyID0gJyc7XG4gIH1cblxuICByZXNldEJ1ZmZlciAoKSB7XG4gICAgdGhpcy5idWZmZXJlZERhdGEgPSAnJztcbiAgfVxuXG4gIGFkZERhdGEgKGRhdGEpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkRGF0YSArPSBkYXRhO1xuICB9XG5cbiAgZmluYWxpemVEYXRhICgpIHtcbiAgICBsZXQgZGF0YSA9IHRoaXMuYnVmZmVyZWREYXRhO1xuICAgIHRoaXMuYnVmZmVyZWREYXRhID0gJyc7XG5cbiAgICAvLyB0cnkgdG8gZmlndXJlIG91dCB3aGF0IHR5cGUgb2YgZGF0YSB3ZSBoYXZlLCBhbmQgcmV0dXJuIGl0XG4gICAgbGV0IHBhcnNlZERhdGE7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZERhdGEgPSB7XG4gICAgICAgIHR5cGU6IE1FU1NBR0VfVFlQRVNbcGFyc2VJbnQoZGF0YVswXSwgMTApXSxcbiAgICAgIH07XG4gICAgICBpZiAocGFyc2VkRGF0YS50eXBlICE9PSAnbm8gZGF0YScpIHtcbiAgICAgICAgLy8gZm9ybWF0IGlzIDxvbmUgY2hhciBtZXNzYWdlIHR5cGU+LDxEQVRBPlxuICAgICAgICBwYXJzZWREYXRhLnJlc3VsdCA9IGRhdGEuc3Vic3RyaW5nKDIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgZGF0YSBmcm9tIHNvY2tldDogJHtlcnJ9YCk7XG4gICAgICBsb2dnZXIuZXJyb3IoZGF0YSk7XG4gICAgICBwYXJzZWREYXRhID0ge1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICBlcnJvcjogVU5LTk9XTl9FUlJPUlxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgfVxuXG4gIGdldFJlc3VsdCAoKSB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmZpbmFsaXplRGF0YSgpO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGRhdGEucmVzdWx0KSAmJiBkYXRhLnJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIHdlIGhhdmUgYSByZXN1bHQsIHRyeSB0byBtYWtlIHVzZSBvZiBpdFxuICAgICAgaWYgKGRhdGEucmVzdWx0KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgR290IHJlc3VsdCBmcm9tIGluc3RydW1lbnRzOiAke2RhdGEucmVzdWx0LnNsaWNlKDAsIDMwMCl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0dvdCBudWxsIHJlc3VsdCBmcm9tIGluc3RydW1lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLnR5cGUgJiYgZGF0YS50eXBlLmluZGV4T2YoJ2NodW5rJykgIT09IC0xKSB7XG4gICAgICAgIC8vIGEgXCJjaHVua1wiIG9mIGRhdGEsIHNvIGFkZCB0byBvdXIgYnVmZmVyXG4gICAgICAgIHRoaXMucmVzdWx0QnVmZmVyICs9IGRhdGEucmVzdWx0O1xuICAgICAgICBsb2dnZXIuZGVidWcoYEdvdCBjaHVuayBkYXRhLCBjdXJyZW50IHJlc3VsdEJ1ZmZlciBsZW5ndGg6ICR7dGhpcy5yZXN1bHRCdWZmZXIubGVuZ3RofWApO1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnbGFzdCBjaHVuaycpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoaXMgaXMgdGhlIGxhc3QgZGF0YSBmaW5hbCBsZW5ndGg6ICR7dGhpcy5yZXN1bHRCdWZmZXIubGVuZ3RofWApO1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGxhc3Qgcm93LCB1bnBhY2sgYW5kIHJldHVybiByZXNwb25zZVxuICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UodGhpcy5yZXN1bHRCdWZmZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgcmVzdWx0IGJ1ZmZlcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICByZXN1bHQgPSBVTktOT1dOX0VSUk9SO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlc3VsdEJ1ZmZlciA9ICcnO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdOb3QgdGhlIGxhc3QgY2h1bmssIHRyeWluZyB0byBnZXQgbW9yZScpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZWVkc01vcmVEYXRhOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90IGEgXCJjaHVua1wiLCBzbyBwYXJzZSBhbmQgcmV0dXJuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhLnJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgQ291bGQgbm90IHBhcnNlIHJlc3VsdCBidWZmZXI6ICR7ZXJyfWApO1xuICAgICAgICAgIHJlc3VsdCA9IFVOS05PV05fRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgaGF2ZSBubyByZXN1bHRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVSUF1dG9SZXNwb25zZTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
