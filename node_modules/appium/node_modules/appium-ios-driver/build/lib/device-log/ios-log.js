'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _appiumSupport = require('appium-support');

var _teen_process = require('teen_process');

var START_TIMEOUT = 10000;
var DEVICE_CONSOLE_PATH = _path2['default'].resolve(__dirname, '..', '..', '..', 'build', 'deviceconsole');
var SYSTEM_LOG_PATH = '/var/log/system.log';
// We keep only the most recent log entries to avoid out of memory error
var MAX_LOG_ENTRIES_COUNT = 10000;

var IOSLog = (function () {
  function IOSLog(opts) {
    _classCallCheck(this, IOSLog);

    this.sim = opts.sim;
    this.udid = opts.udid;
    this.showLogs = !!opts.showLogs;
    this.realDeviceLogger = opts.realDeviceLogger || 'idevicesyslog';
    this.xcodeVersion = opts.xcodeVersion;

    this.proc = null;
    this.logs = [];
    this.logRow = '';
    this.logIdxSinceLastRequest = -1;
    this.maxBufferSize = MAX_LOG_ENTRIES_COUNT;
  }

  _createClass(IOSLog, [{
    key: 'startCaptureRealDevice',
    value: function startCaptureRealDevice() {
      var cmd, args, env, deviceconsole, stat;
      return _regeneratorRuntime.async(function startCaptureRealDevice$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined, args = undefined, env = undefined;

            if (!((this.realDeviceLogger || '').indexOf('idevicesyslog') !== -1)) {
              context$2$0.next = 24;
              break;
            }

            _logger2['default'].debug('Attempting iOS device log capture via libimobiledevice idevicesyslog');

            if (!(this.realDeviceLogger.toLowerCase() === 'idevicesyslog')) {
              context$2$0.next = 15;
              break;
            }

            cmd = 'idevicesyslog';
            context$2$0.prev = 5;
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.which('idevicesyslog'));

          case 8:
            context$2$0.next = 13;
            break;

          case 10:
            context$2$0.prev = 10;
            context$2$0.t0 = context$2$0['catch'](5);
            throw new Error('Unable to find system idevicesyslog: ' + context$2$0.t0.message);

          case 13:
            context$2$0.next = 20;
            break;

          case 15:
            context$2$0.next = 17;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(this.realDeviceLogger));

          case 17:
            if (context$2$0.sent) {
              context$2$0.next = 19;
              break;
            }

            throw new Error('Unable to find idevicesyslog from \'realDeviceLogger\' capability \'' + this.realDeviceLogger + '\'');

          case 19:
            cmd = this.realDeviceLogger;

          case 20:

            args = ['-u', this.udid];
            env = process.env;
            context$2$0.next = 57;
            break;

          case 24:
            if (!((this.realDeviceLogger || '').indexOf('deviceconsole') !== -1)) {
              context$2$0.next = 56;
              break;
            }

            _logger2['default'].debug('Attempting iOS device log capture via deviceconsole');
            deviceconsole = undefined;

            if (!(this.realDeviceLogger.toLowerCase() === 'deviceconsole')) {
              context$2$0.next = 31;
              break;
            }

            deviceconsole = DEVICE_CONSOLE_PATH;
            context$2$0.next = 48;
            break;

          case 31:
            stat = undefined;
            context$2$0.prev = 32;
            context$2$0.next = 35;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(this.realDeviceLogger));

          case 35:
            stat = context$2$0.sent;
            context$2$0.next = 41;
            break;

          case 38:
            context$2$0.prev = 38;
            context$2$0.t1 = context$2$0['catch'](32);
            throw new Error('Unable to find deviceconsole from \'realDeviceLogger\' capability \'' + this.realDeviceLogger + '\': ' + context$2$0.t1.message);

          case 41:
            if (!stat.isDirectory()) {
              context$2$0.next = 45;
              break;
            }

            deviceconsole = this.realDeviceLogger;
            context$2$0.next = 48;
            break;

          case 45:
            if (_lodash2['default'].endsWith(this.realDeviceLogger, 'deviceconsole')) {
              context$2$0.next = 47;
              break;
            }

            throw new Error('Unable to parse \'deviceconsole\' installation directory from \'' + this.realDeviceLogger + '\'');

          case 47:
            // remove the executable, and trailing `/`, to get the install directory
            deviceconsole = _path2['default'].dirname(this.realDeviceLogger);

          case 48:

            _logger2['default'].debug('Using \'deviceconsole\' from \'' + deviceconsole + '\'');

            cmd = deviceconsole + '/deviceconsole';
            args = ['-u', this.udid];

            // set up the environment to be able to run deviceconsole
            env = _lodash2['default'].clone(process.env);
            env.DYLD_LIBRARY_PATH = deviceconsole;
            if (process.env.DYLD_LIBRARY_PATH) {
              env.DYLD_LIBRARY_PATH = env.DYLD_LIBRARY_PATH + ':' + process.env.DYLD_LIBRARY_PATH;
            }
            context$2$0.next = 57;
            break;

          case 56:
            _logger2['default'].errorAndThrow('Unable to capture device log. Unknown \'realDeviceLogger\': \'' + this.realDeviceLogger + '\'');

          case 57:

            this.subprocessId = cmd + '_' + this.udid;

            _logger2['default'].debug('Starting iOS device log capture with: \'' + cmd + '\'');

            context$2$0.prev = 59;
            context$2$0.next = 62;
            return _regeneratorRuntime.awrap(this.killExistingSysLogProcesses(cmd, args));

          case 62:
            context$2$0.next = 66;
            break;

          case 64:
            context$2$0.prev = 64;
            context$2$0.t2 = context$2$0['catch'](59);

          case 66:

            // just use one instance of 'idevicesyslog' per udid
            this.proc = this.getIDeviceSysLogProcess(cmd, args, env);

            context$2$0.next = 69;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 69:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[5, 10], [32, 38], [59, 64]]);
    }
  }, {
    key: 'startCaptureSimulator',
    value: function startCaptureSimulator() {
      var logPath, systemLogPath, files, lastModifiedLogPath, lastModifiedLogTime, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, file, _ref, mtime, tailArgs;

      return _regeneratorRuntime.async(function startCaptureSimulator$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.t0 = _logger2['default'];
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.sim.getPlatformVersion());

          case 3:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = 'Starting iOS ' + context$2$0.t1;
            context$2$0.t3 = context$2$0.t2 + ' simulator log capture';
            context$2$0.t0.debug.call(context$2$0.t0, context$2$0.t3);

            if (!(this.xcodeVersion.major < 5)) {
              context$2$0.next = 12;
              break;
            }

            this.proc = new _teen_process.SubProcess('tail', ['-f', '-n', '1', SYSTEM_LOG_PATH]);
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 11:
            return context$2$0.abrupt('return');

          case 12:

            // this is xcode 6+
            if (_lodash2['default'].isUndefined(this.sim.udid)) {
              _logger2['default'].errorAndThrow('iOS log capture with Xcode ' + this.xcodeVersion.versionString + ' requires a sim udid');
            }

            logPath = this.sim.getLogDir();
            context$2$0.prev = 14;

            if (!(logPath.indexOf('*') >= 0)) {
              context$2$0.next = 18;
              break;
            }

            _logger2['default'].error('Log path has * in it. Unable to start log capture: ' + logPath);
            return context$2$0.abrupt('return');

          case 18:
            systemLogPath = _path2['default'].resolve(logPath, 'system.log');

            _logger2['default'].debug('System log path: ' + systemLogPath);
            context$2$0.next = 22;
            return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(logPath));

          case 22:
            context$2$0.next = 24;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(systemLogPath, 'A new Appium session is about to start!\n', { flag: 'a' }));

          case 24:
            files = undefined;
            context$2$0.prev = 25;
            context$2$0.next = 28;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.glob(systemLogPath));

          case 28:
            files = context$2$0.sent;

            if (!(files.length < 1)) {
              context$2$0.next = 31;
              break;
            }

            throw new Error('Could not start log capture');

          case 31:
            context$2$0.next = 36;
            break;

          case 33:
            context$2$0.prev = 33;
            context$2$0.t4 = context$2$0['catch'](25);

            _logger2['default'].error('Could not start log capture because no iOS ' + ('simulator logs could be found at ' + systemLogPath + '. ') + 'Logging will not be functional for this run');

          case 36:
            lastModifiedLogPath = files[0];
            context$2$0.next = 39;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(lastModifiedLogPath));

          case 39:
            lastModifiedLogTime = context$2$0.sent.mtime;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 43;
            _iterator = _getIterator(files);

          case 45:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 55;
              break;
            }

            file = _step.value;
            context$2$0.next = 49;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(file));

          case 49:
            _ref = context$2$0.sent;
            mtime = _ref.mtime;

            if (mtime > lastModifiedLogTime) {
              lastModifiedLogPath = file;
              lastModifiedLogTime = mtime;
            }

          case 52:
            _iteratorNormalCompletion = true;
            context$2$0.next = 45;
            break;

          case 55:
            context$2$0.next = 61;
            break;

          case 57:
            context$2$0.prev = 57;
            context$2$0.t5 = context$2$0['catch'](43);
            _didIteratorError = true;
            _iteratorError = context$2$0.t5;

          case 61:
            context$2$0.prev = 61;
            context$2$0.prev = 62;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 64:
            context$2$0.prev = 64;

            if (!_didIteratorError) {
              context$2$0.next = 67;
              break;
            }

            throw _iteratorError;

          case 67:
            return context$2$0.finish(64);

          case 68:
            return context$2$0.finish(61);

          case 69:
            tailArgs = ['-f', '-n', '1', lastModifiedLogPath];
            context$2$0.prev = 70;
            context$2$0.next = 73;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', ['-xf', ['tail'].concat(tailArgs).join(' ')]));

          case 73:
            context$2$0.next = 77;
            break;

          case 75:
            context$2$0.prev = 75;
            context$2$0.t6 = context$2$0['catch'](70);

          case 77:
            this.proc = new _teen_process.SubProcess('tail', tailArgs);
            context$2$0.next = 80;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 80:
            context$2$0.next = 85;
            break;

          case 82:
            context$2$0.prev = 82;
            context$2$0.t7 = context$2$0['catch'](14);

            _logger2['default'].errorAndThrow('Simulator log capture failed: ' + context$2$0.t7.message);

          case 85:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[14, 82], [25, 33], [43, 57, 61, 69], [62,, 64, 68], [70, 75]]);
    }
  }, {
    key: 'startCapture',
    value: function startCapture() {
      return _regeneratorRuntime.async(function startCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.udid) {
              context$2$0.next = 4;
              break;
            }

            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.startCaptureRealDevice());

          case 3:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 4:
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.startCaptureSimulator());

          case 6:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 7:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'finishStartingLogCapture',
    value: function finishStartingLogCapture() {
      var firstLine, sd;
      return _regeneratorRuntime.async(function finishStartingLogCapture$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc) {
              _logger2['default'].errorAndThrow('Could not capture device log');
            }
            firstLine = true;

            this.proc.on('output', function (stdout, stderr) {
              if (stdout) {
                if (firstLine) {
                  if (stdout.substr(-1, 1) === '\n') {
                    // don't store the first line of the log because it came before the sim or device was launched
                    firstLine = false;
                  }
                } else {
                  _this.logRow += stdout;
                  if (stdout.substr(-1, 1) === '\n') {
                    _this.onOutput();
                    _this.logRow = '';
                  }
                }
              }
              if (stderr) {
                _this.onOutput('STDERR');
              }
            });

            sd = function sd(stdout, stderr) {
              if (/execvp\(\)/.test(stderr)) {
                throw new Error('iOS log capture process failed to start');
              }
              return stdout || stderr;
            };

            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.proc.start(sd, START_TIMEOUT));

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stopCapture',
    value: function stopCapture() {
      var cachedSysLog;
      return _regeneratorRuntime.async(function stopCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc) {
              context$2$0.next = 12;
              break;
            }

            if (!this.udid) {
              context$2$0.next = 10;
              break;
            }

            cachedSysLog = IOSLog.cachedIDeviceSysLogs[this.subprocessId];

            cachedSysLog.count--;

            if (!(cachedSysLog.count === 0)) {
              context$2$0.next = 8;
              break;
            }

            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(this.killLogSubProcess());

          case 7:
            delete IOSLog.cachedIDeviceSysLogs[this.subprocessId];

          case 8:
            context$2$0.next = 12;
            break;

          case 10:
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.killLogSubProcess());

          case 12:
            this.proc = null;

          case 13:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killLogSubProcess',
    value: function killLogSubProcess() {
      return _regeneratorRuntime.async(function killLogSubProcess$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc.isRunning) {
              context$2$0.next = 12;
              break;
            }

            _logger2['default'].debug('Stopping iOS log capture');
            context$2$0.prev = 2;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGTERM', 1000));

          case 5:
            context$2$0.next = 12;
            break;

          case 7:
            context$2$0.prev = 7;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].error('Cannot stop log capture process. Sending SIGKILL...');
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGKILL'));

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 7]]);
    }
  }, {
    key: 'onOutput',
    value: function onOutput() {
      var prefix = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

      var logs = this.logRow.split('\n');
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _getIterator(logs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var log = _step2.value;

          if (!log) continue; // eslint-disable-line curly
          var logObj = {
            timestamp: Date.now(),
            level: 'ALL',
            message: log
          };
          this.logs.push(logObj);
          if (this.logs.length > this.maxBufferSize) {
            this.logs.shift();
            if (this.logIdxSinceLastRequest > 0) {
              --this.logIdxSinceLastRequest;
            }
          }
          if (this.showLogs) {
            var space = prefix.length > 0 ? ' ' : '';
            _logger2['default'].info('[IOS_SYSLOG_ROW' + space + prefix + '] ' + log);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'getLogs',
    value: function getLogs() {
      var result;
      return _regeneratorRuntime.async(function getLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!(this.logs.length && this.logIdxSinceLastRequest < this.logs.length)) {
              context$2$0.next = 5;
              break;
            }

            result = this.logs;

            if (this.logIdxSinceLastRequest > 0) {
              result = result.slice(this.logIdxSinceLastRequest);
            }
            this.logIdxSinceLastRequest = this.logs.length;
            return context$2$0.abrupt('return', result);

          case 5:
            return context$2$0.abrupt('return', []);

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getAllLogs',
    value: function getAllLogs() {
      return _regeneratorRuntime.async(function getAllLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', this.logs);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killExistingSysLogProcesses',
    value: function killExistingSysLogProcesses(cmd, args) {
      return _regeneratorRuntime.async(function killExistingSysLogProcesses$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (IOSLog.cachedIDeviceSysLogs[this.subprocessId]) {
              context$2$0.next = 3;
              break;
            }

            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', ['-xf', [cmd].concat(_toConsumableArray(args)).join(' ')]));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get 'idevicesyslog' subprocess for a given udid.
     *
     * This function caches and re-uses instances so that there's
     * just one instance per device (cache by UDID)
     */
  }, {
    key: 'getIDeviceSysLogProcess',
    value: function getIDeviceSysLogProcess(cmd, args, env) {
      var _this2 = this;

      if (!IOSLog.cachedIDeviceSysLogs[this.subprocessId]) {
        var _IOSLog$cachedIDeviceSysLogs$subprocessId = IOSLog.cachedIDeviceSysLogs[this.subprocessId] = {
          proc: new _teen_process.SubProcess(cmd, args, { env: env }),
          count: 1
        };

        var proc = _IOSLog$cachedIDeviceSysLogs$subprocessId.proc;

        // If the process dies, remove it from the cache
        proc.on('exit', function () {
          return delete IOSLog.cachedIDeviceSysLogs[_this2.subprocessId];
        });
      } else {
        IOSLog.cachedIDeviceSysLogs[this.subprocessId].count++;
      }
      return IOSLog.cachedIDeviceSysLogs[this.subprocessId].proc;
    }
  }]);

  return IOSLog;
})();

IOSLog.cachedIDeviceSysLogs = {};

exports.IOSLog = IOSLog;
exports.DEVICE_CONSOLE_PATH = DEVICE_CONSOLE_PATH;
exports['default'] = IOSLog;

// make sure it is available on the PATH

// make sure the executable exists

// make sure that we have the path to the directory,
// not the actual executable

// make sure they've passed in `deviceconsole` and not something random

// cleanup existing listeners if the previous session has not been terminated properly

// otherwise, if we have a simulator...

// cleanup existing listeners if the previous session has not been terminated properly

// if we have a real device

// If no other UDID's are using 'idevicesyslog' kill it
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kZXZpY2UtbG9nL2lvcy1sb2cuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQixNQUFNOzs7O3NCQUNULFFBQVE7Ozs7c0JBQ0gsVUFBVTs7Ozs2QkFDRixnQkFBZ0I7OzRCQUNWLGNBQWM7O0FBRS9DLElBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQztBQUM1QixJQUFNLG1CQUFtQixHQUFHLGtCQUFLLE9BQU8sQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBQ2hHLElBQU0sZUFBZSxHQUFHLHFCQUFxQixDQUFDOztBQUU5QyxJQUFNLHFCQUFxQixHQUFHLEtBQUssQ0FBQzs7SUFFOUIsTUFBTTtBQUNFLFdBRFIsTUFBTSxDQUNHLElBQUksRUFBRTswQkFEZixNQUFNOztBQUVSLFFBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNwQixRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDdEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUNoQyxRQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixJQUFJLGVBQWUsQ0FBQztBQUNqRSxRQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7O0FBRXRDLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ2YsUUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDakIsUUFBSSxDQUFDLHNCQUFzQixHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2pDLFFBQUksQ0FBQyxhQUFhLEdBQUcscUJBQXFCLENBQUM7R0FDNUM7O2VBYkcsTUFBTTs7V0FlbUI7VUFDdkIsR0FBRyxFQUFF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QkFDckIsTUFBTSIsImZpbGUiOiJsaWIvZGV2aWNlLWxvZy9pb3MtbG9nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBmcywgbWtkaXJwIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHsgU3ViUHJvY2VzcywgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5cbmNvbnN0IFNUQVJUX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IERFVklDRV9DT05TT0xFX1BBVEggPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAnYnVpbGQnLCAnZGV2aWNlY29uc29sZScpO1xuY29uc3QgU1lTVEVNX0xPR19QQVRIID0gJy92YXIvbG9nL3N5c3RlbS5sb2cnO1xuLy8gV2Uga2VlcCBvbmx5IHRoZSBtb3N0IHJlY2VudCBsb2cgZW50cmllcyB0byBhdm9pZCBvdXQgb2YgbWVtb3J5IGVycm9yXG5jb25zdCBNQVhfTE9HX0VOVFJJRVNfQ09VTlQgPSAxMDAwMDtcblxuY2xhc3MgSU9TTG9nIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLnNpbSA9IG9wdHMuc2ltO1xuICAgIHRoaXMudWRpZCA9IG9wdHMudWRpZDtcbiAgICB0aGlzLnNob3dMb2dzID0gISFvcHRzLnNob3dMb2dzO1xuICAgIHRoaXMucmVhbERldmljZUxvZ2dlciA9IG9wdHMucmVhbERldmljZUxvZ2dlciB8fCAnaWRldmljZXN5c2xvZyc7XG4gICAgdGhpcy54Y29kZVZlcnNpb24gPSBvcHRzLnhjb2RlVmVyc2lvbjtcblxuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgdGhpcy5sb2dSb3cgPSAnJztcbiAgICB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPSAtMTtcbiAgICB0aGlzLm1heEJ1ZmZlclNpemUgPSBNQVhfTE9HX0VOVFJJRVNfQ09VTlQ7XG4gIH1cblxuICBhc3luYyBzdGFydENhcHR1cmVSZWFsRGV2aWNlICgpIHtcbiAgICBsZXQgY21kLCBhcmdzLCBlbnY7XG4gICAgaWYgKCh0aGlzLnJlYWxEZXZpY2VMb2dnZXIgfHwgJycpLmluZGV4T2YoJ2lkZXZpY2VzeXNsb2cnKSAhPT0gLTEpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQXR0ZW1wdGluZyBpT1MgZGV2aWNlIGxvZyBjYXB0dXJlIHZpYSBsaWJpbW9iaWxlZGV2aWNlIGlkZXZpY2VzeXNsb2cnKTtcbiAgICAgIGlmICh0aGlzLnJlYWxEZXZpY2VMb2dnZXIudG9Mb3dlckNhc2UoKSA9PT0gJ2lkZXZpY2VzeXNsb2cnKSB7XG4gICAgICAgIGNtZCA9ICdpZGV2aWNlc3lzbG9nJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgaXQgaXMgYXZhaWxhYmxlIG9uIHRoZSBQQVRIXG4gICAgICAgICAgYXdhaXQgZnMud2hpY2goJ2lkZXZpY2VzeXNsb2cnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBzeXN0ZW0gaWRldmljZXN5c2xvZzogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBleGVjdXRhYmxlIGV4aXN0c1xuICAgICAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyh0aGlzLnJlYWxEZXZpY2VMb2dnZXIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBpZGV2aWNlc3lzbG9nIGZyb20gJ3JlYWxEZXZpY2VMb2dnZXInIGNhcGFiaWxpdHkgJyR7dGhpcy5yZWFsRGV2aWNlTG9nZ2VyfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBjbWQgPSB0aGlzLnJlYWxEZXZpY2VMb2dnZXI7XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSBbJy11JywgdGhpcy51ZGlkXTtcbiAgICAgIGVudiA9IHByb2Nlc3MuZW52O1xuICAgIH0gZWxzZSBpZiAoKHRoaXMucmVhbERldmljZUxvZ2dlciB8fCAnJykuaW5kZXhPZignZGV2aWNlY29uc29sZScpICE9PSAtMSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdBdHRlbXB0aW5nIGlPUyBkZXZpY2UgbG9nIGNhcHR1cmUgdmlhIGRldmljZWNvbnNvbGUnKTtcbiAgICAgIGxldCBkZXZpY2Vjb25zb2xlO1xuICAgICAgaWYgKHRoaXMucmVhbERldmljZUxvZ2dlci50b0xvd2VyQ2FzZSgpID09PSAnZGV2aWNlY29uc29sZScpIHtcbiAgICAgICAgZGV2aWNlY29uc29sZSA9IERFVklDRV9DT05TT0xFX1BBVEg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnksXG4gICAgICAgIC8vIG5vdCB0aGUgYWN0dWFsIGV4ZWN1dGFibGVcbiAgICAgICAgbGV0IHN0YXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdCA9IGF3YWl0IGZzLnN0YXQodGhpcy5yZWFsRGV2aWNlTG9nZ2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBkZXZpY2Vjb25zb2xlIGZyb20gJ3JlYWxEZXZpY2VMb2dnZXInIGNhcGFiaWxpdHkgJyR7dGhpcy5yZWFsRGV2aWNlTG9nZ2VyfSc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIGRldmljZWNvbnNvbGUgPSB0aGlzLnJlYWxEZXZpY2VMb2dnZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXkndmUgcGFzc2VkIGluIGBkZXZpY2Vjb25zb2xlYCBhbmQgbm90IHNvbWV0aGluZyByYW5kb21cbiAgICAgICAgICBpZiAoIV8uZW5kc1dpdGgodGhpcy5yZWFsRGV2aWNlTG9nZ2VyLCAnZGV2aWNlY29uc29sZScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSAnZGV2aWNlY29uc29sZScgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeSBmcm9tICcke3RoaXMucmVhbERldmljZUxvZ2dlcn0nYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZXhlY3V0YWJsZSwgYW5kIHRyYWlsaW5nIGAvYCwgdG8gZ2V0IHRoZSBpbnN0YWxsIGRpcmVjdG9yeVxuICAgICAgICAgIGRldmljZWNvbnNvbGUgPSBwYXRoLmRpcm5hbWUodGhpcy5yZWFsRGV2aWNlTG9nZ2VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsb2dnZXIuZGVidWcoYFVzaW5nICdkZXZpY2Vjb25zb2xlJyBmcm9tICcke2RldmljZWNvbnNvbGV9J2ApO1xuXG4gICAgICBjbWQgPSBgJHtkZXZpY2Vjb25zb2xlfS9kZXZpY2Vjb25zb2xlYDtcbiAgICAgIGFyZ3MgPSBbJy11JywgdGhpcy51ZGlkXTtcblxuICAgICAgLy8gc2V0IHVwIHRoZSBlbnZpcm9ubWVudCB0byBiZSBhYmxlIHRvIHJ1biBkZXZpY2Vjb25zb2xlXG4gICAgICBlbnYgPSBfLmNsb25lKHByb2Nlc3MuZW52KTtcbiAgICAgIGVudi5EWUxEX0xJQlJBUllfUEFUSCA9IGRldmljZWNvbnNvbGU7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuRFlMRF9MSUJSQVJZX1BBVEgpIHtcbiAgICAgICAgZW52LkRZTERfTElCUkFSWV9QQVRIID0gYCR7ZW52LkRZTERfTElCUkFSWV9QQVRIfToke3Byb2Nlc3MuZW52LkRZTERfTElCUkFSWV9QQVRIfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KGBVbmFibGUgdG8gY2FwdHVyZSBkZXZpY2UgbG9nLiBVbmtub3duICdyZWFsRGV2aWNlTG9nZ2VyJzogJyR7dGhpcy5yZWFsRGV2aWNlTG9nZ2VyfSdgKTtcbiAgICB9XG5cbiAgICB0aGlzLnN1YnByb2Nlc3NJZCA9IGAke2NtZH1fJHt0aGlzLnVkaWR9YDtcblxuICAgIGxvZ2dlci5kZWJ1ZyhgU3RhcnRpbmcgaU9TIGRldmljZSBsb2cgY2FwdHVyZSB3aXRoOiAnJHtjbWR9J2ApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGNsZWFudXAgZXhpc3RpbmcgbGlzdGVuZXJzIGlmIHRoZSBwcmV2aW91cyBzZXNzaW9uIGhhcyBub3QgYmVlbiB0ZXJtaW5hdGVkIHByb3Blcmx5XG4gICAgICBhd2FpdCB0aGlzLmtpbGxFeGlzdGluZ1N5c0xvZ1Byb2Nlc3NlcyhjbWQsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBqdXN0IHVzZSBvbmUgaW5zdGFuY2Ugb2YgJ2lkZXZpY2VzeXNsb2cnIHBlciB1ZGlkXG4gICAgdGhpcy5wcm9jID0gdGhpcy5nZXRJRGV2aWNlU3lzTG9nUHJvY2VzcyhjbWQsIGFyZ3MsIGVudik7XG5cbiAgICBhd2FpdCB0aGlzLmZpbmlzaFN0YXJ0aW5nTG9nQ2FwdHVyZSgpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRDYXB0dXJlU2ltdWxhdG9yICgpIHtcbiAgICAvLyBvdGhlcndpc2UsIGlmIHdlIGhhdmUgYSBzaW11bGF0b3IuLi5cbiAgICBsb2dnZXIuZGVidWcoYFN0YXJ0aW5nIGlPUyAke2F3YWl0IHRoaXMuc2ltLmdldFBsYXRmb3JtVmVyc2lvbigpfSBzaW11bGF0b3IgbG9nIGNhcHR1cmVgKTtcbiAgICBpZiAodGhpcy54Y29kZVZlcnNpb24ubWFqb3IgPCA1KSB7XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2VzcygndGFpbCcsIFsnLWYnLCAnLW4nLCAnMScsIFNZU1RFTV9MT0dfUEFUSF0pO1xuICAgICAgYXdhaXQgdGhpcy5maW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIHhjb2RlIDYrXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5zaW0udWRpZCkpIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KGBpT1MgbG9nIGNhcHR1cmUgd2l0aCBYY29kZSAke3RoaXMueGNvZGVWZXJzaW9uLnZlcnNpb25TdHJpbmd9IHJlcXVpcmVzIGEgc2ltIHVkaWRgKTtcbiAgICB9XG5cbiAgICBsZXQgbG9nUGF0aCA9IHRoaXMuc2ltLmdldExvZ0RpcigpO1xuICAgIHRyeSB7XG4gICAgICBpZiAobG9nUGF0aC5pbmRleE9mKCcqJykgPj0gMCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYExvZyBwYXRoIGhhcyAqIGluIGl0LiBVbmFibGUgdG8gc3RhcnQgbG9nIGNhcHR1cmU6ICR7bG9nUGF0aH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN5c3RlbUxvZ1BhdGggPSBwYXRoLnJlc29sdmUobG9nUGF0aCwgJ3N5c3RlbS5sb2cnKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgU3lzdGVtIGxvZyBwYXRoOiAke3N5c3RlbUxvZ1BhdGh9YCk7XG4gICAgICBhd2FpdCBta2RpcnAobG9nUGF0aCk7XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUoc3lzdGVtTG9nUGF0aCwgJ0EgbmV3IEFwcGl1bSBzZXNzaW9uIGlzIGFib3V0IHRvIHN0YXJ0IVxcbicsIHtmbGFnOiAnYSd9KTtcbiAgICAgIGxldCBmaWxlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVzID0gYXdhaXQgZnMuZ2xvYihzeXN0ZW1Mb2dQYXRoKTtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBzdGFydCBsb2cgY2FwdHVyZScpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgQ291bGQgbm90IHN0YXJ0IGxvZyBjYXB0dXJlIGJlY2F1c2Ugbm8gaU9TIGAgK1xuICAgICAgICAgICAgICAgICAgICAgYHNpbXVsYXRvciBsb2dzIGNvdWxkIGJlIGZvdW5kIGF0ICR7c3lzdGVtTG9nUGF0aH0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgYExvZ2dpbmcgd2lsbCBub3QgYmUgZnVuY3Rpb25hbCBmb3IgdGhpcyBydW5gKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGxhc3RNb2RpZmllZExvZ1BhdGggPSBmaWxlc1swXTtcbiAgICAgIGxldCBsYXN0TW9kaWZpZWRMb2dUaW1lID0gKGF3YWl0IGZzLnN0YXQobGFzdE1vZGlmaWVkTG9nUGF0aCkpLm10aW1lO1xuICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICBsZXQge210aW1lfSA9IGF3YWl0IGZzLnN0YXQoZmlsZSk7XG4gICAgICAgIGlmIChtdGltZSA+IGxhc3RNb2RpZmllZExvZ1RpbWUpIHtcbiAgICAgICAgICBsYXN0TW9kaWZpZWRMb2dQYXRoID0gZmlsZTtcbiAgICAgICAgICBsYXN0TW9kaWZpZWRMb2dUaW1lID0gbXRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxBcmdzID0gWyctZicsICctbicsICcxJywgbGFzdE1vZGlmaWVkTG9nUGF0aF07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBjbGVhbnVwIGV4aXN0aW5nIGxpc3RlbmVycyBpZiB0aGUgcHJldmlvdXMgc2Vzc2lvbiBoYXMgbm90IGJlZW4gdGVybWluYXRlZCBwcm9wZXJseVxuICAgICAgICBhd2FpdCBleGVjKCdwa2lsbCcsIFsnLXhmJywgWyd0YWlsJywgLi4udGFpbEFyZ3NdLmpvaW4oJyAnKV0pO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKCd0YWlsJywgdGFpbEFyZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5maW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KGBTaW11bGF0b3IgbG9nIGNhcHR1cmUgZmFpbGVkOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FwdHVyZSAoKSB7XG4gICAgaWYgKHRoaXMudWRpZCkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBhIHJlYWwgZGV2aWNlXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdGFydENhcHR1cmVSZWFsRGV2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0Q2FwdHVyZVNpbXVsYXRvcigpO1xuICB9XG5cbiAgYXN5bmMgZmluaXNoU3RhcnRpbmdMb2dDYXB0dXJlICgpIHtcbiAgICBpZiAoIXRoaXMucHJvYykge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coJ0NvdWxkIG5vdCBjYXB0dXJlIGRldmljZSBsb2cnKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0TGluZSA9IHRydWU7XG4gICAgdGhpcy5wcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgaWYgKGZpcnN0TGluZSkge1xuICAgICAgICAgIGlmIChzdGRvdXQuc3Vic3RyKC0xLCAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHN0b3JlIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBsb2cgYmVjYXVzZSBpdCBjYW1lIGJlZm9yZSB0aGUgc2ltIG9yIGRldmljZSB3YXMgbGF1bmNoZWRcbiAgICAgICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ1JvdyArPSBzdGRvdXQ7XG4gICAgICAgICAgaWYgKHN0ZG91dC5zdWJzdHIoLTEsIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dCgpO1xuICAgICAgICAgICAgdGhpcy5sb2dSb3cgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgdGhpcy5vbk91dHB1dCgnU1RERVJSJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgc2QgPSAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGlmICgvZXhlY3ZwXFwoXFwpLy50ZXN0KHN0ZGVycikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpT1MgbG9nIGNhcHR1cmUgcHJvY2VzcyBmYWlsZWQgdG8gc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGRvdXQgfHwgc3RkZXJyO1xuICAgIH07XG4gICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KHNkLCBTVEFSVF9USU1FT1VUKTtcbiAgfVxuXG4gIGFzeW5jIHN0b3BDYXB0dXJlICgpIHtcbiAgICBpZiAodGhpcy5wcm9jKSB7XG4gICAgICBpZiAodGhpcy51ZGlkKSB7XG4gICAgICAgIC8vIElmIG5vIG90aGVyIFVESUQncyBhcmUgdXNpbmcgJ2lkZXZpY2VzeXNsb2cnIGtpbGwgaXRcbiAgICAgICAgY29uc3QgY2FjaGVkU3lzTG9nID0gSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXTtcbiAgICAgICAgY2FjaGVkU3lzTG9nLmNvdW50LS07XG4gICAgICAgIGlmIChjYWNoZWRTeXNMb2cuY291bnQgPT09IDApIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmtpbGxMb2dTdWJQcm9jZXNzKCk7XG4gICAgICAgICAgZGVsZXRlIElPU0xvZy5jYWNoZWRJRGV2aWNlU3lzTG9nc1t0aGlzLnN1YnByb2Nlc3NJZF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMua2lsbExvZ1N1YlByb2Nlc3MoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9jID0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGtpbGxMb2dTdWJQcm9jZXNzICgpIHtcbiAgICBpZiAodGhpcy5wcm9jLmlzUnVubmluZykge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdTdG9wcGluZyBpT1MgbG9nIGNhcHR1cmUnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvYy5zdG9wKCdTSUdURVJNJywgMTAwMCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignQ2Fubm90IHN0b3AgbG9nIGNhcHR1cmUgcHJvY2Vzcy4gU2VuZGluZyBTSUdLSUxMLi4uJyk7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvYy5zdG9wKCdTSUdLSUxMJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25PdXRwdXQgKHByZWZpeCA9ICcnKSB7XG4gICAgbGV0IGxvZ3MgPSB0aGlzLmxvZ1Jvdy5zcGxpdCgnXFxuJyk7XG4gICAgZm9yIChsZXQgbG9nIG9mIGxvZ3MpIHtcbiAgICAgIGlmICghbG9nKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjdXJseVxuICAgICAgbGV0IGxvZ09iaiA9IHtcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBsZXZlbDogJ0FMTCcsXG4gICAgICAgIG1lc3NhZ2U6IGxvZ1xuICAgICAgfTtcbiAgICAgIHRoaXMubG9ncy5wdXNoKGxvZ09iaik7XG4gICAgICBpZiAodGhpcy5sb2dzLmxlbmd0aCA+IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgICB0aGlzLmxvZ3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA+IDApIHtcbiAgICAgICAgICAtLXRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2hvd0xvZ3MpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gcHJlZml4Lmxlbmd0aCA+IDAgPyAnICcgOiAnJztcbiAgICAgICAgbG9nZ2VyLmluZm8oYFtJT1NfU1lTTE9HX1JPVyR7c3BhY2V9JHtwcmVmaXh9XSAke2xvZ31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRMb2dzICgpIHtcbiAgICBpZiAodGhpcy5sb2dzLmxlbmd0aCAmJiB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLmxvZ3MubGVuZ3RoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5sb2dzO1xuICAgICAgaWYgKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPSB0aGlzLmxvZ3MubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsTG9ncyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9ncztcbiAgfVxuXG4gIGFzeW5jIGtpbGxFeGlzdGluZ1N5c0xvZ1Byb2Nlc3NlcyAoY21kLCBhcmdzKSB7XG4gICAgaWYgKCFJT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3NbdGhpcy5zdWJwcm9jZXNzSWRdKSB7XG4gICAgICBhd2FpdCBleGVjKCdwa2lsbCcsIFsnLXhmJywgW2NtZCwgLi4uYXJnc10uam9pbignICcpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCAnaWRldmljZXN5c2xvZycgc3VicHJvY2VzcyBmb3IgYSBnaXZlbiB1ZGlkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyBhbmQgcmUtdXNlcyBpbnN0YW5jZXMgc28gdGhhdCB0aGVyZSdzXG4gICAqIGp1c3Qgb25lIGluc3RhbmNlIHBlciBkZXZpY2UgKGNhY2hlIGJ5IFVESUQpXG4gICAqL1xuICBnZXRJRGV2aWNlU3lzTG9nUHJvY2VzcyAoY21kLCBhcmdzLCBlbnYpIHtcbiAgICBpZiAoIUlPU0xvZy5jYWNoZWRJRGV2aWNlU3lzTG9nc1t0aGlzLnN1YnByb2Nlc3NJZF0pIHtcbiAgICAgIGxldCB7cHJvY30gPSBJT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3NbdGhpcy5zdWJwcm9jZXNzSWRdID0ge1xuICAgICAgICBwcm9jOiBuZXcgU3ViUHJvY2VzcyhjbWQsIGFyZ3MsIHtlbnZ9KSxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICB9O1xuICAgICAgLy8gSWYgdGhlIHByb2Nlc3MgZGllcywgcmVtb3ZlIGl0IGZyb20gdGhlIGNhY2hlXG4gICAgICBwcm9jLm9uKCdleGl0JywgKCkgPT4gZGVsZXRlIElPU0xvZy5jYWNoZWRJRGV2aWNlU3lzTG9nc1t0aGlzLnN1YnByb2Nlc3NJZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBJT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3NbdGhpcy5zdWJwcm9jZXNzSWRdLmNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBJT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3NbdGhpcy5zdWJwcm9jZXNzSWRdLnByb2M7XG4gIH1cbn1cblxuSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzID0ge307XG5cbmV4cG9ydCB7IElPU0xvZywgREVWSUNFX0NPTlNPTEVfUEFUSCB9O1xuZXhwb3J0IGRlZmF1bHQgSU9TTG9nO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
