'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _appiumXcode = require('appium-xcode');

var _nodeSimctl = require('node-simctl');

var _appiumSupport = require('appium-support');

var _certificate = require('./certificate');

var _touchEnroll = require('./touch-enroll');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _simulatorXcode6 = require('./simulator-xcode-6');

var _simulatorXcode62 = _interopRequireDefault(_simulatorXcode6);

var _fkill = require('fkill');

var _fkill2 = _interopRequireDefault(_fkill);

var DEFAULT_SIM_SHUTDOWN_TIMEOUT = 10000;

// pgrep/pkill exit codes:
// 0       One or more processes were matched.
// 1       No processes were matched.
// 2       Invalid options were specified on the command line.
// 3       An internal error occurred.

function pkill(appName) {
  var forceKill = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var args;
  return _regeneratorRuntime.async(function pkill$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = forceKill ? ['-9'] : [];

        args.push('-x', appName);
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', args));

      case 5:
        return context$1$0.abrupt('return', 0);

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](2);

        if (_lodash2['default'].isUndefined(context$1$0.t0.code)) {
          context$1$0.next = 12;
          break;
        }

        throw new Error('Cannot forcefully terminate ' + appName + '. pkill error code: ' + context$1$0.t0.code);

      case 12:
        _logger2['default'].error('Received unexpected error while trying to kill ' + appName + ': ' + context$1$0.t0.message);
        throw context$1$0.t0;

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 8]]);
}

function killAllSimulators() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_SIM_SHUTDOWN_TIMEOUT : arguments[0];

  var xcodeVersion, appName, pids, _ref, stdout, remainingDevices, allSimsAreDown, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, device;

  return _regeneratorRuntime.async(function killAllSimulators$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        allSimsAreDown = function allSimsAreDown() {
          var devices;
          return _regeneratorRuntime.async(function allSimsAreDown$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                remainingDevices = [];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

              case 3:
                devices = context$2$0.sent;

                devices = _lodash2['default'].flatten(_lodash2['default'].values(devices));
                return context$2$0.abrupt('return', _lodash2['default'].every(devices, function (sim) {
                  var state = sim.state.toLowerCase();
                  var done = state === 'shutdown' || state === 'unavailable' || state === 'disconnected';
                  if (!done) {
                    remainingDevices.push(sim.name + ' (' + sim.sdk + ', udid: ' + sim.udid + ') is still in state \'' + state + '\'');
                  }
                  return done;
                }));

              case 6:
              case 'end':
                return context$2$0.stop();
            }
          }, null, this);
        };

        _logger2['default'].debug('Killing all iOS Simulators');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _appiumXcode.getVersion)(true));

      case 4:
        xcodeVersion = context$1$0.sent;
        appName = xcodeVersion.major >= 7 ? 'Simulator' : 'iOS Simulator';

        // later versions are slower to close
        timeout = timeout * (xcodeVersion.major === 8 ? 2 : 1);

        // Restore default shortcut key to original state
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap((0, _touchEnroll.restoreTouchEnrollShortcuts)());

      case 9:
        pids = undefined;
        context$1$0.prev = 10;
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pgrep', ['-x', appName]));

      case 13:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;

        pids = stdout.trim().split('\n').map(function (pid) {
          return parseInt(pid, 10);
        });
        context$1$0.next = 24;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](10);

        if (!(context$1$0.t0.code === 1)) {
          context$1$0.next = 23;
          break;
        }

        _logger2['default'].debug(appName + ' is not running. Continuing...');
        return context$1$0.abrupt('return');

      case 23:
        _logger2['default'].warn('pgrep error ' + context$1$0.t0.code + ' while detecting whether ' + appName + ' is running. Trying to kill anyway.');

      case 24:
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap((function performKill() {
          var pids = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
          return _regeneratorRuntime.async(function performKill$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcrun', ['simctl', 'shutdown', 'booted'], { timeout: timeout }));

              case 3:
                context$2$0.next = 7;
                break;

              case 5:
                context$2$0.prev = 5;
                context$2$0.t0 = context$2$0['catch'](0);

              case 7:
                if (!pids.length) {
                  context$2$0.next = 13;
                  break;
                }

                _logger2['default'].debug('Using fkill to kill processes: ' + pids.join(', '));
                context$2$0.next = 11;
                return _regeneratorRuntime.awrap((0, _fkill2['default'])(pids, { force: true }));

              case 11:
                context$2$0.next = 16;
                break;

              case 13:
                _logger2['default'].debug('Using pkill to kill application: ' + appName);
                context$2$0.next = 16;
                return _regeneratorRuntime.awrap(pkill(appName, true));

              case 16:
              case 'end':
                return context$2$0.stop();
            }
          }, null, this, [[0, 5]]);
        })(pids));

      case 26:
        remainingDevices = [];
        context$1$0.prev = 27;
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(allSimsAreDown, {
          waitMs: timeout,
          intervalMs: 200
        }));

      case 30:
        context$1$0.next = 56;
        break;

      case 32:
        context$1$0.prev = 32;
        context$1$0.t1 = context$1$0['catch'](27);

        if (!(remainingDevices.length > 0)) {
          context$1$0.next = 55;
          break;
        }

        _logger2['default'].warn('The following devices are still not in the correct state after ' + timeout + ' ms:');
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 39;
        for (_iterator = _getIterator(remainingDevices); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          device = _step.value;

          _logger2['default'].warn('    ' + device);
        }
        context$1$0.next = 47;
        break;

      case 43:
        context$1$0.prev = 43;
        context$1$0.t2 = context$1$0['catch'](39);
        _didIteratorError = true;
        _iteratorError = context$1$0.t2;

      case 47:
        context$1$0.prev = 47;
        context$1$0.prev = 48;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 50:
        context$1$0.prev = 50;

        if (!_didIteratorError) {
          context$1$0.next = 53;
          break;
        }

        throw _iteratorError;

      case 53:
        return context$1$0.finish(50);

      case 54:
        return context$1$0.finish(47);

      case 55:
        throw context$1$0.t1;

      case 56:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[10, 18], [27, 32], [39, 43, 47, 55], [48,, 50, 54]]);
}

function endAllSimulatorDaemons() {
  var _arr, _i, servicePattern, launchCtlCommand, stopCmd, removeCmd;

  return _regeneratorRuntime.async(function endAllSimulatorDaemons$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Ending all simulator daemons');
        _arr = ['com.apple.iphonesimulator', 'com.apple.CoreSimulator'];
        _i = 0;

      case 3:
        if (!(_i < _arr.length)) {
          context$1$0.next = 28;
          break;
        }

        servicePattern = _arr[_i];

        _logger2['default'].debug('Killing any other ' + servicePattern + ' daemons');
        launchCtlCommand = 'launchctl list | grep ' + servicePattern + ' | cut -f 3 | xargs -n 1 launchctl';
        context$1$0.prev = 7;
        stopCmd = launchCtlCommand + ' stop';
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', stopCmd]));

      case 11:
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](7);

        _logger2['default'].warn('Could not stop ' + servicePattern + ' daemons, carrying on anyway!');

      case 16:
        context$1$0.prev = 16;
        removeCmd = launchCtlCommand + ' remove';
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', removeCmd]));

      case 20:
        context$1$0.next = 25;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t1 = context$1$0['catch'](16);

        _logger2['default'].warn('Could not remove ' + servicePattern + ' daemons, carrying on anyway!');

      case 25:
        _i++;
        context$1$0.next = 3;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          var _ref2, stdout;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', 'ps -e  | grep launchd_sim | grep -v bash | grep -v grep | awk {\'print$1\'}']));

              case 2:
                _ref2 = context$2$0.sent;
                stdout = _ref2.stdout;
                return context$2$0.abrupt('return', stdout.trim().length === 0);

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, { waitMs: 5000, intervalMs: 500 }));

      case 31:
        context$1$0.next = 36;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t2 = context$1$0['catch'](28);

        _logger2['default'].warn('Could not end all simulator daemons, carrying on!');

      case 36:
        _logger2['default'].debug('Finishing ending all simulator daemons');

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 13], [16, 22], [28, 33]]);
}

function simExists(udid) {
  var devices;
  return _regeneratorRuntime.async(function simExists$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

      case 2:
        devices = context$1$0.sent;

        devices = _lodash2['default'].toPairs(devices).map(function (pair) {
          return pair[1];
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
        return context$1$0.abrupt('return', !!_lodash2['default'].find(devices, function (sim) {
          return sim.udid === udid;
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function safeRimRaf(delPath) {
  var tryNum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
  return _regeneratorRuntime.async(function safeRimRaf$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(delPath));

      case 3:
        context$1$0.next = 16;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(tryNum < 20)) {
          context$1$0.next = 16;
          break;
        }

        if (!(context$1$0.t0.message.indexOf('ENOTEMPTY') !== -1)) {
          context$1$0.next = 13;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\' was not empty during delete; retrying');
        return context$1$0.abrupt('return', safeRimRaf(delPath, tryNum + 1));

      case 13:
        if (!(context$1$0.t0.message.indexOf('ENOENT') !== -1)) {
          context$1$0.next = 16;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\'\' did not exist when we tried to delete, ignoring');
        return context$1$0.abrupt('return', safeRimRaf(delPath, tryNum + 1));

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

function installSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function installSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('openssl'));

      case 3:
        context$1$0.next = 9;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('customSSLCert requires openssl to be available on path');
        _logger2['default'].errorAndThrow('Command \'openssl\' not found');

      case 9:
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('sqlite3'));

      case 12:
        context$1$0.next = 18;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t1 = context$1$0['catch'](9);

        _logger2['default'].debug('customSSLCert requires sqlite3 to be available on path');
        _logger2['default'].errorAndThrow('Command \'sqlite3\' not found');

      case 18:
        tempFileName = _path2['default'].resolve(__dirname + '/temp-ssl-cert.pem');
        pathToKeychain = _path2['default'].resolve(new _simulatorXcode62['default'](udid).getDir());
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 22:
        context$1$0.prev = 22;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(pathToKeychain));

      case 25:
        context$1$0.next = 31;
        break;

      case 27:
        context$1$0.prev = 27;
        context$1$0.t2 = context$1$0['catch'](22);

        _logger2['default'].debug('Could not install SSL certificate. No simulator with udid \'' + udid + '\'');
        _logger2['default'].errorAndThrow(context$1$0.t2);

      case 31:
        certificate = new _certificate.Certificate(tempFileName);

        _logger2['default'].debug('Installing certificate to ' + pathToKeychain);
        context$1$0.next = 35;
        return _regeneratorRuntime.awrap(certificate.add(pathToKeychain));

      case 35:
        context$1$0.next = 37;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 37:
        return context$1$0.abrupt('return', certificate);

      case 38:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5], [9, 14], [22, 27]]);
}

function uninstallSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function uninstallSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        tempFileName = _path2['default'].resolve(__dirname, 'temp-ssl-cert.pem');
        pathToKeychain = _path2['default'].resolve(new _simulatorXcode62['default'](udid).getDir());
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 5:
        certificate = new _certificate.Certificate(tempFileName);
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(certificate.remove(pathToKeychain));

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 10:
        return context$1$0.abrupt('return', certificate);

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('Could not uninstall SSL certificate. No simulator with udid \'' + udid + '\'');
        _logger2['default'].errorAndThrow(context$1$0.t0);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 13]]);
}

/**
 * Runs a command line sqlite3 query
 */
function execSQLiteQuery(db, query) {
  for (var _len = arguments.length, queryParams = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    queryParams[_key - 2] = arguments[_key];
  }

  var queryTokens, formattedQuery;
  return _regeneratorRuntime.async(function execSQLiteQuery$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        queryTokens = query.split('?');
        formattedQuery = [];

        queryParams.forEach(function (param, i) {
          formattedQuery.push(queryTokens[i]);
          formattedQuery.push(param.replace(/'/g, "''"));
        });
        formattedQuery.push(queryTokens[queryTokens.length - 1]);

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('sqlite3', ['-line', db, formattedQuery.join('')]));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

exports.killAllSimulators = killAllSimulators;
exports.endAllSimulatorDaemons = endAllSimulatorDaemons;
exports.safeRimRaf = safeRimRaf;
exports.simExists = simExists;
exports.installSSLCert = installSSLCert;
exports.uninstallSSLCert = uninstallSSLCert;
exports.execSQLiteQuery = execSQLiteQuery;

// wait for all the devices to be shutdown before Continuing
// but only print out the failed ones when they are actually fully failed

// waiting until the simulator service has died.

// see the README for github.com/appium/node-simctl for example output of getDevices()

// Check that openssl is installed on the path

// Check that sqlite3 is installed on the path
//# sourceMappingURL=data:application/json;charset=utf8;base64,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O0FBRWxCLDRCQUFJLEtBQUssb0VBQWlFLElBQUksUUFBSSxDQUFDO0FBQ25GLDRCQUFJLGFBQWEsZ0JBQUcsQ0FBQzs7Ozs7OztDQUV4Qjs7Ozs7QUFLRCxTQUFlLGVBQWUsQ0FBRSxFQUFFLEVBQUUsS0FBSztvQ0FBSyxXQUFXO0FBQVgsZUFBVzs7O01BQ25ELFdBQVcsRUFDWCxjQUFjOzs7O0FBRGQsbUJBQVcsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztBQUM5QixzQkFBYyxHQUFHLEVBQUU7O0FBQ3ZCLG1CQUFXLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBSyxFQUFFLENBQUMsRUFBSztBQUNoQyx3QkFBYyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQyx3QkFBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ2hELENBQUMsQ0FBQztBQUNILHNCQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozt5Q0FFNUMsd0JBQUssU0FBUyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Q0FDckU7O1FBRVEsaUJBQWlCLEdBQWpCLGlCQUFpQjtRQUFFLHNCQUFzQixHQUF0QixzQkFBc0I7UUFBRSxVQUFVLEdBQVYsVUFBVTtRQUFFLFNBQVMsR0FBVCxTQUFTO1FBQUUsY0FBYyxHQUFkLGNBQWM7UUFBRSxnQkFBZ0IsR0FBaEIsZ0JBQWdCO1FBQUUsZUFBZSxHQUFmLGVBQWUiLCJmaWxlIjoibGliL3V0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJ2FwcGl1bS14Y29kZSc7XG5pbXBvcnQgeyBnZXREZXZpY2VzIH0gZnJvbSAnbm9kZS1zaW1jdGwnO1xuaW1wb3J0IHsgZnMgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZSB9IGZyb20gJy4vY2VydGlmaWNhdGUnO1xuaW1wb3J0IHsgcmVzdG9yZVRvdWNoRW5yb2xsU2hvcnRjdXRzIH0gZnJvbSAnLi90b3VjaC1lbnJvbGwnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgU2ltdWxhdG9yIGZyb20gJy4vc2ltdWxhdG9yLXhjb2RlLTYnO1xuaW1wb3J0IGZraWxsIGZyb20gJ2ZraWxsJztcblxuXG5jb25zdCBERUZBVUxUX1NJTV9TSFVURE9XTl9USU1FT1VUID0gMTAwMDA7XG5cbi8vIHBncmVwL3BraWxsIGV4aXQgY29kZXM6XG4vLyAwICAgICAgIE9uZSBvciBtb3JlIHByb2Nlc3NlcyB3ZXJlIG1hdGNoZWQuXG4vLyAxICAgICAgIE5vIHByb2Nlc3NlcyB3ZXJlIG1hdGNoZWQuXG4vLyAyICAgICAgIEludmFsaWQgb3B0aW9ucyB3ZXJlIHNwZWNpZmllZCBvbiB0aGUgY29tbWFuZCBsaW5lLlxuLy8gMyAgICAgICBBbiBpbnRlcm5hbCBlcnJvciBvY2N1cnJlZC5cblxuYXN5bmMgZnVuY3Rpb24gcGtpbGwgKGFwcE5hbWUsIGZvcmNlS2lsbCA9IGZhbHNlKSB7XG4gIGxldCBhcmdzID0gZm9yY2VLaWxsID8gWyctOSddIDogW107XG4gIGFyZ3MucHVzaCgnLXgnLCBhcHBOYW1lKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKCdwa2lsbCcsIGFyZ3MpO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZXJyLmNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmb3JjZWZ1bGx5IHRlcm1pbmF0ZSAke2FwcE5hbWV9LiBwa2lsbCBlcnJvciBjb2RlOiAke2Vyci5jb2RlfWApO1xuICAgIH1cbiAgICBsb2cuZXJyb3IoYFJlY2VpdmVkIHVuZXhwZWN0ZWQgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGtpbGwgJHthcHBOYW1lfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24ga2lsbEFsbFNpbXVsYXRvcnMgKHRpbWVvdXQgPSBERUZBVUxUX1NJTV9TSFVURE9XTl9USU1FT1VUKSB7XG4gIGxvZy5kZWJ1ZygnS2lsbGluZyBhbGwgaU9TIFNpbXVsYXRvcnMnKTtcbiAgY29uc3QgeGNvZGVWZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbih0cnVlKTtcbiAgY29uc3QgYXBwTmFtZSA9IHhjb2RlVmVyc2lvbi5tYWpvciA+PSA3ID8gJ1NpbXVsYXRvcicgOiAnaU9TIFNpbXVsYXRvcic7XG5cbiAgLy8gbGF0ZXIgdmVyc2lvbnMgYXJlIHNsb3dlciB0byBjbG9zZVxuICB0aW1lb3V0ID0gdGltZW91dCAqICh4Y29kZVZlcnNpb24ubWFqb3IgPT09IDggPyAyIDogMSk7XG5cbiAgLy8gUmVzdG9yZSBkZWZhdWx0IHNob3J0Y3V0IGtleSB0byBvcmlnaW5hbCBzdGF0ZVxuICBhd2FpdCByZXN0b3JlVG91Y2hFbnJvbGxTaG9ydGN1dHMoKTtcblxuICBsZXQgcGlkcztcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdwZ3JlcCcsIFsnLXgnLCBhcHBOYW1lXSk7XG4gICAgcGlkcyA9IHN0ZG91dC50cmltKCkuc3BsaXQoJ1xcbicpLm1hcCgocGlkKSA9PiBwYXJzZUludChwaWQsIDEwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlID09PSAxKSB7XG4gICAgICBsb2cuZGVidWcoYCR7YXBwTmFtZX0gaXMgbm90IHJ1bm5pbmcuIENvbnRpbnVpbmcuLi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nLndhcm4oYHBncmVwIGVycm9yICR7ZS5jb2RlfSB3aGlsZSBkZXRlY3Rpbmcgd2hldGhlciAke2FwcE5hbWV9IGlzIHJ1bm5pbmcuIFRyeWluZyB0byBraWxsIGFueXdheS5gKTtcbiAgfVxuXG4gIGF3YWl0IChhc3luYyBmdW5jdGlvbiBwZXJmb3JtS2lsbCAocGlkcyA9IFtdKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWMoJ3hjcnVuJywgWydzaW1jdGwnLCAnc2h1dGRvd24nLCAnYm9vdGVkJ10sIHt0aW1lb3V0fSk7XG4gICAgfSBjYXRjaCAoaWduKSB7fVxuXG4gICAgaWYgKHBpZHMubGVuZ3RoKSB7XG4gICAgICBsb2cuZGVidWcoYFVzaW5nIGZraWxsIHRvIGtpbGwgcHJvY2Vzc2VzOiAke3BpZHMuam9pbignLCAnKX1gKTtcbiAgICAgIGF3YWl0IGZraWxsKHBpZHMsIHtmb3JjZTogdHJ1ZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuZGVidWcoYFVzaW5nIHBraWxsIHRvIGtpbGwgYXBwbGljYXRpb246ICR7YXBwTmFtZX1gKTtcbiAgICAgIGF3YWl0IHBraWxsKGFwcE5hbWUsIHRydWUpO1xuICAgIH1cbiAgfSkocGlkcyk7XG5cbiAgLy8gd2FpdCBmb3IgYWxsIHRoZSBkZXZpY2VzIHRvIGJlIHNodXRkb3duIGJlZm9yZSBDb250aW51aW5nXG4gIC8vIGJ1dCBvbmx5IHByaW50IG91dCB0aGUgZmFpbGVkIG9uZXMgd2hlbiB0aGV5IGFyZSBhY3R1YWxseSBmdWxseSBmYWlsZWRcbiAgbGV0IHJlbWFpbmluZ0RldmljZXMgPSBbXTtcbiAgYXN5bmMgZnVuY3Rpb24gYWxsU2ltc0FyZURvd24gKCkge1xuICAgIHJlbWFpbmluZ0RldmljZXMgPSBbXTtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXMoKTtcbiAgICBkZXZpY2VzID0gXy5mbGF0dGVuKF8udmFsdWVzKGRldmljZXMpKTtcbiAgICByZXR1cm4gXy5ldmVyeShkZXZpY2VzLCAoc2ltKSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBzaW0uc3RhdGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGxldCBkb25lID0gc3RhdGUgPT09ICdzaHV0ZG93bicgfHxcbiAgICAgICAgICAgICAgICAgc3RhdGUgPT09ICd1bmF2YWlsYWJsZScgfHxcbiAgICAgICAgICAgICAgICAgc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgIHJlbWFpbmluZ0RldmljZXMucHVzaChgJHtzaW0ubmFtZX0gKCR7c2ltLnNka30sIHVkaWQ6ICR7c2ltLnVkaWR9KSBpcyBzdGlsbCBpbiBzdGF0ZSAnJHtzdGF0ZX0nYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9uZTtcbiAgICB9KTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYWxsU2ltc0FyZURvd24sIHtcbiAgICAgIHdhaXRNczogdGltZW91dCxcbiAgICAgIGludGVydmFsTXM6IDIwMFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAocmVtYWluaW5nRGV2aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2cud2FybihgVGhlIGZvbGxvd2luZyBkZXZpY2VzIGFyZSBzdGlsbCBub3QgaW4gdGhlIGNvcnJlY3Qgc3RhdGUgYWZ0ZXIgJHt0aW1lb3V0fSBtczpgKTtcbiAgICAgIGZvciAobGV0IGRldmljZSBvZiByZW1haW5pbmdEZXZpY2VzKSB7XG4gICAgICAgIGxvZy53YXJuKGAgICAgJHtkZXZpY2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBlbmRBbGxTaW11bGF0b3JEYWVtb25zICgpIHtcbiAgbG9nLmRlYnVnKCdFbmRpbmcgYWxsIHNpbXVsYXRvciBkYWVtb25zJyk7XG4gIGZvciAobGV0IHNlcnZpY2VQYXR0ZXJuIG9mIFsnY29tLmFwcGxlLmlwaG9uZXNpbXVsYXRvcicsICdjb20uYXBwbGUuQ29yZVNpbXVsYXRvciddKSB7XG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIGFueSBvdGhlciAke3NlcnZpY2VQYXR0ZXJufSBkYWVtb25zYCk7XG4gICAgbGV0IGxhdW5jaEN0bENvbW1hbmQgPSBgbGF1bmNoY3RsIGxpc3QgfCBncmVwICR7c2VydmljZVBhdHRlcm59IHwgY3V0IC1mIDMgfCB4YXJncyAtbiAxIGxhdW5jaGN0bGA7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBzdG9wQ21kID0gYCR7bGF1bmNoQ3RsQ29tbWFuZH0gc3RvcGA7XG4gICAgICBhd2FpdCBleGVjKCdiYXNoJywgWyctYycsIHN0b3BDbWRdKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBDb3VsZCBub3Qgc3RvcCAke3NlcnZpY2VQYXR0ZXJufSBkYWVtb25zLCBjYXJyeWluZyBvbiBhbnl3YXkhYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVtb3ZlQ21kID0gYCR7bGF1bmNoQ3RsQ29tbWFuZH0gcmVtb3ZlYDtcbiAgICAgIGF3YWl0IGV4ZWMoJ2Jhc2gnLCBbJy1jJywgcmVtb3ZlQ21kXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgQ291bGQgbm90IHJlbW92ZSAke3NlcnZpY2VQYXR0ZXJufSBkYWVtb25zLCBjYXJyeWluZyBvbiBhbnl3YXkhYCk7XG4gICAgfVxuICB9XG4gIC8vIHdhaXRpbmcgdW50aWwgdGhlIHNpbXVsYXRvciBzZXJ2aWNlIGhhcyBkaWVkLlxuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLFxuICAgICAgICBgcHMgLWUgIHwgZ3JlcCBsYXVuY2hkX3NpbSB8IGdyZXAgLXYgYmFzaCB8IGdyZXAgLXYgZ3JlcCB8IGF3ayB7J3ByaW50JDEnfWBdKTtcbiAgICAgIHJldHVybiBzdGRvdXQudHJpbSgpLmxlbmd0aCA9PT0gMDtcbiAgICB9LCB7d2FpdE1zOiA1MDAwLCBpbnRlcnZhbE1zOiA1MDB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYENvdWxkIG5vdCBlbmQgYWxsIHNpbXVsYXRvciBkYWVtb25zLCBjYXJyeWluZyBvbiFgKTtcbiAgfVxuICBsb2cuZGVidWcoJ0ZpbmlzaGluZyBlbmRpbmcgYWxsIHNpbXVsYXRvciBkYWVtb25zJyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNpbUV4aXN0cyAodWRpZCkge1xuICAvLyBzZWUgdGhlIFJFQURNRSBmb3IgZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS1zaW1jdGwgZm9yIGV4YW1wbGUgb3V0cHV0IG9mIGdldERldmljZXMoKVxuICBsZXQgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXMoKTtcblxuICBkZXZpY2VzID0gXy50b1BhaXJzKGRldmljZXMpLm1hcCgocGFpcikgPT4ge1xuICAgIHJldHVybiBwYWlyWzFdO1xuICB9KS5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH0sIFtdKTtcbiAgcmV0dXJuICEhXy5maW5kKGRldmljZXMsIChzaW0pID0+IHtcbiAgICByZXR1cm4gc2ltLnVkaWQgPT09IHVkaWQ7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzYWZlUmltUmFmIChkZWxQYXRoLCB0cnlOdW0gPSAwKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMucmltcmFmKGRlbFBhdGgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHJ5TnVtIDwgMjApIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdFTk9URU1QVFknKSAhPT0gLTEpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBQYXRoICcke2RlbFBhdGh9JyB3YXMgbm90IGVtcHR5IGR1cmluZyBkZWxldGU7IHJldHJ5aW5nYCk7XG4gICAgICAgIHJldHVybiBzYWZlUmltUmFmKGRlbFBhdGgsIHRyeU51bSArIDEpO1xuICAgICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdFTk9FTlQnKSAhPT0gLTEpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBQYXRoICcke2RlbFBhdGh9JycgZGlkIG5vdCBleGlzdCB3aGVuIHdlIHRyaWVkIHRvIGRlbGV0ZSwgaWdub3JpbmdgKTtcbiAgICAgICAgcmV0dXJuIHNhZmVSaW1SYWYoZGVsUGF0aCwgdHJ5TnVtICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbGxTU0xDZXJ0IChwZW1UZXh0LCB1ZGlkKSB7XG4gIC8vIENoZWNrIHRoYXQgb3BlbnNzbCBpcyBpbnN0YWxsZWQgb24gdGhlIHBhdGhcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53aGljaCgnb3BlbnNzbCcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBjdXN0b21TU0xDZXJ0IHJlcXVpcmVzIG9wZW5zc2wgdG8gYmUgYXZhaWxhYmxlIG9uIHBhdGhgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ29tbWFuZCAnb3BlbnNzbCcgbm90IGZvdW5kYCk7XG4gIH1cblxuICAvLyBDaGVjayB0aGF0IHNxbGl0ZTMgaXMgaW5zdGFsbGVkIG9uIHRoZSBwYXRoXG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud2hpY2goJ3NxbGl0ZTMnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhgY3VzdG9tU1NMQ2VydCByZXF1aXJlcyBzcWxpdGUzIHRvIGJlIGF2YWlsYWJsZSBvbiBwYXRoYCk7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvbW1hbmQgJ3NxbGl0ZTMnIG5vdCBmb3VuZGApO1xuICB9XG5cbiAgbGV0IHRlbXBGaWxlTmFtZSA9IHBhdGgucmVzb2x2ZShgJHtfX2Rpcm5hbWV9L3RlbXAtc3NsLWNlcnQucGVtYCk7XG4gIGxldCBwYXRoVG9LZXljaGFpbiA9IHBhdGgucmVzb2x2ZShuZXcgU2ltdWxhdG9yKHVkaWQpLmdldERpcigpKTtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBGaWxlTmFtZSwgcGVtVGV4dCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMuc3RhdChwYXRoVG9LZXljaGFpbik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZGVidWcoYENvdWxkIG5vdCBpbnN0YWxsIFNTTCBjZXJ0aWZpY2F0ZS4gTm8gc2ltdWxhdG9yIHdpdGggdWRpZCAnJHt1ZGlkfSdgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgfVxuICBsZXQgY2VydGlmaWNhdGUgPSBuZXcgQ2VydGlmaWNhdGUodGVtcEZpbGVOYW1lKTtcbiAgbG9nLmRlYnVnKGBJbnN0YWxsaW5nIGNlcnRpZmljYXRlIHRvICR7cGF0aFRvS2V5Y2hhaW59YCk7XG4gIGF3YWl0IGNlcnRpZmljYXRlLmFkZChwYXRoVG9LZXljaGFpbik7XG4gIGF3YWl0IGZzLnVubGluayh0ZW1wRmlsZU5hbWUpO1xuICByZXR1cm4gY2VydGlmaWNhdGU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVuaW5zdGFsbFNTTENlcnQgKHBlbVRleHQsIHVkaWQpIHtcbiAgdHJ5IHtcbiAgICBsZXQgdGVtcEZpbGVOYW1lID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJ3RlbXAtc3NsLWNlcnQucGVtJyk7XG4gICAgbGV0IHBhdGhUb0tleWNoYWluID0gcGF0aC5yZXNvbHZlKG5ldyBTaW11bGF0b3IodWRpZCkuZ2V0RGlyKCkpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0ZW1wRmlsZU5hbWUsIHBlbVRleHQpO1xuICAgIGxldCBjZXJ0aWZpY2F0ZSA9IG5ldyBDZXJ0aWZpY2F0ZSh0ZW1wRmlsZU5hbWUpO1xuICAgIGF3YWl0IGNlcnRpZmljYXRlLnJlbW92ZShwYXRoVG9LZXljaGFpbik7XG4gICAgYXdhaXQgZnMudW5saW5rKHRlbXBGaWxlTmFtZSk7XG4gICAgcmV0dXJuIGNlcnRpZmljYXRlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBDb3VsZCBub3QgdW5pbnN0YWxsIFNTTCBjZXJ0aWZpY2F0ZS4gTm8gc2ltdWxhdG9yIHdpdGggdWRpZCAnJHt1ZGlkfSdgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgYSBjb21tYW5kIGxpbmUgc3FsaXRlMyBxdWVyeVxuICovXG5hc3luYyBmdW5jdGlvbiBleGVjU1FMaXRlUXVlcnkgKGRiLCBxdWVyeSwgLi4ucXVlcnlQYXJhbXMpIHtcbiAgbGV0IHF1ZXJ5VG9rZW5zID0gcXVlcnkuc3BsaXQoJz8nKTtcbiAgbGV0IGZvcm1hdHRlZFF1ZXJ5ID0gW107XG4gIHF1ZXJ5UGFyYW1zLmZvckVhY2goKHBhcmFtLCBpKSA9PiB7XG4gICAgZm9ybWF0dGVkUXVlcnkucHVzaChxdWVyeVRva2Vuc1tpXSk7XG4gICAgZm9ybWF0dGVkUXVlcnkucHVzaChwYXJhbS5yZXBsYWNlKC8nL2csIFwiJydcIikpO1xuICB9KTtcbiAgZm9ybWF0dGVkUXVlcnkucHVzaChxdWVyeVRva2Vuc1txdWVyeVRva2Vucy5sZW5ndGggLSAxXSk7XG5cbiAgcmV0dXJuIGF3YWl0IGV4ZWMoJ3NxbGl0ZTMnLCBbJy1saW5lJywgZGIsIGZvcm1hdHRlZFF1ZXJ5LmpvaW4oJycpXSk7XG59XG5cbmV4cG9ydCB7IGtpbGxBbGxTaW11bGF0b3JzLCBlbmRBbGxTaW11bGF0b3JEYWVtb25zLCBzYWZlUmltUmFmLCBzaW1FeGlzdHMsIGluc3RhbGxTU0xDZXJ0LCB1bmluc3RhbGxTU0xDZXJ0LCBleGVjU1FMaXRlUXVlcnkgfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
