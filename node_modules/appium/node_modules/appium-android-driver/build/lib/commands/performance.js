'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Number$isNaN = require('babel-runtime/core-js/number/is-nan')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _asyncbox = require('asyncbox');

var commands = {},
    helpers = {},
    extensions = {};

var NETWORK_KEYS = [['bucketStart', 'activeTime', 'rxBytes', 'rxPackets', 'txBytes', 'txPackets', 'operations', 'bucketDuration'], ['st', 'activeTime', 'rb', 'rp', 'tb', 'tp', 'op', 'bucketDuration']];
var CPU_KEYS = ['user', 'kernel'];
var BATTERY_KEYS = ['power'];
var MEMORY_KEYS = ['totalPrivateDirty', 'nativePrivateDirty', 'dalvikPrivateDirty', 'eglPrivateDirty', 'glPrivateDirty', 'totalPss', 'nativePss', 'dalvikPss', 'eglPss', 'glPss', 'nativeHeapAllocatedSize', 'nativeHeapSize'];

var SUPPORTED_PERFORMANCE_DATA_TYPES = {
  cpuinfo: 'the amount of cpu by user and kernel process - cpu information for applications on real devices and simulators',
  memoryinfo: 'the amount of memory used by the process - memory information for applications on real devices and simulators',
  batteryinfo: 'the remaining battery power - battery power information for applications on real devices and simulators',
  networkinfo: 'the network statistics - network rx/tx information for applications on real devices and simulators'
};

var RETRY_PAUSE = 1000;

//
// returns the information type of the system state which is supported to read as like cpu, memory, network traffic, and battery.
// output - array like below
//[cpuinfo, batteryinfo, networkinfo, memoryinfo]
//
commands.getPerformanceDataTypes = function () {
  return _lodash2['default'].keys(SUPPORTED_PERFORMANCE_DATA_TYPES);
};

// returns the information type of the system state which is supported to read as like cpu, memory, network traffic, and battery.
//input - (packageName) the package name of the application
//        (dataType) the type of system state which wants to read. It should be one of the keys of the SUPPORTED_PERFORMANCE_DATA_TYPES
//        (dataReadTimeout) the number of attempts to read
// output - table of the performance data, The first line of the table represents the type of data. The remaining lines represent the values of the data.
//
// in case of battery info : [[power], [23]]
// in case of memory info :  [[totalPrivateDirty, nativePrivateDirty, dalvikPrivateDirty, eglPrivateDirty, glPrivateDirty, totalPss, nativePss, dalvikPss, eglPss, glPss, nativeHeapAllocatedSize, nativeHeapSize], [18360, 8296, 6132, null, null, 42588, 8406, 7024, null, null, 26519, 10344]]
// in case of network info : [[bucketStart, activeTime, rxBytes, rxPackets, txBytes, txPackets, operations, bucketDuration,], [1478091600000, null, 1099075, 610947, 928, 114362, 769, 0, 3600000], [1478095200000, null, 1306300, 405997, 509, 46359, 370, 0, 3600000]]
// in case of network info : [[st, activeTime, rb, rp, tb, tp, op, bucketDuration], [1478088000, null, null, 32115296, 34291, 2956805, 25705, 0, 3600], [1478091600, null, null, 2714683, 11821, 1420564, 12650, 0, 3600], [1478095200, null, null, 10079213, 19962, 2487705, 20015, 0, 3600], [1478098800, null, null, 4444433, 10227, 1430356, 10493, 0, 3600]]
// in case of cpu info : [[user, kernel], [0.9, 1.3]]
//
commands.getPerformanceData = function callee$0$0(packageName, dataType) {
  var dataReadTimeout = arguments.length <= 2 || arguments[2] === undefined ? 2 : arguments[2];
  var data;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        data = undefined;
        context$1$0.t0 = dataType;
        context$1$0.next = context$1$0.t0 === 'batteryinfo' ? 4 : context$1$0.t0 === 'cpuinfo' ? 8 : context$1$0.t0 === 'memoryinfo' ? 12 : context$1$0.t0 === 'networkinfo' ? 16 : 20;
        break;

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getBatteryInfo(dataReadTimeout));

      case 6:
        data = context$1$0.sent;
        return context$1$0.abrupt('break', 21);

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.getCPUInfo(packageName, dataReadTimeout));

      case 10:
        data = context$1$0.sent;
        return context$1$0.abrupt('break', 21);

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(this.getMemoryInfo(packageName, dataReadTimeout));

      case 14:
        data = context$1$0.sent;
        return context$1$0.abrupt('break', 21);

      case 16:
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(this.getNetworkTrafficInfo(dataReadTimeout));

      case 18:
        data = context$1$0.sent;
        return context$1$0.abrupt('break', 21);

      case 20:
        throw new Error('No performance data of type \'' + dataType + '\' found.');

      case 21:
        return context$1$0.abrupt('return', data);

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getCPUInfo = function callee$0$0(packageName) {
  var dataReadTimeout = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(dataReadTimeout, RETRY_PAUSE, function callee$1$0() {
          var cmd, data, userMatch, kernelMatch;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                cmd = ['dumpsys', 'cpuinfo', '|', 'grep', '\'' + packageName + '\''];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adb.shell(cmd));

              case 3:
                data = context$2$0.sent;

                if (!_lodash2['default'].isEmpty(data)) {
                  context$2$0.next = 6;
                  break;
                }

                throw new Error('No data from dumpsys');

              case 6:
                userMatch = /([\d\.]+)%\s+user/.exec(data);
                kernelMatch = /([\d\.]+)%\s+kernel/.exec(data);

                if (!(!userMatch || !kernelMatch)) {
                  context$2$0.next = 10;
                  break;
                }

                throw new Error('Unable to parse cpu data: \'' + data + '\'');

              case 10:
                return context$2$0.abrupt('return', [_lodash2['default'].clone(CPU_KEYS), [userMatch[1], kernelMatch[1]]]);

              case 11:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getBatteryInfo = function callee$0$0() {
  var dataReadTimeout = arguments.length <= 0 || arguments[0] === undefined ? 2 : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(dataReadTimeout, RETRY_PAUSE, function callee$1$0() {
          var cmd, data, power;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                cmd = ['dumpsys', 'battery', '|', 'grep', 'level'];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adb.shell(cmd));

              case 3:
                data = context$2$0.sent;

                if (data) {
                  context$2$0.next = 6;
                  break;
                }

                throw new Error('No data from dumpsys');

              case 6:
                power = parseInt((data.split(':')[1] || '').trim(), 10);

                if (_Number$isNaN(power)) {
                  context$2$0.next = 11;
                  break;
                }

                return context$2$0.abrupt('return', [_lodash2['default'].clone(BATTERY_KEYS), [power.toString()]]);

              case 11:
                throw new Error('Unable to parse battery data: \'' + data + '\'');

              case 12:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getMemoryInfo = function callee$0$0(packageName) {
  var dataReadTimeout = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(dataReadTimeout, RETRY_PAUSE, function callee$1$0() {
          var cmd, data, totalPrivateDirty, totalPss, nativePrivateDirty, nativePss, nativeHeapSize, nativeHeapAllocatedSize, dalvikPrivateDirty, dalvikPss, eglPrivateDirty, eglPss, glPrivateDirty, glPss, apilevel, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, entries, type, subType, headers, _data;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                cmd = ['dumpsys', 'meminfo', '\'' + packageName + '\'', '|', 'grep', '-E', "'Native|Dalvik|EGL|GL|TOTAL'"];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adb.shell(cmd));

              case 3:
                data = context$2$0.sent;

                if (data) {
                  context$2$0.next = 6;
                  break;
                }

                throw new Error('No data from dumpsys');

              case 6:
                totalPrivateDirty = undefined, totalPss = undefined, nativePrivateDirty = undefined, nativePss = undefined, nativeHeapSize = undefined, nativeHeapAllocatedSize = undefined, dalvikPrivateDirty = undefined, dalvikPss = undefined, eglPrivateDirty = undefined, eglPss = undefined, glPrivateDirty = undefined, glPss = undefined;
                context$2$0.next = 9;
                return _regeneratorRuntime.awrap(this.adb.getApiLevel());

              case 9:
                apilevel = context$2$0.sent;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$2$0.prev = 13;

                for (_iterator = _getIterator(data.split('\n')); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  line = _step.value;
                  entries = line.trim().split(' ').filter(Boolean);

                  // entries will have the values
                  //   ['<System Type>', '<Memory Type>', <pss total>, <private dirty>, <private clean>, <swapPss dirty>, <heap size>, <heap alloc>, <heap free>]
                  // except 'TOTAL', which skips the second type name
                  //
                  // and on API level 18 and below
                  //   ['<System Type', '<pps>', '<shared dirty>', '<private dirty>', '<heap size>', '<heap alloc>', '<heap free>']

                  if (apilevel > 18) {
                    type = entries[0];
                    subType = entries[1];

                    if (type === 'Native' && subType === 'Heap') {
                      // native heap
                      nativePss = entries[2];
                      nativePrivateDirty = entries[3];
                      nativeHeapSize = entries[6];
                      nativeHeapAllocatedSize = entries[7];
                    } else if (type === 'Dalvik' && subType === 'Heap') {
                      // dalvik heap
                      dalvikPss = entries[2];
                      dalvikPrivateDirty = entries[3];
                    } else if (type === 'EGL' && subType === 'mtrack') {
                      // egl
                      eglPss = entries[2];
                      eglPrivateDirty = entries[3];
                    } else if (type === 'GL' && subType === 'mtrack') {
                      // gl
                      glPss = entries[2];
                      glPrivateDirty = entries[3];
                    } else if (type === 'TOTAL' && entries.length === 8) {
                      // there are two totals, and we only want the full listing, which has 8 entries
                      totalPss = entries[1];
                      totalPrivateDirty = entries[2];
                    }
                  } else {
                    type = entries[0];

                    if (type === 'Native') {
                      nativePss = entries[1];
                      nativePrivateDirty = entries[3];
                      nativeHeapSize = entries[4];
                      nativeHeapAllocatedSize = entries[5];
                    } else if (type === 'Dalvik') {
                      dalvikPss = entries[1];
                      dalvikPrivateDirty = entries[3];
                    } else if (type === 'EGL') {
                      eglPss = entries[1];
                      eglPrivateDirty = entries[3];
                    } else if (type === 'GL') {
                      glPss = entries[1];
                      glPrivateDirty = entries[3];
                    } else if (type === 'TOTAL') {
                      totalPss = entries[1];
                      totalPrivateDirty = entries[3];
                    }
                  }
                }

                context$2$0.next = 21;
                break;

              case 17:
                context$2$0.prev = 17;
                context$2$0.t0 = context$2$0['catch'](13);
                _didIteratorError = true;
                _iteratorError = context$2$0.t0;

              case 21:
                context$2$0.prev = 21;
                context$2$0.prev = 22;

                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }

              case 24:
                context$2$0.prev = 24;

                if (!_didIteratorError) {
                  context$2$0.next = 27;
                  break;
                }

                throw _iteratorError;

              case 27:
                return context$2$0.finish(24);

              case 28:
                return context$2$0.finish(21);

              case 29:
                if (!(totalPrivateDirty && totalPrivateDirty !== 'nodex')) {
                  context$2$0.next = 35;
                  break;
                }

                headers = _lodash2['default'].clone(MEMORY_KEYS);
                _data = [totalPrivateDirty, nativePrivateDirty, dalvikPrivateDirty, eglPrivateDirty, glPrivateDirty, totalPss, nativePss, dalvikPss, eglPss, glPss, nativeHeapAllocatedSize, nativeHeapSize];
                return context$2$0.abrupt('return', [headers, _data]);

              case 35:
                throw new Error('Unable to parse memory data: \'' + data + '\'');

              case 36:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[13, 17, 21, 29], [22,, 24, 28]]);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getNetworkTrafficInfo = function callee$0$0() {
  var dataReadTimeout = arguments.length <= 0 || arguments[0] === undefined ? 2 : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(dataReadTimeout, RETRY_PAUSE, function callee$1$0() {
          var returnValue, bucketDuration, bucketStart, activeTime, rxBytes, rxPackets, txBytes, txPackets, operations, cmd, data, index, fromXtstats, start, delimiter, end, pendingBytes, arrayList, j, k, returnIndex, i;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                returnValue = [];
                bucketDuration = undefined, bucketStart = undefined, activeTime = undefined, rxBytes = undefined, rxPackets = undefined, txBytes = undefined, txPackets = undefined, operations = undefined;
                cmd = ['dumpsys', 'netstats'];
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.adb.shell(cmd));

              case 5:
                data = context$2$0.sent;

                if (data) {
                  context$2$0.next = 8;
                  break;
                }

                throw new Error('No data from dumpsys');

              case 8:
                index = 0;
                fromXtstats = data.indexOf("Xt stats:");
                start = data.indexOf("Pending bytes:", fromXtstats);
                delimiter = data.indexOf(":", start + 1);
                end = data.indexOf("\n", delimiter + 1);
                pendingBytes = data.substring(delimiter + 1, end).trim();

                if (end > delimiter) {
                  start = data.indexOf("bucketDuration", end + 1);
                  delimiter = data.indexOf("=", start + 1);
                  end = data.indexOf("\n", delimiter + 1);
                  bucketDuration = data.substring(delimiter + 1, end).trim();
                }

                if (!(start >= 0)) {
                  context$2$0.next = 33;
                  break;
                }

                data = data.substring(end + 1, data.length);
                arrayList = data.split("\n");

                if (!(arrayList.length > 0)) {
                  context$2$0.next = 33;
                  break;
                }

                start = -1;

                j = 0;

              case 21:
                if (!(j < NETWORK_KEYS.length)) {
                  context$2$0.next = 31;
                  break;
                }

                start = arrayList[0].indexOf(NETWORK_KEYS[j][0]);

                if (!(start >= 0)) {
                  context$2$0.next = 28;
                  break;
                }

                index = j;
                returnValue[0] = [];

                for (k = 0; k < NETWORK_KEYS[j].length; ++k) {
                  returnValue[0][k] = NETWORK_KEYS[j][k];
                }
                return context$2$0.abrupt('break', 31);

              case 28:
                ++j;
                context$2$0.next = 21;
                break;

              case 31:
                returnIndex = 1;

                for (i = 0; i < arrayList.length; i++) {
                  data = arrayList[i];
                  start = data.indexOf(NETWORK_KEYS[index][0]);

                  if (start >= 0) {
                    delimiter = data.indexOf("=", start + 1);
                    end = data.indexOf(" ", delimiter + 1);
                    bucketStart = data.substring(delimiter + 1, end).trim();

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][1], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        activeTime = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][2], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        rxBytes = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][3], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        rxPackets = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][4], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        txBytes = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][5], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        txPackets = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][6], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.length;
                        operations = data.substring(delimiter + 1, end).trim();
                      }
                    }
                    returnValue[returnIndex++] = [bucketStart, activeTime, rxBytes, rxPackets, txBytes, txPackets, operations, bucketDuration];
                  }
                }

              case 33:
                if (!(!_lodash2['default'].isEqual(pendingBytes, "") && !_lodash2['default'].isUndefined(pendingBytes) && !_lodash2['default'].isEqual(pendingBytes, "nodex"))) {
                  context$2$0.next = 37;
                  break;
                }

                return context$2$0.abrupt('return', returnValue);

              case 37:
                throw new Error('Unable to parse network traffic data: \'' + data + '\'');

              case 38:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

_Object$assign(extensions, commands, helpers);
exports.commands = commands;
exports.helpers = helpers;
exports.SUPPORTED_PERFORMANCE_DATA_TYPES = SUPPORTED_PERFORMANCE_DATA_TYPES;
exports.CPU_KEYS = CPU_KEYS;
exports.MEMORY_KEYS = MEMORY_KEYS;
exports.BATTERY_KEYS = BATTERY_KEYS;
exports.NETWORK_KEYS = NETWORK_KEYS;
exports['default'] = extensions;

// TODO: figure out why this is
// sometimes, the function of 'adb.shell' fails. when I tested this function on the target of 'Galaxy Note5',
// adb.shell(dumpsys cpuinfo) returns cpu datas for other application packages, but I can't find the data for packageName.
// It usually fails 30 times and success for the next time,
// Since then, he has continued to succeed.

// `data` will be something like
//    +0% 2209/io.appium.android.apis: 0.1% user + 0.2% kernel
//eslint-disable-line curly

//eslint-disable-line curly

//eslint-disable-line curly

// In case of network traffic information, it is different for the return data between emulator and real device.
// the return data of emulator
//   Xt stats:
//   Pending bytes: 39250
//   History since boot:
//   ident=[[type=WIFI, subType=COMBINED, networkId="WiredSSID"]] uid=-1 set=ALL tag=0x0
//   NetworkStatsHistory: bucketDuration=3600000
//   bucketStart=1478098800000 activeTime=31824 rxBytes=21502 rxPackets=78 txBytes=17748 txPackets=90 operations=0
//
// 7.1
//   Xt stats:
//   Pending bytes: 481487
//   History since boot:
//   ident=[{type=MOBILE, subType=COMBINED, subscriberId=310260..., metered=true}] uid=-1 set=ALL tag=0x0
//     NetworkStatsHistory: bucketDuration=3600
//       st=1483984800 rb=0 rp=0 tb=12031 tp=184 op=0
//       st=1483988400 rb=0 rp=0 tb=38476 tp=587 op=0
//       st=1483999200 rb=315616 rp=400 tb=94800 tp=362 op=0
//       st=1484002800 rb=15826 rp=20 tb=4738 tp=16 op=0
//
// the return data of real device
//   Xt stats:
//   Pending bytes: 0
//   History since boot:
//   ident=[{type=MOBILE, subType=COMBINED, subscriberId=450050...}] uid=-1 set=ALL tag=0x0
//   NetworkStatsHistory: bucketDuration=3600
//   st=1478088000 rb=32115296 rp=34291 tb=2956805 tp=25705 op=0
//   st=1478091600 rb=2714683 rp=11821 tb=1420564 tp=12650 op=0
//   st=1478095200 rb=10079213 rp=19962 tb=2487705 tp=20015 op=0
//   st=1478098800 rb=4444433 rp=10227 tb=1430356 tp=10493 op=0
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9wZXJmb3JtYW5jZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O3NCQUFjLFFBQVE7Ozs7d0JBQ1EsVUFBVTs7QUFHeEMsSUFBSSxRQUFRLEdBQUcsRUFBRTtJQUFFLE9BQU8sR0FBRyxFQUFFO0lBQUUsVUFBVSxHQUFHLEVBQUUsQ0FBQzs7QUFFakQsSUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFDLGFBQWEsRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQztBQUMzTSxJQUFNLFFBQVEsR0FBRyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUNwQyxJQUFNLFlBQVksR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQy9CLElBQU0sV0FBVyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDOztBQUVqTyxJQUFNLGdDQUFnQyxHQUFHO0FBQ3ZDLFNBQU8sRUFBRSxnSEFBZ0g7QUFDekgsWUFBVSxFQUFFLCtHQUErRztBQUMzSCxhQUFXLEVBQUUseUdBQXlHO0FBQ3RILGFBQVcsRUFBRSxvR0FBb0c7Q0FDbEgsQ0FBQzs7QUFFRixJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7Ozs7Ozs7QUFPekIsUUFBUSxDQUFDLHVCQUF1QixHQUFHLFlBQVk7QUFDN0MsU0FBTyxvQkFBRSxJQUFJLENBQUMsZ0NBQWdDLENBQUMs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Q0FBQzs7QUFFRixlQUFjLFVBQVUsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDcEMsUUFBUSxHQUFSLFFBQVE7UUFBRSxPQUFPLEdBQVAsT0FBTztRQUFFLGdDQUFnQyxHQUFoQyxnQ0FBZ0M7UUFBRSxRQUFRLEdBQVIsUUFBUTtRQUM3RCxXQUFXLEdBQVgsV0FBVztRQUFFLFlBQVksR0FBWixZQUFZO1FBQUUsWUFBWSxHQUFaLFlBQVk7cUJBQ2pDLFVBQVUiLCJmaWxlIjoibGliL2NvbW1hbmRzL3BlcmZvcm1hbmNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5cblxubGV0IGNvbW1hbmRzID0ge30sIGhlbHBlcnMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9O1xuXG5jb25zdCBORVRXT1JLX0tFWVMgPSBbWydidWNrZXRTdGFydCcsICdhY3RpdmVUaW1lJywgJ3J4Qnl0ZXMnLCAncnhQYWNrZXRzJywgJ3R4Qnl0ZXMnLCAndHhQYWNrZXRzJywgJ29wZXJhdGlvbnMnLCAnYnVja2V0RHVyYXRpb24nXSwgWydzdCcsICdhY3RpdmVUaW1lJywgJ3JiJywgJ3JwJywgJ3RiJywgJ3RwJywgJ29wJywgJ2J1Y2tldER1cmF0aW9uJ11dO1xuY29uc3QgQ1BVX0tFWVMgPSBbJ3VzZXInLCAna2VybmVsJ107XG5jb25zdCBCQVRURVJZX0tFWVMgPSBbJ3Bvd2VyJ107XG5jb25zdCBNRU1PUllfS0VZUyA9IFsndG90YWxQcml2YXRlRGlydHknLCAnbmF0aXZlUHJpdmF0ZURpcnR5JywgJ2RhbHZpa1ByaXZhdGVEaXJ0eScsICdlZ2xQcml2YXRlRGlydHknLCAnZ2xQcml2YXRlRGlydHknLCAndG90YWxQc3MnLCAnbmF0aXZlUHNzJywgJ2RhbHZpa1BzcycsICdlZ2xQc3MnLCAnZ2xQc3MnLCAnbmF0aXZlSGVhcEFsbG9jYXRlZFNpemUnLCAnbmF0aXZlSGVhcFNpemUnXTtcblxuY29uc3QgU1VQUE9SVEVEX1BFUkZPUk1BTkNFX0RBVEFfVFlQRVMgPSB7XG4gIGNwdWluZm86ICd0aGUgYW1vdW50IG9mIGNwdSBieSB1c2VyIGFuZCBrZXJuZWwgcHJvY2VzcyAtIGNwdSBpbmZvcm1hdGlvbiBmb3IgYXBwbGljYXRpb25zIG9uIHJlYWwgZGV2aWNlcyBhbmQgc2ltdWxhdG9ycycsXG4gIG1lbW9yeWluZm86ICd0aGUgYW1vdW50IG9mIG1lbW9yeSB1c2VkIGJ5IHRoZSBwcm9jZXNzIC0gbWVtb3J5IGluZm9ybWF0aW9uIGZvciBhcHBsaWNhdGlvbnMgb24gcmVhbCBkZXZpY2VzIGFuZCBzaW11bGF0b3JzJyxcbiAgYmF0dGVyeWluZm86ICd0aGUgcmVtYWluaW5nIGJhdHRlcnkgcG93ZXIgLSBiYXR0ZXJ5IHBvd2VyIGluZm9ybWF0aW9uIGZvciBhcHBsaWNhdGlvbnMgb24gcmVhbCBkZXZpY2VzIGFuZCBzaW11bGF0b3JzJyxcbiAgbmV0d29ya2luZm86ICd0aGUgbmV0d29yayBzdGF0aXN0aWNzIC0gbmV0d29yayByeC90eCBpbmZvcm1hdGlvbiBmb3IgYXBwbGljYXRpb25zIG9uIHJlYWwgZGV2aWNlcyBhbmQgc2ltdWxhdG9ycydcbn07XG5cbmNvbnN0IFJFVFJZX1BBVVNFID0gMTAwMDtcblxuLy9cbi8vIHJldHVybnMgdGhlIGluZm9ybWF0aW9uIHR5cGUgb2YgdGhlIHN5c3RlbSBzdGF0ZSB3aGljaCBpcyBzdXBwb3J0ZWQgdG8gcmVhZCBhcyBsaWtlIGNwdSwgbWVtb3J5LCBuZXR3b3JrIHRyYWZmaWMsIGFuZCBiYXR0ZXJ5LlxuLy8gb3V0cHV0IC0gYXJyYXkgbGlrZSBiZWxvd1xuLy9bY3B1aW5mbywgYmF0dGVyeWluZm8sIG5ldHdvcmtpbmZvLCBtZW1vcnlpbmZvXVxuLy9cbmNvbW1hbmRzLmdldFBlcmZvcm1hbmNlRGF0YVR5cGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gXy5rZXlzKFNVUFBPUlRFRF9QRVJGT1JNQU5DRV9EQVRBX1RZUEVTKTtcbn07XG5cbi8vIHJldHVybnMgdGhlIGluZm9ybWF0aW9uIHR5cGUgb2YgdGhlIHN5c3RlbSBzdGF0ZSB3aGljaCBpcyBzdXBwb3J0ZWQgdG8gcmVhZCBhcyBsaWtlIGNwdSwgbWVtb3J5LCBuZXR3b3JrIHRyYWZmaWMsIGFuZCBiYXR0ZXJ5LlxuLy9pbnB1dCAtIChwYWNrYWdlTmFtZSkgdGhlIHBhY2thZ2UgbmFtZSBvZiB0aGUgYXBwbGljYXRpb25cbi8vICAgICAgICAoZGF0YVR5cGUpIHRoZSB0eXBlIG9mIHN5c3RlbSBzdGF0ZSB3aGljaCB3YW50cyB0byByZWFkLiBJdCBzaG91bGQgYmUgb25lIG9mIHRoZSBrZXlzIG9mIHRoZSBTVVBQT1JURURfUEVSRk9STUFOQ0VfREFUQV9UWVBFU1xuLy8gICAgICAgIChkYXRhUmVhZFRpbWVvdXQpIHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gcmVhZFxuLy8gb3V0cHV0IC0gdGFibGUgb2YgdGhlIHBlcmZvcm1hbmNlIGRhdGEsIFRoZSBmaXJzdCBsaW5lIG9mIHRoZSB0YWJsZSByZXByZXNlbnRzIHRoZSB0eXBlIG9mIGRhdGEuIFRoZSByZW1haW5pbmcgbGluZXMgcmVwcmVzZW50IHRoZSB2YWx1ZXMgb2YgdGhlIGRhdGEuXG4vL1xuLy8gaW4gY2FzZSBvZiBiYXR0ZXJ5IGluZm8gOiBbW3Bvd2VyXSwgWzIzXV1cbi8vIGluIGNhc2Ugb2YgbWVtb3J5IGluZm8gOiAgW1t0b3RhbFByaXZhdGVEaXJ0eSwgbmF0aXZlUHJpdmF0ZURpcnR5LCBkYWx2aWtQcml2YXRlRGlydHksIGVnbFByaXZhdGVEaXJ0eSwgZ2xQcml2YXRlRGlydHksIHRvdGFsUHNzLCBuYXRpdmVQc3MsIGRhbHZpa1BzcywgZWdsUHNzLCBnbFBzcywgbmF0aXZlSGVhcEFsbG9jYXRlZFNpemUsIG5hdGl2ZUhlYXBTaXplXSwgWzE4MzYwLCA4Mjk2LCA2MTMyLCBudWxsLCBudWxsLCA0MjU4OCwgODQwNiwgNzAyNCwgbnVsbCwgbnVsbCwgMjY1MTksIDEwMzQ0XV1cbi8vIGluIGNhc2Ugb2YgbmV0d29yayBpbmZvIDogW1tidWNrZXRTdGFydCwgYWN0aXZlVGltZSwgcnhCeXRlcywgcnhQYWNrZXRzLCB0eEJ5dGVzLCB0eFBhY2tldHMsIG9wZXJhdGlvbnMsIGJ1Y2tldER1cmF0aW9uLF0sIFsxNDc4MDkxNjAwMDAwLCBudWxsLCAxMDk5MDc1LCA2MTA5NDcsIDkyOCwgMTE0MzYyLCA3NjksIDAsIDM2MDAwMDBdLCBbMTQ3ODA5NTIwMDAwMCwgbnVsbCwgMTMwNjMwMCwgNDA1OTk3LCA1MDksIDQ2MzU5LCAzNzAsIDAsIDM2MDAwMDBdXVxuLy8gaW4gY2FzZSBvZiBuZXR3b3JrIGluZm8gOiBbW3N0LCBhY3RpdmVUaW1lLCByYiwgcnAsIHRiLCB0cCwgb3AsIGJ1Y2tldER1cmF0aW9uXSwgWzE0NzgwODgwMDAsIG51bGwsIG51bGwsIDMyMTE1Mjk2LCAzNDI5MSwgMjk1NjgwNSwgMjU3MDUsIDAsIDM2MDBdLCBbMTQ3ODA5MTYwMCwgbnVsbCwgbnVsbCwgMjcxNDY4MywgMTE4MjEsIDE0MjA1NjQsIDEyNjUwLCAwLCAzNjAwXSwgWzE0NzgwOTUyMDAsIG51bGwsIG51bGwsIDEwMDc5MjEzLCAxOTk2MiwgMjQ4NzcwNSwgMjAwMTUsIDAsIDM2MDBdLCBbMTQ3ODA5ODgwMCwgbnVsbCwgbnVsbCwgNDQ0NDQzMywgMTAyMjcsIDE0MzAzNTYsIDEwNDkzLCAwLCAzNjAwXV1cbi8vIGluIGNhc2Ugb2YgY3B1IGluZm8gOiBbW3VzZXIsIGtlcm5lbF0sIFswLjksIDEuM11dXG4vL1xuY29tbWFuZHMuZ2V0UGVyZm9ybWFuY2VEYXRhID0gYXN5bmMgZnVuY3Rpb24gKHBhY2thZ2VOYW1lLCBkYXRhVHlwZSwgZGF0YVJlYWRUaW1lb3V0ID0gMikge1xuICBsZXQgZGF0YTtcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgIGNhc2UgJ2JhdHRlcnlpbmZvJzpcbiAgICAgIGRhdGEgPSBhd2FpdCB0aGlzLmdldEJhdHRlcnlJbmZvKGRhdGFSZWFkVGltZW91dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjcHVpbmZvJzpcbiAgICAgIGRhdGEgPSBhd2FpdCB0aGlzLmdldENQVUluZm8ocGFja2FnZU5hbWUsIGRhdGFSZWFkVGltZW91dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtZW1vcnlpbmZvJzpcbiAgICAgIGRhdGEgPSBhd2FpdCB0aGlzLmdldE1lbW9yeUluZm8ocGFja2FnZU5hbWUsIGRhdGFSZWFkVGltZW91dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICduZXR3b3JraW5mbyc6XG4gICAgICBkYXRhID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrVHJhZmZpY0luZm8oZGF0YVJlYWRUaW1lb3V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHBlcmZvcm1hbmNlIGRhdGEgb2YgdHlwZSAnJHtkYXRhVHlwZX0nIGZvdW5kLmApO1xuICB9XG4gIHJldHVybiBkYXRhO1xufTtcblxuaGVscGVycy5nZXRDUFVJbmZvID0gYXN5bmMgZnVuY3Rpb24gKHBhY2thZ2VOYW1lLCBkYXRhUmVhZFRpbWVvdXQgPSAyKSB7XG4gIC8vIFRPRE86IGZpZ3VyZSBvdXQgd2h5IHRoaXMgaXNcbiAgLy8gc29tZXRpbWVzLCB0aGUgZnVuY3Rpb24gb2YgJ2FkYi5zaGVsbCcgZmFpbHMuIHdoZW4gSSB0ZXN0ZWQgdGhpcyBmdW5jdGlvbiBvbiB0aGUgdGFyZ2V0IG9mICdHYWxheHkgTm90ZTUnLFxuICAvLyBhZGIuc2hlbGwoZHVtcHN5cyBjcHVpbmZvKSByZXR1cm5zIGNwdSBkYXRhcyBmb3Igb3RoZXIgYXBwbGljYXRpb24gcGFja2FnZXMsIGJ1dCBJIGNhbid0IGZpbmQgdGhlIGRhdGEgZm9yIHBhY2thZ2VOYW1lLlxuICAvLyBJdCB1c3VhbGx5IGZhaWxzIDMwIHRpbWVzIGFuZCBzdWNjZXNzIGZvciB0aGUgbmV4dCB0aW1lLFxuICAvLyBTaW5jZSB0aGVuLCBoZSBoYXMgY29udGludWVkIHRvIHN1Y2NlZWQuXG4gIHJldHVybiBhd2FpdCByZXRyeUludGVydmFsKGRhdGFSZWFkVGltZW91dCwgUkVUUllfUEFVU0UsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjbWQgPSBbJ2R1bXBzeXMnLCAnY3B1aW5mbycsICd8JywgJ2dyZXAnLCBgJyR7cGFja2FnZU5hbWV9J2BdO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFkYi5zaGVsbChjbWQpO1xuICAgIGlmIChfLmlzRW1wdHkoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSBmcm9tIGR1bXBzeXMnKTtcbiAgICB9XG4gICAgLy8gYGRhdGFgIHdpbGwgYmUgc29tZXRoaW5nIGxpa2VcbiAgICAvLyAgICArMCUgMjIwOS9pby5hcHBpdW0uYW5kcm9pZC5hcGlzOiAwLjElIHVzZXIgKyAwLjIlIGtlcm5lbFxuICAgIGNvbnN0IHVzZXJNYXRjaCA9IC8oW1xcZFxcLl0rKSVcXHMrdXNlci8uZXhlYyhkYXRhKTtcbiAgICBjb25zdCBrZXJuZWxNYXRjaCA9IC8oW1xcZFxcLl0rKSVcXHMra2VybmVsLy5leGVjKGRhdGEpO1xuICAgIGlmICghdXNlck1hdGNoIHx8ICFrZXJuZWxNYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgY3B1IGRhdGE6ICcke2RhdGF9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gW18uY2xvbmUoQ1BVX0tFWVMpLCBbdXNlck1hdGNoWzFdLCBrZXJuZWxNYXRjaFsxXV1dO1xuICB9KTtcbn07XG5cbmhlbHBlcnMuZ2V0QmF0dGVyeUluZm8gPSBhc3luYyBmdW5jdGlvbiAoZGF0YVJlYWRUaW1lb3V0ID0gMikge1xuICByZXR1cm4gYXdhaXQgcmV0cnlJbnRlcnZhbChkYXRhUmVhZFRpbWVvdXQsIFJFVFJZX1BBVVNFLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGNtZCA9IFsnZHVtcHN5cycsICdiYXR0ZXJ5JywgJ3wnLCAnZ3JlcCcsICdsZXZlbCddO1xuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5hZGIuc2hlbGwoY21kKTtcbiAgICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSBmcm9tIGR1bXBzeXMnKTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG5cbiAgICBsZXQgcG93ZXIgPSBwYXJzZUludCgoZGF0YS5zcGxpdCgnOicpWzFdIHx8ICcnKS50cmltKCksIDEwKTtcblxuICAgIGlmICghTnVtYmVyLmlzTmFOKHBvd2VyKSkge1xuICAgICAgcmV0dXJuIFtfLmNsb25lKEJBVFRFUllfS0VZUyksIFtwb3dlci50b1N0cmluZygpXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGJhdHRlcnkgZGF0YTogJyR7ZGF0YX0nYCk7XG4gICAgfVxuICB9KTtcblxufTtcblxuaGVscGVycy5nZXRNZW1vcnlJbmZvID0gYXN5bmMgZnVuY3Rpb24gKHBhY2thZ2VOYW1lLCBkYXRhUmVhZFRpbWVvdXQgPSAyKSB7XG4gIHJldHVybiBhd2FpdCByZXRyeUludGVydmFsKGRhdGFSZWFkVGltZW91dCwgUkVUUllfUEFVU0UsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgY21kID0gWydkdW1wc3lzJywgJ21lbWluZm8nLCBgJyR7cGFja2FnZU5hbWV9J2AsICd8JywgJ2dyZXAnLCAnLUUnLCBcIidOYXRpdmV8RGFsdmlrfEVHTHxHTHxUT1RBTCdcIl07XG4gICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFkYi5zaGVsbChjbWQpO1xuICAgIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhIGZyb20gZHVtcHN5cycpOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcblxuICAgIGxldCB0b3RhbFByaXZhdGVEaXJ0eSwgdG90YWxQc3MsXG4gICAgICAgIG5hdGl2ZVByaXZhdGVEaXJ0eSwgbmF0aXZlUHNzLCBuYXRpdmVIZWFwU2l6ZSwgbmF0aXZlSGVhcEFsbG9jYXRlZFNpemUsXG4gICAgICAgIGRhbHZpa1ByaXZhdGVEaXJ0eSwgZGFsdmlrUHNzLFxuICAgICAgICBlZ2xQcml2YXRlRGlydHksIGVnbFBzcyxcbiAgICAgICAgZ2xQcml2YXRlRGlydHksIGdsUHNzO1xuICAgIGxldCBhcGlsZXZlbCA9IGF3YWl0IHRoaXMuYWRiLmdldEFwaUxldmVsKCk7XG4gICAgZm9yIChsZXQgbGluZSBvZiBkYXRhLnNwbGl0KCdcXG4nKSkge1xuICAgICAgbGV0IGVudHJpZXMgPSBsaW5lLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIC8vIGVudHJpZXMgd2lsbCBoYXZlIHRoZSB2YWx1ZXNcbiAgICAgIC8vICAgWyc8U3lzdGVtIFR5cGU+JywgJzxNZW1vcnkgVHlwZT4nLCA8cHNzIHRvdGFsPiwgPHByaXZhdGUgZGlydHk+LCA8cHJpdmF0ZSBjbGVhbj4sIDxzd2FwUHNzIGRpcnR5PiwgPGhlYXAgc2l6ZT4sIDxoZWFwIGFsbG9jPiwgPGhlYXAgZnJlZT5dXG4gICAgICAvLyBleGNlcHQgJ1RPVEFMJywgd2hpY2ggc2tpcHMgdGhlIHNlY29uZCB0eXBlIG5hbWVcbiAgICAgIC8vXG4gICAgICAvLyBhbmQgb24gQVBJIGxldmVsIDE4IGFuZCBiZWxvd1xuICAgICAgLy8gICBbJzxTeXN0ZW0gVHlwZScsICc8cHBzPicsICc8c2hhcmVkIGRpcnR5PicsICc8cHJpdmF0ZSBkaXJ0eT4nLCAnPGhlYXAgc2l6ZT4nLCAnPGhlYXAgYWxsb2M+JywgJzxoZWFwIGZyZWU+J11cblxuICAgICAgaWYgKGFwaWxldmVsID4gMTgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBlbnRyaWVzWzBdO1xuICAgICAgICBsZXQgc3ViVHlwZSA9IGVudHJpZXNbMV07XG4gICAgICAgIGlmICh0eXBlID09PSAnTmF0aXZlJyAmJiBzdWJUeXBlID09PSAnSGVhcCcpIHtcbiAgICAgICAgICAvLyBuYXRpdmUgaGVhcFxuICAgICAgICAgIG5hdGl2ZVBzcyA9IGVudHJpZXNbMl07XG4gICAgICAgICAgbmF0aXZlUHJpdmF0ZURpcnR5ID0gZW50cmllc1szXTtcbiAgICAgICAgICBuYXRpdmVIZWFwU2l6ZSA9IGVudHJpZXNbNl07XG4gICAgICAgICAgbmF0aXZlSGVhcEFsbG9jYXRlZFNpemUgPSBlbnRyaWVzWzddO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdEYWx2aWsnICYmIHN1YlR5cGUgPT09ICdIZWFwJykge1xuICAgICAgICAgIC8vIGRhbHZpayBoZWFwXG4gICAgICAgICAgZGFsdmlrUHNzID0gZW50cmllc1syXTtcbiAgICAgICAgICBkYWx2aWtQcml2YXRlRGlydHkgPSBlbnRyaWVzWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdFR0wnICYmIHN1YlR5cGUgPT09ICdtdHJhY2snKSB7XG4gICAgICAgICAgLy8gZWdsXG4gICAgICAgICAgZWdsUHNzID0gZW50cmllc1syXTtcbiAgICAgICAgICBlZ2xQcml2YXRlRGlydHkgPSBlbnRyaWVzWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHTCcgJiYgc3ViVHlwZSA9PT0gJ210cmFjaycpIHtcbiAgICAgICAgICAvLyBnbFxuICAgICAgICAgIGdsUHNzID0gZW50cmllc1syXTtcbiAgICAgICAgICBnbFByaXZhdGVEaXJ0eSA9IGVudHJpZXNbM107XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1RPVEFMJyAmJiBlbnRyaWVzLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICAgIC8vIHRoZXJlIGFyZSB0d28gdG90YWxzLCBhbmQgd2Ugb25seSB3YW50IHRoZSBmdWxsIGxpc3RpbmcsIHdoaWNoIGhhcyA4IGVudHJpZXNcbiAgICAgICAgICB0b3RhbFBzcyA9IGVudHJpZXNbMV07XG4gICAgICAgICAgdG90YWxQcml2YXRlRGlydHkgPSBlbnRyaWVzWzJdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdHlwZSA9IGVudHJpZXNbMF07XG4gICAgICAgIGlmICh0eXBlID09PSAnTmF0aXZlJykge1xuICAgICAgICAgIG5hdGl2ZVBzcyA9IGVudHJpZXNbMV07XG4gICAgICAgICAgbmF0aXZlUHJpdmF0ZURpcnR5ID0gZW50cmllc1szXTtcbiAgICAgICAgICBuYXRpdmVIZWFwU2l6ZSA9IGVudHJpZXNbNF07XG4gICAgICAgICAgbmF0aXZlSGVhcEFsbG9jYXRlZFNpemUgPSBlbnRyaWVzWzVdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdEYWx2aWsnKSB7XG4gICAgICAgICAgZGFsdmlrUHNzID0gZW50cmllc1sxXTtcbiAgICAgICAgICBkYWx2aWtQcml2YXRlRGlydHkgPSBlbnRyaWVzWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdFR0wnKSB7XG4gICAgICAgICAgZWdsUHNzID0gZW50cmllc1sxXTtcbiAgICAgICAgICBlZ2xQcml2YXRlRGlydHkgPSBlbnRyaWVzWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHTCcpIHtcbiAgICAgICAgICBnbFBzcyA9IGVudHJpZXNbMV07XG4gICAgICAgICAgZ2xQcml2YXRlRGlydHkgPSBlbnRyaWVzWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdUT1RBTCcpIHtcbiAgICAgICAgICB0b3RhbFBzcyA9IGVudHJpZXNbMV07XG4gICAgICAgICAgdG90YWxQcml2YXRlRGlydHkgPSBlbnRyaWVzWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRvdGFsUHJpdmF0ZURpcnR5ICYmIHRvdGFsUHJpdmF0ZURpcnR5ICE9PSAnbm9kZXgnKSB7XG4gICAgICBsZXQgaGVhZGVycyA9IF8uY2xvbmUoTUVNT1JZX0tFWVMpO1xuICAgICAgbGV0IGRhdGEgPSBbdG90YWxQcml2YXRlRGlydHksIG5hdGl2ZVByaXZhdGVEaXJ0eSwgZGFsdmlrUHJpdmF0ZURpcnR5LCBlZ2xQcml2YXRlRGlydHksIGdsUHJpdmF0ZURpcnR5LCB0b3RhbFBzcywgbmF0aXZlUHNzLCBkYWx2aWtQc3MsIGVnbFBzcywgZ2xQc3MsIG5hdGl2ZUhlYXBBbGxvY2F0ZWRTaXplLCBuYXRpdmVIZWFwU2l6ZV07XG4gICAgICByZXR1cm4gW2hlYWRlcnMsIGRhdGFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBtZW1vcnkgZGF0YTogJyR7ZGF0YX0nYCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmhlbHBlcnMuZ2V0TmV0d29ya1RyYWZmaWNJbmZvID0gYXN5bmMgZnVuY3Rpb24gKGRhdGFSZWFkVGltZW91dCA9IDIpIHtcbiAgcmV0dXJuIGF3YWl0IHJldHJ5SW50ZXJ2YWwoZGF0YVJlYWRUaW1lb3V0LCBSRVRSWV9QQVVTRSwgYXN5bmMgKCkgPT4ge1xuICAgIGxldCByZXR1cm5WYWx1ZSA9IFtdO1xuICAgIGxldCBidWNrZXREdXJhdGlvbiwgYnVja2V0U3RhcnQsIGFjdGl2ZVRpbWUsIHJ4Qnl0ZXMsIHJ4UGFja2V0cywgdHhCeXRlcywgdHhQYWNrZXRzLCBvcGVyYXRpb25zO1xuXG4gICAgbGV0IGNtZCA9IFsnZHVtcHN5cycsICduZXRzdGF0cyddO1xuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5hZGIuc2hlbGwoY21kKTtcbiAgICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSBmcm9tIGR1bXBzeXMnKTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG5cbiAgICAvLyBJbiBjYXNlIG9mIG5ldHdvcmsgdHJhZmZpYyBpbmZvcm1hdGlvbiwgaXQgaXMgZGlmZmVyZW50IGZvciB0aGUgcmV0dXJuIGRhdGEgYmV0d2VlbiBlbXVsYXRvciBhbmQgcmVhbCBkZXZpY2UuXG4gICAgLy8gdGhlIHJldHVybiBkYXRhIG9mIGVtdWxhdG9yXG4gICAgLy8gICBYdCBzdGF0czpcbiAgICAvLyAgIFBlbmRpbmcgYnl0ZXM6IDM5MjUwXG4gICAgLy8gICBIaXN0b3J5IHNpbmNlIGJvb3Q6XG4gICAgLy8gICBpZGVudD1bW3R5cGU9V0lGSSwgc3ViVHlwZT1DT01CSU5FRCwgbmV0d29ya0lkPVwiV2lyZWRTU0lEXCJdXSB1aWQ9LTEgc2V0PUFMTCB0YWc9MHgwXG4gICAgLy8gICBOZXR3b3JrU3RhdHNIaXN0b3J5OiBidWNrZXREdXJhdGlvbj0zNjAwMDAwXG4gICAgLy8gICBidWNrZXRTdGFydD0xNDc4MDk4ODAwMDAwIGFjdGl2ZVRpbWU9MzE4MjQgcnhCeXRlcz0yMTUwMiByeFBhY2tldHM9NzggdHhCeXRlcz0xNzc0OCB0eFBhY2tldHM9OTAgb3BlcmF0aW9ucz0wXG4gICAgLy9cbiAgICAvLyA3LjFcbiAgICAvLyAgIFh0IHN0YXRzOlxuICAgIC8vICAgUGVuZGluZyBieXRlczogNDgxNDg3XG4gICAgLy8gICBIaXN0b3J5IHNpbmNlIGJvb3Q6XG4gICAgLy8gICBpZGVudD1be3R5cGU9TU9CSUxFLCBzdWJUeXBlPUNPTUJJTkVELCBzdWJzY3JpYmVySWQ9MzEwMjYwLi4uLCBtZXRlcmVkPXRydWV9XSB1aWQ9LTEgc2V0PUFMTCB0YWc9MHgwXG4gICAgLy8gICAgIE5ldHdvcmtTdGF0c0hpc3Rvcnk6IGJ1Y2tldER1cmF0aW9uPTM2MDBcbiAgICAvLyAgICAgICBzdD0xNDgzOTg0ODAwIHJiPTAgcnA9MCB0Yj0xMjAzMSB0cD0xODQgb3A9MFxuICAgIC8vICAgICAgIHN0PTE0ODM5ODg0MDAgcmI9MCBycD0wIHRiPTM4NDc2IHRwPTU4NyBvcD0wXG4gICAgLy8gICAgICAgc3Q9MTQ4Mzk5OTIwMCByYj0zMTU2MTYgcnA9NDAwIHRiPTk0ODAwIHRwPTM2MiBvcD0wXG4gICAgLy8gICAgICAgc3Q9MTQ4NDAwMjgwMCByYj0xNTgyNiBycD0yMCB0Yj00NzM4IHRwPTE2IG9wPTBcbiAgICAvL1xuICAgIC8vIHRoZSByZXR1cm4gZGF0YSBvZiByZWFsIGRldmljZVxuICAgIC8vICAgWHQgc3RhdHM6XG4gICAgLy8gICBQZW5kaW5nIGJ5dGVzOiAwXG4gICAgLy8gICBIaXN0b3J5IHNpbmNlIGJvb3Q6XG4gICAgLy8gICBpZGVudD1be3R5cGU9TU9CSUxFLCBzdWJUeXBlPUNPTUJJTkVELCBzdWJzY3JpYmVySWQ9NDUwMDUwLi4ufV0gdWlkPS0xIHNldD1BTEwgdGFnPTB4MFxuICAgIC8vICAgTmV0d29ya1N0YXRzSGlzdG9yeTogYnVja2V0RHVyYXRpb249MzYwMFxuICAgIC8vICAgc3Q9MTQ3ODA4ODAwMCByYj0zMjExNTI5NiBycD0zNDI5MSB0Yj0yOTU2ODA1IHRwPTI1NzA1IG9wPTBcbiAgICAvLyAgIHN0PTE0NzgwOTE2MDAgcmI9MjcxNDY4MyBycD0xMTgyMSB0Yj0xNDIwNTY0IHRwPTEyNjUwIG9wPTBcbiAgICAvLyAgIHN0PTE0NzgwOTUyMDAgcmI9MTAwNzkyMTMgcnA9MTk5NjIgdGI9MjQ4NzcwNSB0cD0yMDAxNSBvcD0wXG4gICAgLy8gICBzdD0xNDc4MDk4ODAwIHJiPTQ0NDQ0MzMgcnA9MTAyMjcgdGI9MTQzMDM1NiB0cD0xMDQ5MyBvcD0wXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgZnJvbVh0c3RhdHMgPSBkYXRhLmluZGV4T2YoXCJYdCBzdGF0czpcIik7XG5cbiAgICBsZXQgc3RhcnQgPSBkYXRhLmluZGV4T2YoXCJQZW5kaW5nIGJ5dGVzOlwiLCBmcm9tWHRzdGF0cyk7XG4gICAgbGV0IGRlbGltaXRlciA9IGRhdGEuaW5kZXhPZihcIjpcIiwgc3RhcnQgKyAxKTtcbiAgICBsZXQgZW5kID0gZGF0YS5pbmRleE9mKFwiXFxuXCIsIGRlbGltaXRlciArIDEpO1xuICAgIGxldCBwZW5kaW5nQnl0ZXMgPSBkYXRhLnN1YnN0cmluZyhkZWxpbWl0ZXIgKyAxLCBlbmQpLnRyaW0oKTtcblxuICAgIGlmIChlbmQgPiBkZWxpbWl0ZXIpIHtcbiAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKFwiYnVja2V0RHVyYXRpb25cIiwgZW5kICsgMSk7XG4gICAgICBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI9XCIsIHN0YXJ0ICsgMSk7XG4gICAgICBlbmQgPSBkYXRhLmluZGV4T2YoXCJcXG5cIiwgZGVsaW1pdGVyICsgMSk7XG4gICAgICBidWNrZXREdXJhdGlvbiA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICBkYXRhID0gZGF0YS5zdWJzdHJpbmcoZW5kICsgMSwgZGF0YS5sZW5ndGgpO1xuICAgICAgbGV0IGFycmF5TGlzdCA9IGRhdGEuc3BsaXQoXCJcXG5cIik7XG5cbiAgICAgIGlmIChhcnJheUxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IC0xO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTkVUV09SS19LRVlTLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgc3RhcnQgPSBhcnJheUxpc3RbMF0uaW5kZXhPZihORVRXT1JLX0tFWVNbal1bMF0pO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIGluZGV4ID0gajtcbiAgICAgICAgICAgIHJldHVyblZhbHVlWzBdID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgTkVUV09SS19LRVlTW2pdLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgIHJldHVyblZhbHVlWzBdW2tdID0gTkVUV09SS19LRVlTW2pdW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJldHVybkluZGV4ID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkYXRhID0gYXJyYXlMaXN0W2ldO1xuICAgICAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKE5FVFdPUktfS0VZU1tpbmRleF1bMF0pO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIGRlbGltaXRlciA9IGRhdGEuaW5kZXhPZihcIj1cIiwgc3RhcnQgKyAxKTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGEuaW5kZXhPZihcIiBcIiwgZGVsaW1pdGVyICsgMSk7XG4gICAgICAgICAgICBidWNrZXRTdGFydCA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAoZW5kID4gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKE5FVFdPUktfS0VZU1tpbmRleF1bMV0sIGVuZCsxKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI9XCIsIHN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0YS5pbmRleE9mKFwiIFwiLCBkZWxpbWl0ZXIgKyAxKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVUaW1lID0gZGF0YS5zdWJzdHJpbmcoZGVsaW1pdGVyICsgMSwgZW5kKS50cmltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVuZCA+IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICBzdGFydCA9IGRhdGEuaW5kZXhPZihORVRXT1JLX0tFWVNbaW5kZXhdWzJdLCBlbmQrMSk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gZGF0YS5pbmRleE9mKFwiPVwiLCBzdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGEuaW5kZXhPZihcIiBcIiwgZGVsaW1pdGVyICsgMSk7XG4gICAgICAgICAgICAgICAgcnhCeXRlcyA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmQgPiBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBkYXRhLmluZGV4T2YoTkVUV09SS19LRVlTW2luZGV4XVszXSwgZW5kKzEpO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGltaXRlciA9IGRhdGEuaW5kZXhPZihcIj1cIiwgc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRhLmluZGV4T2YoXCIgXCIsIGRlbGltaXRlciArIDEpO1xuICAgICAgICAgICAgICAgIHJ4UGFja2V0cyA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmQgPiBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBkYXRhLmluZGV4T2YoTkVUV09SS19LRVlTW2luZGV4XVs0XSwgZW5kKzEpO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGltaXRlciA9IGRhdGEuaW5kZXhPZihcIj1cIiwgc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRhLmluZGV4T2YoXCIgXCIsIGRlbGltaXRlciArIDEpO1xuICAgICAgICAgICAgICAgIHR4Qnl0ZXMgPSBkYXRhLnN1YnN0cmluZyhkZWxpbWl0ZXIgKyAxLCBlbmQpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kID4gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKE5FVFdPUktfS0VZU1tpbmRleF1bNV0sIGVuZCsxKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI9XCIsIHN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0YS5pbmRleE9mKFwiIFwiLCBkZWxpbWl0ZXIgKyAxKTtcbiAgICAgICAgICAgICAgICB0eFBhY2tldHMgPSBkYXRhLnN1YnN0cmluZyhkZWxpbWl0ZXIgKyAxLCBlbmQpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kID4gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKE5FVFdPUktfS0VZU1tpbmRleF1bNl0sIGVuZCsxKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI9XCIsIHN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucyA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblZhbHVlW3JldHVybkluZGV4KytdID0gW2J1Y2tldFN0YXJ0LCBhY3RpdmVUaW1lLCByeEJ5dGVzLCByeFBhY2tldHMsIHR4Qnl0ZXMsIHR4UGFja2V0cywgb3BlcmF0aW9ucywgYnVja2V0RHVyYXRpb25dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc0VxdWFsKHBlbmRpbmdCeXRlcywgXCJcIikgJiYgIV8uaXNVbmRlZmluZWQocGVuZGluZ0J5dGVzKSAmJiAhXy5pc0VxdWFsKHBlbmRpbmdCeXRlcywgXCJub2RleFwiKSkge1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBuZXR3b3JrIHRyYWZmaWMgZGF0YTogJyR7ZGF0YX0nYCk7XG4gICAgfVxuICB9KTtcbn07XG5cbk9iamVjdC5hc3NpZ24oZXh0ZW5zaW9ucywgY29tbWFuZHMsIGhlbHBlcnMpO1xuZXhwb3J0IHsgY29tbWFuZHMsIGhlbHBlcnMsIFNVUFBPUlRFRF9QRVJGT1JNQU5DRV9EQVRBX1RZUEVTLCBDUFVfS0VZUyxcbiAgICAgICAgIE1FTU9SWV9LRVlTLCBCQVRURVJZX0tFWVMsIE5FVFdPUktfS0VZUyB9O1xuZXhwb3J0IGRlZmF1bHQgZXh0ZW5zaW9ucztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
