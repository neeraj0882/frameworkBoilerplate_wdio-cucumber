'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _asyncbox = require('asyncbox');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _temp = require('temp');

var _temp2 = _interopRequireDefault(_temp);

var commands = {},
    extensions = {};

var RETRY_PAUSE = 1000;
var MAX_RECORDING_TIME_SEC = 60 * 3;
var DEFAULT_RECORDING_TIME_SEC = MAX_RECORDING_TIME_SEC;
var PROCESS_SHUTDOWN_TIMEOUT_SEC = 5;
var SCREENRECORD_BINARY = 'screenrecord';
var DEFAULT_EXT = '.mp4';
var MIN_EMULATOR_API_LEVEL = 27;

function extractCurrentRecordingPath(adb, pids) {
  var lsofOutput, _ref, output, pattern, matches;

  return _regeneratorRuntime.async(function extractCurrentRecordingPath$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        lsofOutput = '';
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(adb.shell(['lsof', '-p', pids.join(',')]));

      case 4:
        _ref = context$1$0.sent;
        output = _ref.output;

        lsofOutput = output;
        context$1$0.next = 13;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].warn('Cannot extract the path to the current screen capture. ' + ('Original error: ' + context$1$0.t0.message));
        return context$1$0.abrupt('return', null);

      case 13:
        _logger2['default'].debug('Got the following output from lsof: ' + lsofOutput);
        pattern = new RegExp(/\d+\s+(\/.*\.mp4)/);
        matches = pattern.exec(lsofOutput);
        return context$1$0.abrupt('return', _lodash2['default'].isEmpty(matches) ? null : _lodash2['default'].last(matches));

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 9]]);
}

function finishScreenCapture(adb, pids) {
  return _regeneratorRuntime.async(function finishScreenCapture$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(adb.shell(['kill', '-2'].concat(_toConsumableArray(pids))));

      case 3:
        context$1$0.next = 8;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);
        return context$1$0.abrupt('return', true);

      case 8:
        context$1$0.prev = 8;
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          var output, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, pid;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(adb.shell(['ps']));

              case 3:
                output = context$2$0.sent;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$2$0.prev = 7;
                _iterator = _getIterator(pids);

              case 9:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  context$2$0.next = 16;
                  break;
                }

                pid = _step.value;

                if (!new RegExp('\\b' + pid + '\\b[^\\n]+\\b' + SCREENRECORD_BINARY + '$', 'm').test(output)) {
                  context$2$0.next = 13;
                  break;
                }

                return context$2$0.abrupt('return', false);

              case 13:
                _iteratorNormalCompletion = true;
                context$2$0.next = 9;
                break;

              case 16:
                context$2$0.next = 22;
                break;

              case 18:
                context$2$0.prev = 18;
                context$2$0.t0 = context$2$0['catch'](7);
                _didIteratorError = true;
                _iteratorError = context$2$0.t0;

              case 22:
                context$2$0.prev = 22;
                context$2$0.prev = 23;

                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }

              case 25:
                context$2$0.prev = 25;

                if (!_didIteratorError) {
                  context$2$0.next = 28;
                  break;
                }

                throw _iteratorError;

              case 28:
                return context$2$0.finish(25);

              case 29:
                return context$2$0.finish(22);

              case 30:
                return context$2$0.abrupt('return', true);

              case 33:
                context$2$0.prev = 33;
                context$2$0.t1 = context$2$0['catch'](0);

                _logger2['default'].warn(context$2$0.t1.message);
                return context$2$0.abrupt('return', false);

              case 37:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[0, 33], [7, 18, 22, 30], [23,, 25, 29]]);
        }, { waitMs: PROCESS_SHUTDOWN_TIMEOUT_SEC * 1000, intervalMs: 500 }));

      case 11:
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t1 = context$1$0['catch'](8);
        return context$1$0.abrupt('return', false);

      case 16:
        return context$1$0.abrupt('return', true);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5], [8, 13]]);
}

function uploadRecordedMedia(adb, pathOnDevice) {
  var remotePath = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
  var uploadOptions = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  var localFile, _ref2, size, memoryUsage, maxMemoryLimit, content, remoteUrl, options, user, pass, method;

  return _regeneratorRuntime.async(function uploadRecordedMedia$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        localFile = _temp2['default'].path({ prefix: 'appium', suffix: DEFAULT_EXT });
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(adb.pull(pathOnDevice, localFile));

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(localFile));

      case 6:
        _ref2 = context$1$0.sent;
        size = _ref2.size;

        _logger2['default'].debug('The size of the recent screen recording is ' + _appiumSupport.util.toReadableSizeString(size));

        if (!_lodash2['default'].isEmpty(remotePath)) {
          context$1$0.next = 18;
          break;
        }

        memoryUsage = process.memoryUsage();
        maxMemoryLimit = (memoryUsage.heapTotal - memoryUsage.heapUsed) / 2;

        if (!(size >= maxMemoryLimit)) {
          context$1$0.next = 14;
          break;
        }

        throw new Error('Cannot read the recorded media \'' + pathOnDevice + '\' to the memory, ' + 'because the file is too large ' + ('(' + _appiumSupport.util.toReadableSizeString(size) + ' >= ' + _appiumSupport.util.toReadableSizeString(maxMemoryLimit) + '). ') + 'Try to provide a link to a remote writable location instead.');

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(localFile));

      case 16:
        content = context$1$0.sent;
        return context$1$0.abrupt('return', content.toString('base64'));

      case 18:
        remoteUrl = _url2['default'].parse(remotePath);
        options = {};
        user = uploadOptions.user;
        pass = uploadOptions.pass;
        method = uploadOptions.method;

        if (remoteUrl.protocol.startsWith('http')) {
          options = {
            url: remoteUrl.href,
            method: method || 'PUT',
            multipart: [{ body: _fs3['default'].createReadStream(localFile) }]
          };
          if (user && pass) {
            options.auth = { user: user, pass: pass };
          }
        } else if (remoteUrl.protocol === 'ftp') {
          options = {
            host: remoteUrl.hostname,
            port: remoteUrl.port || 21
          };
          if (user && pass) {
            options.user = user;
            options.pass = pass;
          }
        }
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.net.uploadFile(localFile, remotePath, options));

      case 26:
        return context$1$0.abrupt('return', '');

      case 27:
        context$1$0.prev = 27;
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(localFile));

      case 30:
        context$1$0.prev = 30;
        context$1$0.next = 33;
        return _regeneratorRuntime.awrap(adb.rimraf(pathOnDevice));

      case 33:
        context$1$0.next = 38;
        break;

      case 35:
        context$1$0.prev = 35;
        context$1$0.t0 = context$1$0['catch'](30);

        _logger2['default'].warn('Cannot delete the recorded screen media \'' + pathOnDevice + '\' from the device. Continuing anyway');

      case 38:
        return context$1$0.finish(27);

      case 39:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1,, 27, 39], [30, 35]]);
}

function verifyScreenRecordIsSupported(adb, isEmulator) {
  var apiLevel;
  return _regeneratorRuntime.async(function verifyScreenRecordIsSupported$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(adb.getApiLevel());

      case 2:
        apiLevel = context$1$0.sent;

        if (!(isEmulator && apiLevel < MIN_EMULATOR_API_LEVEL)) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Screen recording does not work on emulators running Android API level less than ' + MIN_EMULATOR_API_LEVEL);

      case 5:
        if (!(apiLevel < 19)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error('Screen recording not available on API Level ' + apiLevel + '. Minimum API Level is 19.');

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * @typedef {Object} StartRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the captured video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 *                                  This option only has an effect if there is screen recording process in progreess
 *                                  and `forceRestart` parameter is not set to `true`.
 * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 * @property {?string} videoSize - The format is widthxheight.
 *                  The default value is the device's native display resolution (if supported),
 *                  1280x720 if not. For best results,
 *                  use a size supported by your device's Advanced Video Coding (AVC) encoder.
 *                  For example, "1280x720"
 * @property {?boolean} bugReport - Set it to `true` in order to display additional information on the video overlay,
 *                                  such as a timestamp, that is helpful in videos captured to illustrate bugs.
 *                                  This option is only supported since API level 27 (Android P).
 * @property {?string|number} timeLimit - The maximum recording time, in seconds. The default and maximum value is 180 (3 minutes).
 * @property {?string|number} bitRate - The video bit rate for the video, in megabits per second.
 *                The default value is 4. You can increase the bit rate to improve video quality,
 *                but doing so results in larger movie files.
 * @property {?boolean} forceRestart - Whether to try to catch and upload/return the currently running screen recording
 *                                     (`false`, the default setting) or ignore the result of it and start a new recording
 *                                     immediately (`true`).
 */

/**
 * Record the display of a real devices running Android 4.4 (API level 19) and higher.
 * Emulators are supported since API level 27 (Android P).
 * It records screen activity to an MPEG-4 file. Audio is not recorded with the video file.
 * If screen recording has been already started then the command will stop it forcefully and start a new one.
 * The previously recorded video file will be deleted.
 *
 * @param {?StartRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if
 *                   any screen recording is currently running or an empty string.
 * @throws {Error} If screen recording has failed to start or is not supported on the device under test.
 */
commands.startRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var videoSize, _options$timeLimit, timeLimit, bugReport, bitRate, forceRestart, result, pids, pathOnDevice, cmd;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        videoSize = options.videoSize;
        _options$timeLimit = options.timeLimit;
        timeLimit = _options$timeLimit === undefined ? DEFAULT_RECORDING_TIME_SEC : _options$timeLimit;
        bugReport = options.bugReport;
        bitRate = options.bitRate;
        forceRestart = options.forceRestart;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(verifyScreenRecordIsSupported(this.adb, this.isEmulator()));

      case 8:
        result = '';

        if (forceRestart) {
          context$1$0.next = 13;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.stopRecordingScreen(options));

      case 12:
        result = context$1$0.sent;

      case 13:
        context$1$0.prev = 13;
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(this.adb.getPIDsByName(SCREENRECORD_BINARY));

      case 16:
        context$1$0.t0 = function (p) {
          return '' + p;
        };

        pids = context$1$0.sent.map(context$1$0.t0);

        if (_lodash2['default'].isEmpty(pids)) {
          context$1$0.next = 21;
          break;
        }

        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.adb.shell(['kill'].concat(_toConsumableArray(pids))));

      case 21:
        context$1$0.next = 26;
        break;

      case 23:
        context$1$0.prev = 23;
        context$1$0.t1 = context$1$0['catch'](13);

        _logger2['default'].errorAndThrow('Unable to stop screen recording: ' + context$1$0.t1.message);

      case 26:
        if (_lodash2['default'].isEmpty(this._recentScreenRecordingPath)) {
          context$1$0.next = 35;
          break;
        }

        context$1$0.prev = 27;
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(this.adb.rimraf(this._recentScreenRecordingPath));

      case 30:
        context$1$0.next = 34;
        break;

      case 32:
        context$1$0.prev = 32;
        context$1$0.t2 = context$1$0['catch'](27);

      case 34:
        this._recentScreenRecordingPath = null;

      case 35:
        pathOnDevice = '/sdcard/' + Math.floor(new Date()) + DEFAULT_EXT;
        cmd = [SCREENRECORD_BINARY];

        if (_appiumSupport.util.hasValue(videoSize)) {
          cmd.push('--size', videoSize);
        }
        if (_appiumSupport.util.hasValue(timeLimit)) {
          cmd.push('--time-limit', '' + timeLimit);
        }
        if (_appiumSupport.util.hasValue(bitRate)) {
          cmd.push('--bit-rate', '' + bitRate);
        }
        if (bugReport) {
          cmd.push('--bugreport');
        }
        cmd.push(pathOnDevice);

        // wrap in a manual Promise so we can handle errors in adb shell operation
        context$1$0.next = 44;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$1$0(resolve, reject) {
          var err, timeout;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            var _this2 = this;

            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                err = null;
                timeout = Math.floor(parseFloat(timeLimit) * 1000);

                if (!(timeout > MAX_RECORDING_TIME_SEC * 1000 || timeout <= 0)) {
                  context$2$0.next = 4;
                  break;
                }

                return context$2$0.abrupt('return', reject(new Error('The timeLimit value must be in range (0, ' + MAX_RECORDING_TIME_SEC + '] seconds. ' + ('The value of ' + timeLimit + ' has been passed instead.'))));

              case 4:
                _logger2['default'].debug('Beginning screen recording with command: \'adb shell ' + cmd.join(' ') + '\'' + ('Will timeout in ' + timeout / 1000 + ' s'));
                // screenrecord has its owen timer, so we only use this one as a safety precaution
                timeout += PROCESS_SHUTDOWN_TIMEOUT_SEC * 1000 * 2;
                // do not await here, as the call runs in the background and we check for its product
                this.adb.shell(cmd, { timeout: timeout, killSignal: 'SIGINT' })['catch'](function (e) {
                  err = e;
                });

                // there is the delay time to start recording the screen, so, wait until it is ready.
                // the ready condition is
                //   1. check the movie file is created
                //   2. check it is started to capture the screen
                context$2$0.prev = 7;
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(10, RETRY_PAUSE, function callee$2$0() {
                  var size;
                  return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                    while (1) switch (context$3$0.prev = context$3$0.next) {
                      case 0:
                        if (!err) {
                          context$3$0.next = 2;
                          break;
                        }

                        return context$3$0.abrupt('return');

                      case 2:
                        context$3$0.next = 4;
                        return _regeneratorRuntime.awrap(this.adb.fileSize(pathOnDevice));

                      case 4:
                        size = context$3$0.sent;

                        if (!(size <= 32)) {
                          context$3$0.next = 7;
                          break;
                        }

                        throw new Error('Remote file \'' + pathOnDevice + '\' found but it is still too small: ' + size + ' bytes');

                      case 7:
                      case 'end':
                        return context$3$0.stop();
                    }
                  }, null, _this2);
                }));

              case 10:
                context$2$0.next = 15;
                break;

              case 12:
                context$2$0.prev = 12;
                context$2$0.t0 = context$2$0['catch'](7);

                err = context$2$0.t0;

              case 15:
                if (!err) {
                  context$2$0.next = 18;
                  break;
                }

                _logger2['default'].error('Error recording screen: ' + err.message);
                return context$2$0.abrupt('return', reject(err));

              case 18:
                this._recentScreenRecordingPath = pathOnDevice;
                resolve(result);

              case 20:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[7, 12]]);
        }));

      case 44:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 45:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[13, 23], [27, 32]]);
};

/**
 * @typedef {Object} StopRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the resulting video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 * @property {?string} user - The name of the user for the remote authentication.
 * @property {?string} pass - The password for the remote authentication.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 */

/**
 * Stop recording the screen. If no screen recording process is running then
 * the endpoint will try to get the recently recorded file.
 * If no previously recorded file is found and no active screen recording
 * processes are running then the method returns an empty string.
 *
 * @param {?StopRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if 'remotePath'
 *                   parameter is empty or null or an empty string.
 * @throws {Error} If there was an error while getting the name of a media file
 *                 or the file content cannot be uploaded to the remote location
 *                 or screen recording is not supported on the device under test.
 */
commands.stopRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var remotePath, user, pass, method, pids, pathOnDevice, result;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        remotePath = options.remotePath;
        user = options.user;
        pass = options.pass;
        method = options.method;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(verifyScreenRecordIsSupported(this.adb, this.isEmulator()));

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.adb.getPIDsByName(SCREENRECORD_BINARY));

      case 8:
        context$1$0.t0 = function (p) {
          return '' + p;
        };

        pids = context$1$0.sent.map(context$1$0.t0);
        pathOnDevice = this._recentScreenRecordingPath;

        if (!_lodash2['default'].isEmpty(pids)) {
          context$1$0.next = 15;
          break;
        }

        _logger2['default'].info('Screen recording is not running. There is nothing to stop.');
        context$1$0.next = 29;
        break;

      case 15:
        context$1$0.t1 = pathOnDevice;

        if (context$1$0.t1) {
          context$1$0.next = 20;
          break;
        }

        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(extractCurrentRecordingPath(this.adb, pids));

      case 19:
        context$1$0.t1 = context$1$0.sent;

      case 20:
        pathOnDevice = context$1$0.t1;
        context$1$0.prev = 21;

        if (_lodash2['default'].isEmpty(pathOnDevice)) {
          _logger2['default'].errorAndThrow('Cannot parse the path to the file created by ' + 'screen recorder process from \'ps\' output. ' + 'Did you start screen recording before?');
        }

      case 23:
        context$1$0.prev = 23;
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(finishScreenCapture(this.adb, pids));

      case 26:
        if (context$1$0.sent) {
          context$1$0.next = 28;
          break;
        }

        _logger2['default'].warn('Unable to stop screen recording. Continuing anyway');

      case 28:
        return context$1$0.finish(23);

      case 29:
        result = '';

        if (_lodash2['default'].isEmpty(pathOnDevice)) {
          context$1$0.next = 38;
          break;
        }

        context$1$0.prev = 31;
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap(uploadRecordedMedia(this.adb, pathOnDevice, remotePath, { user: user, pass: pass, method: method }));

      case 34:
        result = context$1$0.sent;

      case 35:
        context$1$0.prev = 35;

        this._recentScreenRecordingPath = null;
        return context$1$0.finish(35);

      case 38:
        return context$1$0.abrupt('return', result);

      case 39:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[21,, 23, 29], [31,, 35, 38]]);
};

_Object$assign(extensions, commands);
exports.commands = commands;
exports['default'] = extensions;

// Wait until the process is terminated

//make adb command
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9yZWNvcmRzY3JlZW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7O21CQUNOLElBQUk7Ozs7bUJBQ0osS0FBSzs7Ozt3QkFDMkIsVUFBVTs7d0JBQzVDLFVBQVU7Ozs7NkJBQ00sZ0JBQWdCOztzQkFDOUIsV0FBVzs7OztvQkFDVixNQUFNOzs7O0FBR3ZCLElBQUksUUFBUSxHQUFHLEVBQUU7SUFBRSxVQUFVLEdBQUcsRUFBRSxDQUFDOztBQUVuQyxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDekIsSUFBTSxzQkFBc0IsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLElBQU0sMEJBQTBCLEdBQUcsc0JBQXNCLENBQUM7QUFDMUQsSUFBTSw0QkFBNEIsR0FBRyxDQUFDLENBQUM7QUFDdkMsSUFBTSxtQkFBbUIsR0FBRyxjQUFjLENBQUM7QUFDM0MsSUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDO0FBQzNCLElBQU0sc0JBQXNCLEdBQUcsRUFBRSxDQUFDOztBQUdsQyxTQUFlLDJCQUEyQixDQUFFLEdBQUcsRUFBRSxJQUFJO01BQy9DLFVBQVUsUUFFTCxNQUFNLEVBUVQsT0FBTyxFQUNQLE9BQU87Ozs7O0FBWFQsa0JBQVUsR0FBRyxFQUFFOzs7eUNBRU0sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDOzs7O0FBQXpELGNBQU0sUUFBTixNQUFNOztBQUNiLGtCQUFVLEdBQUcsTUFBTSxDQUFDOzs7Ozs7OztBQUVwQiw0QkFBSSxJQUFJLENBQUMsa0ZBQ21CLGVBQUksT0FBTyxDQUFFLENBQUMsQ0FBQzs0Q0FDcEMsSUFBSTs7O0FBRWIsNEJBQUksS0FBSywwQ0FBd0MsVUFBVSxDQUFHLENBQUM7QUFDekQsZUFBTyxHQUFHLElBQUksTUFBTSxDQUFDLG1CQUFtQixD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O0FBQTVGLGNBQU07Ozs7O0FBRU4sWUFBSSxDQUFDLDBCQUEwQixHQUFHLElBQUksQ0FBQzs7Ozs0Q0FHcEMsTUFBTTs7Ozs7OztDQUNkLENBQUM7O0FBR0YsZUFBYyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDM0IsUUFBUSxHQUFSLFFBQVE7cUJBQ0YsVUFBVSIsImZpbGUiOiJsaWIvY29tbWFuZHMvcmVjb3Jkc2NyZWVuLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBfZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IHsgcmV0cnlJbnRlcnZhbCwgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHV0aWwsIGZzLCBuZXQgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgdGVtcCBmcm9tICd0ZW1wJztcblxuXG5sZXQgY29tbWFuZHMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9O1xuXG5jb25zdCBSRVRSWV9QQVVTRSA9IDEwMDA7XG5jb25zdCBNQVhfUkVDT1JESU5HX1RJTUVfU0VDID0gNjAgKiAzO1xuY29uc3QgREVGQVVMVF9SRUNPUkRJTkdfVElNRV9TRUMgPSBNQVhfUkVDT1JESU5HX1RJTUVfU0VDO1xuY29uc3QgUFJPQ0VTU19TSFVURE9XTl9USU1FT1VUX1NFQyA9IDU7XG5jb25zdCBTQ1JFRU5SRUNPUkRfQklOQVJZID0gJ3NjcmVlbnJlY29yZCc7XG5jb25zdCBERUZBVUxUX0VYVCA9ICcubXA0JztcbmNvbnN0IE1JTl9FTVVMQVRPUl9BUElfTEVWRUwgPSAyNztcblxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0Q3VycmVudFJlY29yZGluZ1BhdGggKGFkYiwgcGlkcykge1xuICBsZXQgbHNvZk91dHB1dCA9ICcnO1xuICB0cnkge1xuICAgIGNvbnN0IHtvdXRwdXR9ID0gYXdhaXQgYWRiLnNoZWxsKFsnbHNvZicsICctcCcsIHBpZHMuam9pbignLCcpXSk7XG4gICAgbHNvZk91dHB1dCA9IG91dHB1dDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYENhbm5vdCBleHRyYWN0IHRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IHNjcmVlbiBjYXB0dXJlLiBgICtcbiAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbG9nLmRlYnVnKGBHb3QgdGhlIGZvbGxvd2luZyBvdXRwdXQgZnJvbSBsc29mOiAke2xzb2ZPdXRwdXR9YCk7XG4gIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKC9cXGQrXFxzKyhcXC8uKlxcLm1wNCkvKTtcbiAgY29uc3QgbWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhsc29mT3V0cHV0KTtcbiAgcmV0dXJuIF8uaXNFbXB0eShtYXRjaGVzKSA/IG51bGwgOiBfLmxhc3QobWF0Y2hlcyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbmlzaFNjcmVlbkNhcHR1cmUgKGFkYiwgcGlkcykge1xuICB0cnkge1xuICAgIGF3YWl0IGFkYi5zaGVsbChbJ2tpbGwnLCAnLTInLCAuLi5waWRzXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFdhaXQgdW50aWwgdGhlIHByb2Nlc3MgaXMgdGVybWluYXRlZFxuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgYWRiLnNoZWxsKFsncHMnXSk7XG4gICAgICAgIGZvciAoY29uc3QgcGlkIG9mIHBpZHMpIHtcbiAgICAgICAgICBpZiAobmV3IFJlZ0V4cChgXFxcXGIke3BpZH1cXFxcYlteXFxcXG5dK1xcXFxiJHtTQ1JFRU5SRUNPUkRfQklOQVJZfSRgLCAnbScpLnRlc3Qob3V0cHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cud2FybihlcnIubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7d2FpdE1zOiBQUk9DRVNTX1NIVVRET1dOX1RJTUVPVVRfU0VDICogMTAwMCwgaW50ZXJ2YWxNczogNTAwfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZFJlY29yZGVkTWVkaWEgKGFkYiwgcGF0aE9uRGV2aWNlLCByZW1vdGVQYXRoID0gbnVsbCwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGxvY2FsRmlsZSA9IHRlbXAucGF0aCh7cHJlZml4OiAnYXBwaXVtJywgc3VmZml4OiBERUZBVUxUX0VYVH0pO1xuICB0cnkge1xuICAgIGF3YWl0IGFkYi5wdWxsKHBhdGhPbkRldmljZSwgbG9jYWxGaWxlKTtcblxuICAgIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQobG9jYWxGaWxlKTtcbiAgICBsb2cuZGVidWcoYFRoZSBzaXplIG9mIHRoZSByZWNlbnQgc2NyZWVuIHJlY29yZGluZyBpcyAke3V0aWwudG9SZWFkYWJsZVNpemVTdHJpbmcoc2l6ZSl9YCk7XG4gICAgaWYgKF8uaXNFbXB0eShyZW1vdGVQYXRoKSkge1xuICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICBjb25zdCBtYXhNZW1vcnlMaW1pdCA9IChtZW1vcnlVc2FnZS5oZWFwVG90YWwgLSBtZW1vcnlVc2FnZS5oZWFwVXNlZCkgLyAyO1xuICAgICAgaWYgKHNpemUgPj0gbWF4TWVtb3J5TGltaXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVhZCB0aGUgcmVjb3JkZWQgbWVkaWEgJyR7cGF0aE9uRGV2aWNlfScgdG8gdGhlIG1lbW9yeSwgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgYmVjYXVzZSB0aGUgZmlsZSBpcyB0b28gbGFyZ2UgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7dXRpbC50b1JlYWRhYmxlU2l6ZVN0cmluZyhzaXplKX0gPj0gJHt1dGlsLnRvUmVhZGFibGVTaXplU3RyaW5nKG1heE1lbW9yeUxpbWl0KX0pLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBUcnkgdG8gcHJvdmlkZSBhIGxpbmsgdG8gYSByZW1vdGUgd3JpdGFibGUgbG9jYXRpb24gaW5zdGVhZC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShsb2NhbEZpbGUpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbW90ZVVybCA9IHVybC5wYXJzZShyZW1vdGVQYXRoKTtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IHt1c2VyLCBwYXNzLCBtZXRob2R9ID0gdXBsb2FkT3B0aW9ucztcbiAgICBpZiAocmVtb3RlVXJsLnByb3RvY29sLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgdXJsOiByZW1vdGVVcmwuaHJlZixcbiAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BVVCcsXG4gICAgICAgIG11bHRpcGFydDogW3sgYm9keTogX2ZzLmNyZWF0ZVJlYWRTdHJlYW0obG9jYWxGaWxlKSB9XSxcbiAgICAgIH07XG4gICAgICBpZiAodXNlciAmJiBwYXNzKSB7XG4gICAgICAgIG9wdGlvbnMuYXV0aCA9IHt1c2VyLCBwYXNzfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlbW90ZVVybC5wcm90b2NvbCA9PT0gJ2Z0cCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGhvc3Q6IHJlbW90ZVVybC5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogcmVtb3RlVXJsLnBvcnQgfHwgMjEsXG4gICAgICB9O1xuICAgICAgaWYgKHVzZXIgJiYgcGFzcykge1xuICAgICAgICBvcHRpb25zLnVzZXIgPSB1c2VyO1xuICAgICAgICBvcHRpb25zLnBhc3MgPSBwYXNzO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBuZXQudXBsb2FkRmlsZShsb2NhbEZpbGUsIHJlbW90ZVBhdGgsIG9wdGlvbnMpO1xuICAgIHJldHVybiAnJztcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYobG9jYWxGaWxlKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYWRiLnJpbXJhZihwYXRoT25EZXZpY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy53YXJuKGBDYW5ub3QgZGVsZXRlIHRoZSByZWNvcmRlZCBzY3JlZW4gbWVkaWEgJyR7cGF0aE9uRGV2aWNlfScgZnJvbSB0aGUgZGV2aWNlLiBDb250aW51aW5nIGFueXdheWApO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlTY3JlZW5SZWNvcmRJc1N1cHBvcnRlZCAoYWRiLCBpc0VtdWxhdG9yKSB7XG4gIGNvbnN0IGFwaUxldmVsID0gYXdhaXQgYWRiLmdldEFwaUxldmVsKCk7XG4gIGlmIChpc0VtdWxhdG9yICYmIGFwaUxldmVsIDwgTUlOX0VNVUxBVE9SX0FQSV9MRVZFTCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2NyZWVuIHJlY29yZGluZyBkb2VzIG5vdCB3b3JrIG9uIGVtdWxhdG9ycyBydW5uaW5nIEFuZHJvaWQgQVBJIGxldmVsIGxlc3MgdGhhbiAke01JTl9FTVVMQVRPUl9BUElfTEVWRUx9YCk7XG4gIH1cbiAgaWYgKGFwaUxldmVsIDwgMTkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNjcmVlbiByZWNvcmRpbmcgbm90IGF2YWlsYWJsZSBvbiBBUEkgTGV2ZWwgJHthcGlMZXZlbH0uIE1pbmltdW0gQVBJIExldmVsIGlzIDE5LmApO1xuICB9XG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGFydFJlY29yZGluZ09wdGlvbnNcbiAqXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byB0aGUgcmVtb3RlIGxvY2F0aW9uLCB3aGVyZSB0aGUgY2FwdHVyZWQgdmlkZW8gc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGZvbGxvd2luZyBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZDogaHR0cC9odHRwcywgZnRwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVsbCBvciBlbXB0eSBzdHJpbmcgdmFsdWUgKHRoZSBkZWZhdWx0IHNldHRpbmcpIG1lYW5zIHRoZSBjb250ZW50IG9mIHJlc3VsdGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSBzaG91bGQgYmUgZW5jb2RlZCBhcyBCYXNlNjQgYW5kIHBhc3NlZCBhcyB0aGUgZW5kcG91bnQgcmVzcG9uc2UgdmFsdWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gaWYgdGhlIGdlbmVyYXRlZCBtZWRpYSBmaWxlIGlzIHRvbyBiaWcgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpdCBpbnRvIHRoZSBhdmFpbGFibGUgcHJvY2VzcyBtZW1vcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9wdGlvbiBvbmx5IGhhcyBhbiBlZmZlY3QgaWYgdGhlcmUgaXMgc2NyZWVuIHJlY29yZGluZyBwcm9jZXNzIGluIHByb2dyZWVzc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGBmb3JjZVJlc3RhcnRgIHBhcmFtZXRlciBpcyBub3Qgc2V0IHRvIGB0cnVlYC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdXNlciAtIFRoZSBuYW1lIG9mIHRoZSB1c2VyIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLiBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcGFzcyAtIFRoZSBwYXNzd29yZCBmb3IgdGhlIHJlbW90ZSBhdXRoZW50aWNhdGlvbi4gT25seSB3b3JrcyBpZiBgcmVtb3RlUGF0aGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG1ldGhvZCAtIFRoZSBodHRwIG11bHRpcGFydCB1cGxvYWQgbWV0aG9kIG5hbWUuIFRoZSAnUFVUJyBvbmUgaXMgdXNlZCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdmlkZW9TaXplIC0gVGhlIGZvcm1hdCBpcyB3aWR0aHhoZWlnaHQuXG4gKiAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBkZXZpY2UncyBuYXRpdmUgZGlzcGxheSByZXNvbHV0aW9uIChpZiBzdXBwb3J0ZWQpLFxuICogICAgICAgICAgICAgICAgICAxMjgweDcyMCBpZiBub3QuIEZvciBiZXN0IHJlc3VsdHMsXG4gKiAgICAgICAgICAgICAgICAgIHVzZSBhIHNpemUgc3VwcG9ydGVkIGJ5IHlvdXIgZGV2aWNlJ3MgQWR2YW5jZWQgVmlkZW8gQ29kaW5nIChBVkMpIGVuY29kZXIuXG4gKiAgICAgICAgICAgICAgICAgIEZvciBleGFtcGxlLCBcIjEyODB4NzIwXCJcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGJ1Z1JlcG9ydCAtIFNldCBpdCB0byBgdHJ1ZWAgaW4gb3JkZXIgdG8gZGlzcGxheSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9uIHRoZSB2aWRlbyBvdmVybGF5LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjaCBhcyBhIHRpbWVzdGFtcCwgdGhhdCBpcyBoZWxwZnVsIGluIHZpZGVvcyBjYXB0dXJlZCB0byBpbGx1c3RyYXRlIGJ1Z3MuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBzaW5jZSBBUEkgbGV2ZWwgMjcgKEFuZHJvaWQgUCkuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd8bnVtYmVyfSB0aW1lTGltaXQgLSBUaGUgbWF4aW11bSByZWNvcmRpbmcgdGltZSwgaW4gc2Vjb25kcy4gVGhlIGRlZmF1bHQgYW5kIG1heGltdW0gdmFsdWUgaXMgMTgwICgzIG1pbnV0ZXMpLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfG51bWJlcn0gYml0UmF0ZSAtIFRoZSB2aWRlbyBiaXQgcmF0ZSBmb3IgdGhlIHZpZGVvLCBpbiBtZWdhYml0cyBwZXIgc2Vjb25kLlxuICogICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgNC4gWW91IGNhbiBpbmNyZWFzZSB0aGUgYml0IHJhdGUgdG8gaW1wcm92ZSB2aWRlbyBxdWFsaXR5LFxuICogICAgICAgICAgICAgICAgYnV0IGRvaW5nIHNvIHJlc3VsdHMgaW4gbGFyZ2VyIG1vdmllIGZpbGVzLlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZm9yY2VSZXN0YXJ0IC0gV2hldGhlciB0byB0cnkgdG8gY2F0Y2ggYW5kIHVwbG9hZC9yZXR1cm4gdGhlIGN1cnJlbnRseSBydW5uaW5nIHNjcmVlbiByZWNvcmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChgZmFsc2VgLCB0aGUgZGVmYXVsdCBzZXR0aW5nKSBvciBpZ25vcmUgdGhlIHJlc3VsdCBvZiBpdCBhbmQgc3RhcnQgYSBuZXcgcmVjb3JkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVseSAoYHRydWVgKS5cbiAqL1xuXG4vKipcbiAqIFJlY29yZCB0aGUgZGlzcGxheSBvZiBhIHJlYWwgZGV2aWNlcyBydW5uaW5nIEFuZHJvaWQgNC40IChBUEkgbGV2ZWwgMTkpIGFuZCBoaWdoZXIuXG4gKiBFbXVsYXRvcnMgYXJlIHN1cHBvcnRlZCBzaW5jZSBBUEkgbGV2ZWwgMjcgKEFuZHJvaWQgUCkuXG4gKiBJdCByZWNvcmRzIHNjcmVlbiBhY3Rpdml0eSB0byBhbiBNUEVHLTQgZmlsZS4gQXVkaW8gaXMgbm90IHJlY29yZGVkIHdpdGggdGhlIHZpZGVvIGZpbGUuXG4gKiBJZiBzY3JlZW4gcmVjb3JkaW5nIGhhcyBiZWVuIGFscmVhZHkgc3RhcnRlZCB0aGVuIHRoZSBjb21tYW5kIHdpbGwgc3RvcCBpdCBmb3JjZWZ1bGx5IGFuZCBzdGFydCBhIG5ldyBvbmUuXG4gKiBUaGUgcHJldmlvdXNseSByZWNvcmRlZCB2aWRlbyBmaWxlIHdpbGwgYmUgZGVsZXRlZC5cbiAqXG4gKiBAcGFyYW0gez9TdGFydFJlY29yZGluZ09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgYXZhaWxhYmxlIG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQtZW5jb2RlZCBjb250ZW50IG9mIHRoZSByZWNvcmRlZCBtZWRpYSBmaWxlIGlmXG4gKiAgICAgICAgICAgICAgICAgICBhbnkgc2NyZWVuIHJlY29yZGluZyBpcyBjdXJyZW50bHkgcnVubmluZyBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc2NyZWVuIHJlY29yZGluZyBoYXMgZmFpbGVkIHRvIHN0YXJ0IG9yIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICovXG5jb21tYW5kcy5zdGFydFJlY29yZGluZ1NjcmVlbiA9IGFzeW5jIGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge3ZpZGVvU2l6ZSwgdGltZUxpbWl0PURFRkFVTFRfUkVDT1JESU5HX1RJTUVfU0VDLCBidWdSZXBvcnQsIGJpdFJhdGUsIGZvcmNlUmVzdGFydH0gPSBvcHRpb25zO1xuXG4gIGF3YWl0IHZlcmlmeVNjcmVlblJlY29yZElzU3VwcG9ydGVkKHRoaXMuYWRiLCB0aGlzLmlzRW11bGF0b3IoKSk7XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBpZiAoIWZvcmNlUmVzdGFydCkge1xuICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuc3RvcFJlY29yZGluZ1NjcmVlbihvcHRpb25zKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHBpZHMgPSAoYXdhaXQgdGhpcy5hZGIuZ2V0UElEc0J5TmFtZShTQ1JFRU5SRUNPUkRfQklOQVJZKSkubWFwKChwKSA9PiBgJHtwfWApO1xuICAgIGlmICghXy5pc0VtcHR5KHBpZHMpKSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYi5zaGVsbChbJ2tpbGwnLCAuLi5waWRzXSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVW5hYmxlIHRvIHN0b3Agc2NyZWVuIHJlY29yZGluZzogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuICBpZiAoIV8uaXNFbXB0eSh0aGlzLl9yZWNlbnRTY3JlZW5SZWNvcmRpbmdQYXRoKSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYi5yaW1yYWYodGhpcy5fcmVjZW50U2NyZWVuUmVjb3JkaW5nUGF0aCk7XG4gICAgfSBjYXRjaCAoaWduKSB7fVxuICAgIHRoaXMuX3JlY2VudFNjcmVlblJlY29yZGluZ1BhdGggPSBudWxsO1xuICB9XG5cbiAgY29uc3QgcGF0aE9uRGV2aWNlID0gYC9zZGNhcmQvJHtNYXRoLmZsb29yKG5ldyBEYXRlKCkpfSR7REVGQVVMVF9FWFR9YDtcblxuICAvL21ha2UgYWRiIGNvbW1hbmRcbiAgY29uc3QgY21kID0gW1NDUkVFTlJFQ09SRF9CSU5BUlldO1xuICBpZiAodXRpbC5oYXNWYWx1ZSh2aWRlb1NpemUpKSB7XG4gICAgY21kLnB1c2goJy0tc2l6ZScsIHZpZGVvU2l6ZSk7XG4gIH1cbiAgaWYgKHV0aWwuaGFzVmFsdWUodGltZUxpbWl0KSkge1xuICAgIGNtZC5wdXNoKCctLXRpbWUtbGltaXQnLCBgJHt0aW1lTGltaXR9YCk7XG4gIH1cbiAgaWYgKHV0aWwuaGFzVmFsdWUoYml0UmF0ZSkpIHtcbiAgICBjbWQucHVzaCgnLS1iaXQtcmF0ZScsIGAke2JpdFJhdGV9YCk7XG4gIH1cbiAgaWYgKGJ1Z1JlcG9ydCkge1xuICAgIGNtZC5wdXNoKCctLWJ1Z3JlcG9ydCcpO1xuICB9XG4gIGNtZC5wdXNoKHBhdGhPbkRldmljZSk7XG5cbiAgLy8gd3JhcCBpbiBhIG1hbnVhbCBQcm9taXNlIHNvIHdlIGNhbiBoYW5kbGUgZXJyb3JzIGluIGFkYiBzaGVsbCBvcGVyYXRpb25cbiAgcmV0dXJuIGF3YWl0IG5ldyBCKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgdGltZW91dCA9IE1hdGguZmxvb3IocGFyc2VGbG9hdCh0aW1lTGltaXQpICogMTAwMCk7XG4gICAgaWYgKHRpbWVvdXQgPiBNQVhfUkVDT1JESU5HX1RJTUVfU0VDICogMTAwMCB8fCB0aW1lb3V0IDw9IDApIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBUaGUgdGltZUxpbWl0IHZhbHVlIG11c3QgYmUgaW4gcmFuZ2UgKDAsICR7TUFYX1JFQ09SRElOR19USU1FX1NFQ31dIHNlY29uZHMuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFRoZSB2YWx1ZSBvZiAke3RpbWVMaW1pdH0gaGFzIGJlZW4gcGFzc2VkIGluc3RlYWQuYCkpO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYEJlZ2lubmluZyBzY3JlZW4gcmVjb3JkaW5nIHdpdGggY29tbWFuZDogJ2FkYiBzaGVsbCAke2NtZC5qb2luKCcgJyl9J2AgK1xuICAgICAgICAgICAgICBgV2lsbCB0aW1lb3V0IGluICR7dGltZW91dCAvIDEwMDB9IHNgKTtcbiAgICAvLyBzY3JlZW5yZWNvcmQgaGFzIGl0cyBvd2VuIHRpbWVyLCBzbyB3ZSBvbmx5IHVzZSB0aGlzIG9uZSBhcyBhIHNhZmV0eSBwcmVjYXV0aW9uXG4gICAgdGltZW91dCArPSBQUk9DRVNTX1NIVVRET1dOX1RJTUVPVVRfU0VDICogMTAwMCAqIDI7XG4gICAgLy8gZG8gbm90IGF3YWl0IGhlcmUsIGFzIHRoZSBjYWxsIHJ1bnMgaW4gdGhlIGJhY2tncm91bmQgYW5kIHdlIGNoZWNrIGZvciBpdHMgcHJvZHVjdFxuICAgIHRoaXMuYWRiLnNoZWxsKGNtZCwge3RpbWVvdXQsIGtpbGxTaWduYWw6ICdTSUdJTlQnfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIGVyciA9IGU7XG4gICAgfSk7XG5cbiAgICAvLyB0aGVyZSBpcyB0aGUgZGVsYXkgdGltZSB0byBzdGFydCByZWNvcmRpbmcgdGhlIHNjcmVlbiwgc28sIHdhaXQgdW50aWwgaXQgaXMgcmVhZHkuXG4gICAgLy8gdGhlIHJlYWR5IGNvbmRpdGlvbiBpc1xuICAgIC8vICAgMS4gY2hlY2sgdGhlIG1vdmllIGZpbGUgaXMgY3JlYXRlZFxuICAgIC8vICAgMi4gY2hlY2sgaXQgaXMgc3RhcnRlZCB0byBjYXB0dXJlIHRoZSBzY3JlZW5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmV0cnlJbnRlcnZhbCgxMCwgUkVUUllfUEFVU0UsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNpemUgPSBhd2FpdCB0aGlzLmFkYi5maWxlU2l6ZShwYXRoT25EZXZpY2UpO1xuICAgICAgICBpZiAoc2l6ZSA8PSAzMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtb3RlIGZpbGUgJyR7cGF0aE9uRGV2aWNlfScgZm91bmQgYnV0IGl0IGlzIHN0aWxsIHRvbyBzbWFsbDogJHtzaXplfSBieXRlc2ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihgRXJyb3IgcmVjb3JkaW5nIHNjcmVlbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICB9XG4gICAgdGhpcy5fcmVjZW50U2NyZWVuUmVjb3JkaW5nUGF0aCA9IHBhdGhPbkRldmljZTtcbiAgICByZXNvbHZlKHJlc3VsdCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdG9wUmVjb3JkaW5nT3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIHRoZSByZW1vdGUgbG9jYXRpb24sIHdoZXJlIHRoZSByZXN1bHRpbmcgdmlkZW8gc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGZvbGxvd2luZyBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZDogaHR0cC9odHRwcywgZnRwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVsbCBvciBlbXB0eSBzdHJpbmcgdmFsdWUgKHRoZSBkZWZhdWx0IHNldHRpbmcpIG1lYW5zIHRoZSBjb250ZW50IG9mIHJlc3VsdGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSBzaG91bGQgYmUgZW5jb2RlZCBhcyBCYXNlNjQgYW5kIHBhc3NlZCBhcyB0aGUgZW5kcG91bnQgcmVzcG9uc2UgdmFsdWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gaWYgdGhlIGdlbmVyYXRlZCBtZWRpYSBmaWxlIGlzIHRvbyBiaWcgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpdCBpbnRvIHRoZSBhdmFpbGFibGUgcHJvY2VzcyBtZW1vcnkuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHVzZXIgLSBUaGUgbmFtZSBvZiB0aGUgdXNlciBmb3IgdGhlIHJlbW90ZSBhdXRoZW50aWNhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcGFzcyAtIFRoZSBwYXNzd29yZCBmb3IgdGhlIHJlbW90ZSBhdXRoZW50aWNhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbWV0aG9kIC0gVGhlIGh0dHAgbXVsdGlwYXJ0IHVwbG9hZCBtZXRob2QgbmFtZS4gVGhlICdQVVQnIG9uZSBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLyoqXG4gKiBTdG9wIHJlY29yZGluZyB0aGUgc2NyZWVuLiBJZiBubyBzY3JlZW4gcmVjb3JkaW5nIHByb2Nlc3MgaXMgcnVubmluZyB0aGVuXG4gKiB0aGUgZW5kcG9pbnQgd2lsbCB0cnkgdG8gZ2V0IHRoZSByZWNlbnRseSByZWNvcmRlZCBmaWxlLlxuICogSWYgbm8gcHJldmlvdXNseSByZWNvcmRlZCBmaWxlIGlzIGZvdW5kIGFuZCBubyBhY3RpdmUgc2NyZWVuIHJlY29yZGluZ1xuICogcHJvY2Vzc2VzIGFyZSBydW5uaW5nIHRoZW4gdGhlIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gez9TdG9wUmVjb3JkaW5nT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIGNvbnRlbnQgb2YgdGhlIHJlY29yZGVkIG1lZGlhIGZpbGUgaWYgJ3JlbW90ZVBhdGgnXG4gKiAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIgaXMgZW1wdHkgb3IgbnVsbCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhlIG5hbWUgb2YgYSBtZWRpYSBmaWxlXG4gKiAgICAgICAgICAgICAgICAgb3IgdGhlIGZpbGUgY29udGVudCBjYW5ub3QgYmUgdXBsb2FkZWQgdG8gdGhlIHJlbW90ZSBsb2NhdGlvblxuICogICAgICAgICAgICAgICAgIG9yIHNjcmVlbiByZWNvcmRpbmcgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbmNvbW1hbmRzLnN0b3BSZWNvcmRpbmdTY3JlZW4gPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtyZW1vdGVQYXRoLCB1c2VyLCBwYXNzLCBtZXRob2R9ID0gb3B0aW9ucztcblxuICBhd2FpdCB2ZXJpZnlTY3JlZW5SZWNvcmRJc1N1cHBvcnRlZCh0aGlzLmFkYiwgdGhpcy5pc0VtdWxhdG9yKCkpO1xuXG4gIGNvbnN0IHBpZHMgPSAoYXdhaXQgdGhpcy5hZGIuZ2V0UElEc0J5TmFtZShTQ1JFRU5SRUNPUkRfQklOQVJZKSkubWFwKChwKSA9PiBgJHtwfWApO1xuICBsZXQgcGF0aE9uRGV2aWNlID0gdGhpcy5fcmVjZW50U2NyZWVuUmVjb3JkaW5nUGF0aDtcbiAgaWYgKF8uaXNFbXB0eShwaWRzKSkge1xuICAgIGxvZy5pbmZvKGBTY3JlZW4gcmVjb3JkaW5nIGlzIG5vdCBydW5uaW5nLiBUaGVyZSBpcyBub3RoaW5nIHRvIHN0b3AuYCk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aE9uRGV2aWNlID0gcGF0aE9uRGV2aWNlIHx8IGF3YWl0IGV4dHJhY3RDdXJyZW50UmVjb3JkaW5nUGF0aCh0aGlzLmFkYiwgcGlkcyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfLmlzRW1wdHkocGF0aE9uRGV2aWNlKSkge1xuICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ2Fubm90IHBhcnNlIHRoZSBwYXRoIHRvIHRoZSBmaWxlIGNyZWF0ZWQgYnkgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGBzY3JlZW4gcmVjb3JkZXIgcHJvY2VzcyBmcm9tICdwcycgb3V0cHV0LiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYERpZCB5b3Ugc3RhcnQgc2NyZWVuIHJlY29yZGluZyBiZWZvcmU/YCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghYXdhaXQgZmluaXNoU2NyZWVuQ2FwdHVyZSh0aGlzLmFkYiwgcGlkcykpIHtcbiAgICAgICAgbG9nLndhcm4oYFVuYWJsZSB0byBzdG9wIHNjcmVlbiByZWNvcmRpbmcuIENvbnRpbnVpbmcgYW55d2F5YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBpZiAoIV8uaXNFbXB0eShwYXRoT25EZXZpY2UpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHVwbG9hZFJlY29yZGVkTWVkaWEodGhpcy5hZGIsIHBhdGhPbkRldmljZSwgcmVtb3RlUGF0aCwge3VzZXIsIHBhc3MsIG1ldGhvZH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9yZWNlbnRTY3JlZW5SZWNvcmRpbmdQYXRoID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuT2JqZWN0LmFzc2lnbihleHRlbnNpb25zLCBjb21tYW5kcyk7XG5leHBvcnQgeyBjb21tYW5kcyB9O1xuZXhwb3J0IGRlZmF1bHQgZXh0ZW5zaW9ucztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
