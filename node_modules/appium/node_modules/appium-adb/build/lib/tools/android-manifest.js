'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _teen_process = require('teen_process');

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _helpersJs = require('../helpers.js');

var _appiumSupport = require('appium-support');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _xmldom = require('xmldom');

var _xmldom2 = _interopRequireDefault(_xmldom);

var _xpath = require('xpath');

var _xpath2 = _interopRequireDefault(_xpath);

var manifestMethods = {};

// android:process= may be defined in AndroidManifest.xml
// http://developer.android.com/reference/android/R.attr.html#process
// note that the process name when used with ps must be truncated to the last 15 chars
// ps -c com.example.android.apis becomes ps -c le.android.apis
manifestMethods.processFromManifest = function callee$0$0(localApk) {
  var args, _ref, stdout, result, lines, applicationRegex, applicationFound, attributeRegex, processRegex, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, notAttribute, _process;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 2:
        _loggerJs2['default'].info("Retrieving process from manifest");
        args = ['dump', 'xmltree', localApk, 'AndroidManifest.xml'];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, args));

      case 6:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        result = null;
        lines = stdout.split("\n");
        applicationRegex = new RegExp(/\s+E: application \(line=\d+\).*/);
        applicationFound = false;
        attributeRegex = new RegExp(/\s+A: .+/);
        processRegex = new RegExp(/\s+A: android:process\(0x01010011\)="([^"]+).*"/);
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 17;
        _iterator = _getIterator(lines);

      case 19:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 36;
          break;
        }

        line = _step.value;

        if (applicationFound) {
          context$1$0.next = 25;
          break;
        }

        if (applicationRegex.test(line)) {
          applicationFound = true;
        }
        context$1$0.next = 33;
        break;

      case 25:
        notAttribute = !attributeRegex.test(line);

        if (!notAttribute) {
          context$1$0.next = 28;
          break;
        }

        return context$1$0.abrupt('break', 36);

      case 28:
        _process = processRegex.exec(line);

        if (!(_process && _process.length > 1)) {
          context$1$0.next = 33;
          break;
        }

        result = _process[1];
        // must trim to last 15 for android's ps binary
        if (result.length > 15) {
          result = result.substr(result.length - 15);
        }
        return context$1$0.abrupt('break', 36);

      case 33:
        _iteratorNormalCompletion = true;
        context$1$0.next = 19;
        break;

      case 36:
        context$1$0.next = 42;
        break;

      case 38:
        context$1$0.prev = 38;
        context$1$0.t0 = context$1$0['catch'](17);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 42:
        context$1$0.prev = 42;
        context$1$0.prev = 43;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 45:
        context$1$0.prev = 45;

        if (!_didIteratorError) {
          context$1$0.next = 48;
          break;
        }

        throw _iteratorError;

      case 48:
        return context$1$0.finish(45);

      case 49:
        return context$1$0.finish(42);

      case 50:
        return context$1$0.abrupt('return', result);

      case 51:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[17, 38, 42, 50], [43,, 45, 49]]);
};

/**
 * @typedef {Object} APKInfo
 * @property {string} apkPackage - The name of application package, for example 'com.acme.app'.
 * @property {string} apkActivity - The name of main application activity.
 */

/**
* Extract package and main activity name from application manifest using
* the custom apk tools.
*
* @param {string} localApk - The full path to application package.
* @param {string} aaptPath - The full path to appt binary.
* @param {string} jarPath - The full path to appium_apk_tools.jar utility
* @param {string} tmpRoot - The full path to the class-wide temporary folder.
* @return {APKInfo} The parsed application info.
* @throws {Error} If there was an error while getting the data from the given
*                 application package.
*/
function extractApkInfoWithApkTools(localApk, aaptPath, jarPath, tmpRoot) {
  var args, stdout, apkPackage, apkActivity, outputPath, getLaunchActivity, output, act;
  return _regeneratorRuntime.async(function extractApkInfoWithApkTools$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info("Extracting package and launch activity from manifest");
        args = ['dump', 'badging', localApk];
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(aaptPath, args));

      case 4:
        stdout = context$1$0.sent.stdout;
        apkPackage = new RegExp(/package: name='([^']+)'/g).exec(stdout);

        if (!(!apkPackage || apkPackage.length < 2)) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Cannot parse package name from ' + ('\'' + _lodash2['default'].join([aaptPath, 'dump', 'badging', '"' + localApk + '"'], ' ') + '\' command  output'));

      case 8:
        apkPackage = apkPackage[1];
        apkActivity = new RegExp(/launchable-activity: name='([^']+)'/g).exec(stdout);

        if (!(apkActivity && apkActivity.length >= 2)) {
          context$1$0.next = 13;
          break;
        }

        apkActivity = apkActivity[1];
        return context$1$0.abrupt('return', { apkPackage: apkPackage, apkActivity: apkActivity });

      case 13:
        outputPath = _path2['default'].resolve(tmpRoot, apkPackage);
        getLaunchActivity = ['-jar', jarPath, 'printLaunchActivity', localApk, outputPath];
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('java', getLaunchActivity));

      case 17:
        output = context$1$0.sent;

        if (!output.stderr) {
          context$1$0.next = 20;
          break;
        }

        throw new Error('Cannot parse launchActivity from manifest: ' + output.stderr);

      case 20:
        stdout = output.stdout;
        act = new RegExp(/Launch activity parsed:([^']+)/g).exec(stdout);

        if (!(act && act.length >= 2)) {
          context$1$0.next = 25;
          break;
        }

        apkActivity = act[1];
        return context$1$0.abrupt('return', { apkPackage: apkPackage, apkActivity: apkActivity });

      case 25:
        throw new Error('Cannot parse main activity name from \'' + stdout + '\' command  output');

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Extract package and main activity name from application manifest using
 * apkanalyzer tool.
 *
 * @param {string} localApk - The full path to application package.
 * @param {string} apkanalyzerPath - The full path to apkanalyzer tool.
 * @return {APKInfo} The parsed application info.
 * @throws {Error} If there was an error while getting the data from the given
 *                 application package or if the tool itself
 *                 is not present on the local file system.
 */
function extractApkInfoWithApkanalyzer(localApk, apkanalyzerPath) {
  var args, manifestXml, doc, apkPackageAttribute, apkPackage, apkActivityAttribute, apkActivity;
  return _regeneratorRuntime.async(function extractApkInfoWithApkanalyzer$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['-h', 'manifest', 'print', localApk];

        _loggerJs2['default'].debug('Starting \'' + apkanalyzerPath + '\' with args ' + JSON.stringify(args));
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(apkanalyzerPath, args, {
          shell: true,
          cwd: _path2['default'].dirname(apkanalyzerPath)
        }));

      case 4:
        manifestXml = context$1$0.sent.stdout;
        doc = new _xmldom2['default'].DOMParser().parseFromString(manifestXml);
        apkPackageAttribute = _xpath2['default'].select1('//manifest/@package', doc);

        if (apkPackageAttribute) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Cannot parse package name from ' + manifestXml);

      case 9:
        apkPackage = apkPackageAttribute.value;
        apkActivityAttribute = _xpath2['default'].select1("//application/*[starts-with(name(), 'activity') " + "and .//action[@*[local-name()='name' and .='android.intent.action.MAIN']] " + "and .//category[@*[local-name()='name' and .='android.intent.category.LAUNCHER']]]" + "/@*[local-name()='name']", doc);

        if (apkActivityAttribute) {
          context$1$0.next = 13;
          break;
        }

        throw new Error('Cannot parse main activity name from ' + manifestXml);

      case 13:
        apkActivity = apkActivityAttribute.value;
        return context$1$0.abrupt('return', { apkPackage: apkPackage, apkActivity: apkActivity });

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Extract package and main activity name from application manifest.
 *
 * @param {string} localApk - The full path to application package.
 * @return {APKInfo} The parsed application info.
 * @throws {error} If there was an error while getting the data from the given
 *                 application package.
 */
manifestMethods.packageAndLaunchActivityFromManifest = function callee$0$0(localApk) {
  var apkInfoGetters, savedError, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, infoGetter, _ref2, apkPackage, apkActivity;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        apkInfoGetters = [function callee$1$0() {
          var apkanalyzerPath;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _helpersJs.getApkanalyzerForOs)(this));

              case 2:
                apkanalyzerPath = context$2$0.sent;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(extractApkInfoWithApkanalyzer(localApk, apkanalyzerPath));

              case 5:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 6:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.initAapt());

              case 2:
                context$2$0.next = 4;
                return _regeneratorRuntime.awrap(extractApkInfoWithApkTools(localApk, this.binaries.aapt, this.jars['appium_apk_tools.jar'], this.tmpDir));

              case 4:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }];
        savedError = undefined;
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 5;
        _iterator2 = _getIterator(apkInfoGetters);

      case 7:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 27;
          break;
        }

        infoGetter = _step2.value;
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(infoGetter());

      case 12:
        _ref2 = context$1$0.sent;
        apkPackage = _ref2.apkPackage;
        apkActivity = _ref2.apkActivity;

        _loggerJs2['default'].info('Package name: \'' + apkPackage + '\'');
        _loggerJs2['default'].info('Main activity name: \'' + apkActivity + '\'');
        return context$1$0.abrupt('return', { apkPackage: apkPackage, apkActivity: apkActivity });

      case 20:
        context$1$0.prev = 20;
        context$1$0.t0 = context$1$0['catch'](9);

        if (infoGetter !== _lodash2['default'].last(apkInfoGetters)) {
          _loggerJs2['default'].info('Using the alternative activity name detection method ' + ('because of: ' + context$1$0.t0.message));
        }
        savedError = context$1$0.t0;

      case 24:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 7;
        break;

      case 27:
        context$1$0.next = 33;
        break;

      case 29:
        context$1$0.prev = 29;
        context$1$0.t1 = context$1$0['catch'](5);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t1;

      case 33:
        context$1$0.prev = 33;
        context$1$0.prev = 34;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 36:
        context$1$0.prev = 36;

        if (!_didIteratorError2) {
          context$1$0.next = 39;
          break;
        }

        throw _iteratorError2;

      case 39:
        return context$1$0.finish(36);

      case 40:
        return context$1$0.finish(33);

      case 41:
        throw new Error('packageAndLaunchActivityFromManifest failed. ' + ('Original error: ' + savedError.message) + (savedError.stderr ? '; StdErr: ' + savedError.stderr : ''));

      case 42:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 29, 33, 41], [9, 20], [34,, 36, 40]]);
};

/**
 * Extract target SDK version from application manifest.
 *
 * @param {string} localApk - The full path to application package.
 * @return {number} The version of the target SDK.
 * @throws {error} If there was an error while getting the data from the given
 *                 application package.
 */
manifestMethods.targetSdkVersionFromManifest = function callee$0$0(localApk) {
  var args, output, _ref3, stdout, targetSdkVersion;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 2:
        _loggerJs2['default'].info("Extracting package and launch activity from manifest");
        args = ['dump', 'badging', localApk];
        output = undefined;
        context$1$0.prev = 5;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, args));

      case 8:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;

        output = stdout;
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](5);
        throw new Error('fetching targetSdkVersion from local APK failed. Original error: ' + context$1$0.t0.message);

      case 16:
        targetSdkVersion = new RegExp(/targetSdkVersion:'([^']+)'/g).exec(output);

        if (targetSdkVersion) {
          context$1$0.next = 19;
          break;
        }

        throw new Error('targetSdkVersion is not specified in the application.');

      case 19:
        return context$1$0.abrupt('return', parseInt(targetSdkVersion[1], 10));

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 13]]);
};

/**
 * Extract target SDK version from package information.
 *
 * @param {string} pkg - The class name of the package installed on the device under test.
 * @return {number} The version of the target SDK.
 */
manifestMethods.targetSdkVersionUsingPKG = function callee$0$0(pkg) {
  var stdout, targetSdkVersion;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'package', pkg]));

      case 2:
        stdout = context$1$0.sent;
        targetSdkVersion = new RegExp(/targetSdk=([^\s\s]+)/g).exec(stdout);

        if (targetSdkVersion && targetSdkVersion.length >= 2) {
          targetSdkVersion = targetSdkVersion[1];
        } else {
          // targetSdk not found in the dump, assigning 0 to targetSdkVersion
          targetSdkVersion = 0;
        }
        return context$1$0.abrupt('return', parseInt(targetSdkVersion, 10));

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Create binary representation of package manifest (usually AndroidManifest.xml).
 * `${manifest}.apk` file will be created as the result of this method
 * containing the compiled manifest.
 *
 * @param {string} manifest - Full path to the initial manifest template
 * @param {string} manifestPackage - The name of the manifest package
 * @param {string} targetPackage - The name of the destination package
 */
manifestMethods.compileManifest = function callee$0$0(manifest, manifestPackage, targetPackage) {
  var _ref4, platform, platformPath;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Compiling manifest ' + manifest);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _helpersJs.getAndroidPlatformAndPath)());

      case 3:
        _ref4 = context$1$0.sent;
        platform = _ref4.platform;
        platformPath = _ref4.platformPath;

        if (platform) {
          context$1$0.next = 8;
          break;
        }

        throw new Error("Required platform doesn't exist (API level >= 17)");

      case 8:
        _loggerJs2['default'].debug('Compiling manifest.');
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 11:
        context$1$0.prev = 11;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['package', '-M', manifest, '--rename-manifest-package', manifestPackage, '--rename-instrumentation-target-package', targetPackage, '-I', _path2['default'].resolve(platformPath, 'android.jar'), '-F', manifest + '.apk', '-f']));

      case 14:
        _loggerJs2['default'].debug("Compiled manifest");
        context$1$0.next = 20;
        break;

      case 17:
        context$1$0.prev = 17;
        context$1$0.t0 = context$1$0['catch'](11);
        throw new Error('Error compiling manifest. Original error: ' + context$1$0.t0.message);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[11, 17]]);
};

/**
 * Replace/insert the specially precompiled manifest file into the
 * particular package.
 *
 * @param {string} manifest - Full path to the precompiled manifest
 *                            created by `compileManifest` method call
 *                            without .apk extension
 * @param {string} srcApk - Full path to the existing valid application package, where
 *                          this manifest has to be insetred to. This package
 *                          will NOT be modified.
 * @param {string} dstApk - Full path to the resulting package.
 *                          The file will be overriden if it already exists.
 */
manifestMethods.insertManifest = function callee$0$0(manifest, srcApk, dstApk) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Inserting manifest, src: ' + srcApk + ' dst: ' + dstApk);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _helpersJs.unzipFile)(manifest + '.apk'));

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.copyFile(srcApk, dstApk));

      case 7:
        _loggerJs2['default'].debug("Testing new tmp apk");
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _helpersJs.assertZipArchive)(dstApk));

      case 10:
        _loggerJs2['default'].debug("Moving manifest");
        context$1$0.prev = 11;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['remove', dstApk, _path2['default'].basename(manifest)]));

      case 14:
        context$1$0.next = 18;
        break;

      case 16:
        context$1$0.prev = 16;
        context$1$0.t0 = context$1$0['catch'](11);

      case 18:
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['add', dstApk, _path2['default'].basename(manifest)], { cwd: _path2['default'].dirname(manifest) }));

      case 20:
        _loggerJs2['default'].debug("Inserted manifest.");

      case 21:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[11, 16]]);
};

/**
 * Check whether package manifest contains Internet permissions.
 *
 * @param {string} localApk - The full path to application package.
 * @return {boolean} True if the manifest requires Internet access permission.
 */
manifestMethods.hasInternetPermissionFromManifest = function callee$0$0(localApk) {
  var _ref5, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 2:
        _loggerJs2['default'].debug('Checking if \'' + localApk + '\' requires internet access permission in the manifest');
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['dump', 'badging', localApk]));

      case 6:
        _ref5 = context$1$0.sent;
        stdout = _ref5.stdout;
        return context$1$0.abrupt('return', new RegExp(/uses-permission:.*'android.permission.INTERNET'/).test(stdout));

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);
        throw new Error('Cannot check if \'' + localApk + '\' requires internet access permission. ' + ('Original error: ' + context$1$0.t0.message));

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 11]]);
};

exports['default'] = manifestMethods;
module.exports = exports['default'];

// process must be an attribute after application.

// this is an application attribute process.

// Look for activity or activity-alias with
// action == android.intent.action.MAIN and
// category == android.intent.category.LAUNCHER
// descendants
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9hbmRyb2lkLW1hbmlmZXN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs0QkFBcUIsY0FBYzs7d0JBQ25CLGNBQWM7Ozs7eUJBRU0sZUFBZTs7NkJBQ2hDLGdCQUFnQjs7c0JBQ3JCLFFBQVE7Ozs7b0JBQ0wsTUFBTTs7OztzQkFDSixRQUFROzs7O3FCQUNULE9BQU87Ozs7QUFFekIsSUFBSSxlQUFlLEdBQUcsRUFBRSxDQUFDOzs7Ozs7QUFNekIsZUFBZSxDQUFDLG1CQUFtQixHQUFHLG9CQUFnQixRQUFRO01BR3hELElBQUksUUFDSCxNQUFNLEVBQ1AsTUFBTSxFQUNOLEtBQUssRUFDTCxnQkFBZ0IsRUFDaEIsZ0JBQWdCLEVBQ2hCLGNBQWMsRUFDZCxZQUFZLGtGQUNQLElBQUksRUFNTCxZQUFZLEVBS1osUUFBTzs7Ozs7O3lDQXJCVCxJQUFJLENBQUMsUUFBUSxFQUFFOzs7QUFDckIsOEJBQUksSUFBSSxDQUFDLGtDQUFrQyxDQUFDLENBQUM7QUFDekMsWUFBSSxHQUFHLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUscUJBQXFCLENBQUM7O3lDQUMxQyx3QkFBSyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7Ozs7QUFBOUMsY0FBTSxRQUFOLE1BQU07QUFDUCxjQUFNLEdBQUcsSUFBSTtBQUNiLGFBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUMxQix3QkFBZ0IsR0FBRyxJQUFJLE1BQU0sQ0FBQyxrQ0FBa0MsQ0FBQztBQUNqRSx3QkFBZ0IsR0FBRyxLQUFLO0FBQ3hCLHNCQUFjLEdBQUcsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDO0FBQ3ZDLG9CQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsaURBQWlELENBQUM7Ozs7O2lDQUMvRCxLQUFLOzs7Ozs7OztBQUFiLFlBQUk7O1lBQ04sZ0JBQWdCOzs7OztBQUNuQixZQUFJLGdCQUFnQixD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ZUFBZSIsImZpbGUiOiJsaWIvdG9vbHMvYW5kcm9pZC1tYW5pZmVzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZ2V0QW5kcm9pZFBsYXRmb3JtQW5kUGF0aCwgdW56aXBGaWxlLCBhc3NlcnRaaXBBcmNoaXZlLFxuICAgICAgICAgZ2V0QXBrYW5hbHl6ZXJGb3JPcyB9IGZyb20gJy4uL2hlbHBlcnMuanMnO1xuaW1wb3J0IHsgZnMgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeG1sZG9tIGZyb20gJ3htbGRvbSc7XG5pbXBvcnQgeHBhdGggZnJvbSAneHBhdGgnO1xuXG5sZXQgbWFuaWZlc3RNZXRob2RzID0ge307XG5cbi8vIGFuZHJvaWQ6cHJvY2Vzcz0gbWF5IGJlIGRlZmluZWQgaW4gQW5kcm9pZE1hbmlmZXN0LnhtbFxuLy8gaHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvYW5kcm9pZC9SLmF0dHIuaHRtbCNwcm9jZXNzXG4vLyBub3RlIHRoYXQgdGhlIHByb2Nlc3MgbmFtZSB3aGVuIHVzZWQgd2l0aCBwcyBtdXN0IGJlIHRydW5jYXRlZCB0byB0aGUgbGFzdCAxNSBjaGFyc1xuLy8gcHMgLWMgY29tLmV4YW1wbGUuYW5kcm9pZC5hcGlzIGJlY29tZXMgcHMgLWMgbGUuYW5kcm9pZC5hcGlzXG5tYW5pZmVzdE1ldGhvZHMucHJvY2Vzc0Zyb21NYW5pZmVzdCA9IGFzeW5jIGZ1bmN0aW9uIChsb2NhbEFwaykge1xuICBhd2FpdCB0aGlzLmluaXRBYXB0KCk7XG4gIGxvZy5pbmZvKFwiUmV0cmlldmluZyBwcm9jZXNzIGZyb20gbWFuaWZlc3RcIik7XG4gIGxldCBhcmdzID0gWydkdW1wJywgJ3htbHRyZWUnLCBsb2NhbEFwaywgJ0FuZHJvaWRNYW5pZmVzdC54bWwnXTtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmJpbmFyaWVzLmFhcHQsIGFyZ3MpO1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KFwiXFxuXCIpO1xuICBsZXQgYXBwbGljYXRpb25SZWdleCA9IG5ldyBSZWdFeHAoL1xccytFOiBhcHBsaWNhdGlvbiBcXChsaW5lPVxcZCtcXCkuKi8pO1xuICBsZXQgYXBwbGljYXRpb25Gb3VuZCA9IGZhbHNlO1xuICBsZXQgYXR0cmlidXRlUmVnZXggPSBuZXcgUmVnRXhwKC9cXHMrQTogLisvKTtcbiAgbGV0IHByb2Nlc3NSZWdleCA9IG5ldyBSZWdFeHAoL1xccytBOiBhbmRyb2lkOnByb2Nlc3NcXCgweDAxMDEwMDExXFwpPVwiKFteXCJdKykuKlwiLyk7XG4gIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBpZiAoIWFwcGxpY2F0aW9uRm91bmQpIHtcbiAgICAgIGlmIChhcHBsaWNhdGlvblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgYXBwbGljYXRpb25Gb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBub3RBdHRyaWJ1dGUgPSAhYXR0cmlidXRlUmVnZXgudGVzdChsaW5lKTtcbiAgICAgIC8vIHByb2Nlc3MgbXVzdCBiZSBhbiBhdHRyaWJ1dGUgYWZ0ZXIgYXBwbGljYXRpb24uXG4gICAgICBpZiAobm90QXR0cmlidXRlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IHByb2Nlc3MgPSBwcm9jZXNzUmVnZXguZXhlYyhsaW5lKTtcbiAgICAgIC8vIHRoaXMgaXMgYW4gYXBwbGljYXRpb24gYXR0cmlidXRlIHByb2Nlc3MuXG4gICAgICBpZiAocHJvY2VzcyAmJiBwcm9jZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc1sxXTtcbiAgICAgICAgLy8gbXVzdCB0cmltIHRvIGxhc3QgMTUgZm9yIGFuZHJvaWQncyBwcyBiaW5hcnlcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxNSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHIocmVzdWx0Lmxlbmd0aCAtIDE1KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQVBLSW5mb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGFwa1BhY2thZ2UgLSBUaGUgbmFtZSBvZiBhcHBsaWNhdGlvbiBwYWNrYWdlLCBmb3IgZXhhbXBsZSAnY29tLmFjbWUuYXBwJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhcGtBY3Rpdml0eSAtIFRoZSBuYW1lIG9mIG1haW4gYXBwbGljYXRpb24gYWN0aXZpdHkuXG4gKi9cblxuIC8qKlxuICogRXh0cmFjdCBwYWNrYWdlIGFuZCBtYWluIGFjdGl2aXR5IG5hbWUgZnJvbSBhcHBsaWNhdGlvbiBtYW5pZmVzdCB1c2luZ1xuICogdGhlIGN1c3RvbSBhcGsgdG9vbHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsQXBrIC0gVGhlIGZ1bGwgcGF0aCB0byBhcHBsaWNhdGlvbiBwYWNrYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGFhcHRQYXRoIC0gVGhlIGZ1bGwgcGF0aCB0byBhcHB0IGJpbmFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBqYXJQYXRoIC0gVGhlIGZ1bGwgcGF0aCB0byBhcHBpdW1fYXBrX3Rvb2xzLmphciB1dGlsaXR5XG4gKiBAcGFyYW0ge3N0cmluZ30gdG1wUm9vdCAtIFRoZSBmdWxsIHBhdGggdG8gdGhlIGNsYXNzLXdpZGUgdGVtcG9yYXJ5IGZvbGRlci5cbiAqIEByZXR1cm4ge0FQS0luZm99IFRoZSBwYXJzZWQgYXBwbGljYXRpb24gaW5mby5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgZGF0YSBmcm9tIHRoZSBnaXZlblxuICogICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIHBhY2thZ2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RBcGtJbmZvV2l0aEFwa1Rvb2xzIChsb2NhbEFwaywgYWFwdFBhdGgsIGphclBhdGgsIHRtcFJvb3QpIHtcbiAgbG9nLmluZm8oXCJFeHRyYWN0aW5nIHBhY2thZ2UgYW5kIGxhdW5jaCBhY3Rpdml0eSBmcm9tIG1hbmlmZXN0XCIpO1xuICBsZXQgYXJncyA9IFsnZHVtcCcsICdiYWRnaW5nJywgbG9jYWxBcGtdO1xuICBsZXQgc3Rkb3V0ID0gKGF3YWl0IGV4ZWMoYWFwdFBhdGgsIGFyZ3MpKS5zdGRvdXQ7XG4gIGxldCBhcGtQYWNrYWdlID0gbmV3IFJlZ0V4cCgvcGFja2FnZTogbmFtZT0nKFteJ10rKScvZykuZXhlYyhzdGRvdXQpO1xuICBpZiAoIWFwa1BhY2thZ2UgfHwgYXBrUGFja2FnZS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgcGFja2FnZSBuYW1lIGZyb20gYCArXG4gICAgICBgJyR7Xy5qb2luKFthYXB0UGF0aCwgJ2R1bXAnLCAnYmFkZ2luZycsICdcIicgKyBsb2NhbEFwayArICdcIiddLCAnICcpfScgY29tbWFuZCAgb3V0cHV0YCk7XG4gIH1cbiAgYXBrUGFja2FnZSA9IGFwa1BhY2thZ2VbMV07XG4gIGxldCBhcGtBY3Rpdml0eSA9IG5ldyBSZWdFeHAoL2xhdW5jaGFibGUtYWN0aXZpdHk6IG5hbWU9JyhbXiddKyknL2cpLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKGFwa0FjdGl2aXR5ICYmIGFwa0FjdGl2aXR5Lmxlbmd0aCA+PSAyKSB7XG4gICAgYXBrQWN0aXZpdHkgPSBhcGtBY3Rpdml0eVsxXTtcbiAgICByZXR1cm4ge2Fwa1BhY2thZ2UsIGFwa0FjdGl2aXR5fTtcbiAgfVxuXG4gIGxldCBvdXRwdXRQYXRoID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsIGFwa1BhY2thZ2UpO1xuICBsZXQgZ2V0TGF1bmNoQWN0aXZpdHkgPSBbXG4gICAgJy1qYXInLCBqYXJQYXRoLFxuICAgICdwcmludExhdW5jaEFjdGl2aXR5JywgbG9jYWxBcGssXG4gICAgb3V0cHV0UGF0aFxuICBdO1xuICBjb25zdCBvdXRwdXQgPSBhd2FpdCBleGVjKCdqYXZhJywgZ2V0TGF1bmNoQWN0aXZpdHkpO1xuICBpZiAob3V0cHV0LnN0ZGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIGxhdW5jaEFjdGl2aXR5IGZyb20gbWFuaWZlc3Q6ICR7b3V0cHV0LnN0ZGVycn1gKTtcbiAgfVxuICBzdGRvdXQgPSBvdXRwdXQuc3Rkb3V0O1xuICBsZXQgYWN0ID0gbmV3IFJlZ0V4cCgvTGF1bmNoIGFjdGl2aXR5IHBhcnNlZDooW14nXSspL2cpLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKGFjdCAmJiBhY3QubGVuZ3RoID49IDIpIHtcbiAgICBhcGtBY3Rpdml0eSA9IGFjdFsxXTtcbiAgICByZXR1cm4ge2Fwa1BhY2thZ2UsIGFwa0FjdGl2aXR5fTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBtYWluIGFjdGl2aXR5IG5hbWUgZnJvbSAnJHtzdGRvdXR9JyBjb21tYW5kICBvdXRwdXRgKTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHBhY2thZ2UgYW5kIG1haW4gYWN0aXZpdHkgbmFtZSBmcm9tIGFwcGxpY2F0aW9uIG1hbmlmZXN0IHVzaW5nXG4gKiBhcGthbmFseXplciB0b29sLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbEFwayAtIFRoZSBmdWxsIHBhdGggdG8gYXBwbGljYXRpb24gcGFja2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGthbmFseXplclBhdGggLSBUaGUgZnVsbCBwYXRoIHRvIGFwa2FuYWx5emVyIHRvb2wuXG4gKiBAcmV0dXJuIHtBUEtJbmZvfSBUaGUgcGFyc2VkIGFwcGxpY2F0aW9uIGluZm8uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgZ2l2ZW5cbiAqICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBwYWNrYWdlIG9yIGlmIHRoZSB0b29sIGl0c2VsZlxuICogICAgICAgICAgICAgICAgIGlzIG5vdCBwcmVzZW50IG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEFwa0luZm9XaXRoQXBrYW5hbHl6ZXIgKGxvY2FsQXBrLCBhcGthbmFseXplclBhdGgpIHtcbiAgY29uc3QgYXJncyA9IFsnLWgnLCAnbWFuaWZlc3QnLCAncHJpbnQnLCBsb2NhbEFwa107XG4gIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgJyR7YXBrYW5hbHl6ZXJQYXRofScgd2l0aCBhcmdzICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gIGNvbnN0IG1hbmlmZXN0WG1sID0gKGF3YWl0IGV4ZWMoYXBrYW5hbHl6ZXJQYXRoLCBhcmdzLCB7XG4gICAgc2hlbGw6IHRydWUsXG4gICAgY3dkOiBwYXRoLmRpcm5hbWUoYXBrYW5hbHl6ZXJQYXRoKVxuICB9KSkuc3Rkb3V0O1xuICBjb25zdCBkb2MgPSBuZXcgeG1sZG9tLkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhtYW5pZmVzdFhtbCk7XG4gIGNvbnN0IGFwa1BhY2thZ2VBdHRyaWJ1dGUgPSB4cGF0aC5zZWxlY3QxKCcvL21hbmlmZXN0L0BwYWNrYWdlJywgZG9jKTtcbiAgaWYgKCFhcGtQYWNrYWdlQXR0cmlidXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgcGFja2FnZSBuYW1lIGZyb20gJHttYW5pZmVzdFhtbH1gKTtcbiAgfVxuICBjb25zdCBhcGtQYWNrYWdlID0gYXBrUGFja2FnZUF0dHJpYnV0ZS52YWx1ZTtcbiAgLy8gTG9vayBmb3IgYWN0aXZpdHkgb3IgYWN0aXZpdHktYWxpYXMgd2l0aFxuICAvLyBhY3Rpb24gPT0gYW5kcm9pZC5pbnRlbnQuYWN0aW9uLk1BSU4gYW5kXG4gIC8vIGNhdGVnb3J5ID09IGFuZHJvaWQuaW50ZW50LmNhdGVnb3J5LkxBVU5DSEVSXG4gIC8vIGRlc2NlbmRhbnRzXG4gIGNvbnN0IGFwa0FjdGl2aXR5QXR0cmlidXRlID0geHBhdGguc2VsZWN0MShcbiAgICBcIi8vYXBwbGljYXRpb24vKltzdGFydHMtd2l0aChuYW1lKCksICdhY3Rpdml0eScpIFwiICtcbiAgICBcImFuZCAuLy9hY3Rpb25bQCpbbG9jYWwtbmFtZSgpPSduYW1lJyBhbmQgLj0nYW5kcm9pZC5pbnRlbnQuYWN0aW9uLk1BSU4nXV0gXCIgK1xuICAgIFwiYW5kIC4vL2NhdGVnb3J5W0AqW2xvY2FsLW5hbWUoKT0nbmFtZScgYW5kIC49J2FuZHJvaWQuaW50ZW50LmNhdGVnb3J5LkxBVU5DSEVSJ11dXVwiICtcbiAgICBcIi9AKltsb2NhbC1uYW1lKCk9J25hbWUnXVwiLCBkb2MpO1xuICBpZiAoIWFwa0FjdGl2aXR5QXR0cmlidXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgbWFpbiBhY3Rpdml0eSBuYW1lIGZyb20gJHttYW5pZmVzdFhtbH1gKTtcbiAgfVxuICBjb25zdCBhcGtBY3Rpdml0eSA9IGFwa0FjdGl2aXR5QXR0cmlidXRlLnZhbHVlO1xuICByZXR1cm4ge2Fwa1BhY2thZ2UsIGFwa0FjdGl2aXR5fTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHBhY2thZ2UgYW5kIG1haW4gYWN0aXZpdHkgbmFtZSBmcm9tIGFwcGxpY2F0aW9uIG1hbmlmZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbEFwayAtIFRoZSBmdWxsIHBhdGggdG8gYXBwbGljYXRpb24gcGFja2FnZS5cbiAqIEByZXR1cm4ge0FQS0luZm99IFRoZSBwYXJzZWQgYXBwbGljYXRpb24gaW5mby5cbiAqIEB0aHJvd3Mge2Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgZGF0YSBmcm9tIHRoZSBnaXZlblxuICogICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIHBhY2thZ2UuXG4gKi9cbm1hbmlmZXN0TWV0aG9kcy5wYWNrYWdlQW5kTGF1bmNoQWN0aXZpdHlGcm9tTWFuaWZlc3QgPSBhc3luYyBmdW5jdGlvbiAobG9jYWxBcGspIHtcbiAgY29uc3QgYXBrSW5mb0dldHRlcnMgPSBbXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBrYW5hbHl6ZXJQYXRoID0gYXdhaXQgZ2V0QXBrYW5hbHl6ZXJGb3JPcyh0aGlzKTtcbiAgICAgIHJldHVybiBhd2FpdCBleHRyYWN0QXBrSW5mb1dpdGhBcGthbmFseXplcihsb2NhbEFwaywgYXBrYW5hbHl6ZXJQYXRoKTtcbiAgICB9LFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdEFhcHQoKTtcbiAgICAgIHJldHVybiBhd2FpdCBleHRyYWN0QXBrSW5mb1dpdGhBcGtUb29scyhsb2NhbEFwayxcbiAgICAgICAgdGhpcy5iaW5hcmllcy5hYXB0LCB0aGlzLmphcnNbJ2FwcGl1bV9hcGtfdG9vbHMuamFyJ10sIHRoaXMudG1wRGlyKTtcbiAgICB9LFxuICBdO1xuXG4gIGxldCBzYXZlZEVycm9yO1xuICBmb3IgKGNvbnN0IGluZm9HZXR0ZXIgb2YgYXBrSW5mb0dldHRlcnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge2Fwa1BhY2thZ2UsIGFwa0FjdGl2aXR5fSA9IGF3YWl0IGluZm9HZXR0ZXIoKTtcbiAgICAgIGxvZy5pbmZvKGBQYWNrYWdlIG5hbWU6ICcke2Fwa1BhY2thZ2V9J2ApO1xuICAgICAgbG9nLmluZm8oYE1haW4gYWN0aXZpdHkgbmFtZTogJyR7YXBrQWN0aXZpdHl9J2ApO1xuICAgICAgcmV0dXJuIHthcGtQYWNrYWdlLCBhcGtBY3Rpdml0eX07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGluZm9HZXR0ZXIgIT09IF8ubGFzdChhcGtJbmZvR2V0dGVycykpIHtcbiAgICAgICAgbG9nLmluZm8oYFVzaW5nIHRoZSBhbHRlcm5hdGl2ZSBhY3Rpdml0eSBuYW1lIGRldGVjdGlvbiBtZXRob2QgYCtcbiAgICAgICAgICAgICAgICAgYGJlY2F1c2Ugb2Y6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgc2F2ZWRFcnJvciA9IGU7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgcGFja2FnZUFuZExhdW5jaEFjdGl2aXR5RnJvbU1hbmlmZXN0IGZhaWxlZC4gYCArXG4gICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7c2F2ZWRFcnJvci5tZXNzYWdlfWAgK1xuICAgICAgICAgICAgICAgICAgKHNhdmVkRXJyb3Iuc3RkZXJyID8gYDsgU3RkRXJyOiAke3NhdmVkRXJyb3Iuc3RkZXJyfWAgOiAnJykpO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0IHRhcmdldCBTREsgdmVyc2lvbiBmcm9tIGFwcGxpY2F0aW9uIG1hbmlmZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbEFwayAtIFRoZSBmdWxsIHBhdGggdG8gYXBwbGljYXRpb24gcGFja2FnZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZlcnNpb24gb2YgdGhlIHRhcmdldCBTREsuXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgZ2l2ZW5cbiAqICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBwYWNrYWdlLlxuICovXG5tYW5pZmVzdE1ldGhvZHMudGFyZ2V0U2RrVmVyc2lvbkZyb21NYW5pZmVzdCA9IGFzeW5jIGZ1bmN0aW9uIChsb2NhbEFwaykge1xuICBhd2FpdCB0aGlzLmluaXRBYXB0KCk7XG4gIGxvZy5pbmZvKFwiRXh0cmFjdGluZyBwYWNrYWdlIGFuZCBsYXVuY2ggYWN0aXZpdHkgZnJvbSBtYW5pZmVzdFwiKTtcbiAgbGV0IGFyZ3MgPSBbJ2R1bXAnLCAnYmFkZ2luZycsIGxvY2FsQXBrXTtcbiAgbGV0IG91dHB1dDtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuYmluYXJpZXMuYWFwdCwgYXJncyk7XG4gICAgb3V0cHV0ID0gc3Rkb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBmZXRjaGluZyB0YXJnZXRTZGtWZXJzaW9uIGZyb20gbG9jYWwgQVBLIGZhaWxlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG4gIGxldCB0YXJnZXRTZGtWZXJzaW9uID0gbmV3IFJlZ0V4cCgvdGFyZ2V0U2RrVmVyc2lvbjonKFteJ10rKScvZykuZXhlYyhvdXRwdXQpO1xuICBpZiAoIXRhcmdldFNka1ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHRhcmdldFNka1ZlcnNpb24gaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYXBwbGljYXRpb24uYCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KHRhcmdldFNka1ZlcnNpb25bMV0sIDEwKTtcbn07XG5cbi8qKlxuICogRXh0cmFjdCB0YXJnZXQgU0RLIHZlcnNpb24gZnJvbSBwYWNrYWdlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgcGFja2FnZSBpbnN0YWxsZWQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmVyc2lvbiBvZiB0aGUgdGFyZ2V0IFNESy5cbiAqL1xubWFuaWZlc3RNZXRob2RzLnRhcmdldFNka1ZlcnNpb25Vc2luZ1BLRyA9IGFzeW5jIGZ1bmN0aW9uIChwa2cpIHtcbiAgbGV0IHN0ZG91dCA9ICBhd2FpdCB0aGlzLnNoZWxsKFsnZHVtcHN5cycsICdwYWNrYWdlJywgcGtnXSk7XG4gIGxldCB0YXJnZXRTZGtWZXJzaW9uID0gbmV3IFJlZ0V4cCgvdGFyZ2V0U2RrPShbXlxcc1xcc10rKS9nKS5leGVjKHN0ZG91dCk7XG4gIGlmICh0YXJnZXRTZGtWZXJzaW9uICYmIHRhcmdldFNka1ZlcnNpb24ubGVuZ3RoID49IDIpIHtcbiAgICB0YXJnZXRTZGtWZXJzaW9uID0gdGFyZ2V0U2RrVmVyc2lvblsxXTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0YXJnZXRTZGsgbm90IGZvdW5kIGluIHRoZSBkdW1wLCBhc3NpZ25pbmcgMCB0byB0YXJnZXRTZGtWZXJzaW9uXG4gICAgdGFyZ2V0U2RrVmVyc2lvbiA9IDA7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KHRhcmdldFNka1ZlcnNpb24sIDEwKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBwYWNrYWdlIG1hbmlmZXN0ICh1c3VhbGx5IEFuZHJvaWRNYW5pZmVzdC54bWwpLlxuICogYCR7bWFuaWZlc3R9LmFwa2AgZmlsZSB3aWxsIGJlIGNyZWF0ZWQgYXMgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZFxuICogY29udGFpbmluZyB0aGUgY29tcGlsZWQgbWFuaWZlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hbmlmZXN0IC0gRnVsbCBwYXRoIHRvIHRoZSBpbml0aWFsIG1hbmlmZXN0IHRlbXBsYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFuaWZlc3RQYWNrYWdlIC0gVGhlIG5hbWUgb2YgdGhlIG1hbmlmZXN0IHBhY2thZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRQYWNrYWdlIC0gVGhlIG5hbWUgb2YgdGhlIGRlc3RpbmF0aW9uIHBhY2thZ2VcbiAqL1xubWFuaWZlc3RNZXRob2RzLmNvbXBpbGVNYW5pZmVzdCA9IGFzeW5jIGZ1bmN0aW9uIChtYW5pZmVzdCwgbWFuaWZlc3RQYWNrYWdlLCB0YXJnZXRQYWNrYWdlKSB7XG4gIGxvZy5kZWJ1ZyhgQ29tcGlsaW5nIG1hbmlmZXN0ICR7bWFuaWZlc3R9YCk7XG4gIGxldCB7cGxhdGZvcm0sIHBsYXRmb3JtUGF0aH0gPSBhd2FpdCBnZXRBbmRyb2lkUGxhdGZvcm1BbmRQYXRoKCk7XG4gIGlmICghcGxhdGZvcm0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBwbGF0Zm9ybSBkb2Vzbid0IGV4aXN0IChBUEkgbGV2ZWwgPj0gMTcpXCIpO1xuICB9XG4gIGxvZy5kZWJ1ZygnQ29tcGlsaW5nIG1hbmlmZXN0LicpO1xuICBhd2FpdCB0aGlzLmluaXRBYXB0KCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyh0aGlzLmJpbmFyaWVzLmFhcHQsIFtcbiAgICAgICdwYWNrYWdlJyxcbiAgICAgICctTScsIG1hbmlmZXN0LFxuICAgICAgJy0tcmVuYW1lLW1hbmlmZXN0LXBhY2thZ2UnLCBtYW5pZmVzdFBhY2thZ2UsXG4gICAgICAnLS1yZW5hbWUtaW5zdHJ1bWVudGF0aW9uLXRhcmdldC1wYWNrYWdlJywgdGFyZ2V0UGFja2FnZSxcbiAgICAgICctSScsIHBhdGgucmVzb2x2ZShwbGF0Zm9ybVBhdGgsICdhbmRyb2lkLmphcicpLFxuICAgICAgJy1GJywgYCR7bWFuaWZlc3R9LmFwa2AsXG4gICAgICAnLWYnLFxuICAgIF0pO1xuICAgIGxvZy5kZWJ1ZyhcIkNvbXBpbGVkIG1hbmlmZXN0XCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNvbXBpbGluZyBtYW5pZmVzdC4gT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZS9pbnNlcnQgdGhlIHNwZWNpYWxseSBwcmVjb21waWxlZCBtYW5pZmVzdCBmaWxlIGludG8gdGhlXG4gKiBwYXJ0aWN1bGFyIHBhY2thZ2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hbmlmZXN0IC0gRnVsbCBwYXRoIHRvIHRoZSBwcmVjb21waWxlZCBtYW5pZmVzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZCBieSBgY29tcGlsZU1hbmlmZXN0YCBtZXRob2QgY2FsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCAuYXBrIGV4dGVuc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IHNyY0FwayAtIEZ1bGwgcGF0aCB0byB0aGUgZXhpc3RpbmcgdmFsaWQgYXBwbGljYXRpb24gcGFja2FnZSwgd2hlcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIG1hbmlmZXN0IGhhcyB0byBiZSBpbnNldHJlZCB0by4gVGhpcyBwYWNrYWdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBOT1QgYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZHN0QXBrIC0gRnVsbCBwYXRoIHRvIHRoZSByZXN1bHRpbmcgcGFja2FnZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZmlsZSB3aWxsIGJlIG92ZXJyaWRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAqL1xubWFuaWZlc3RNZXRob2RzLmluc2VydE1hbmlmZXN0ID0gYXN5bmMgZnVuY3Rpb24gKG1hbmlmZXN0LCBzcmNBcGssIGRzdEFwaykge1xuICBsb2cuZGVidWcoYEluc2VydGluZyBtYW5pZmVzdCwgc3JjOiAke3NyY0Fwa30gZHN0OiAke2RzdEFwa31gKTtcbiAgYXdhaXQgdGhpcy5pbml0QWFwdCgpO1xuICBhd2FpdCB1bnppcEZpbGUoYCR7bWFuaWZlc3R9LmFwa2ApO1xuICBhd2FpdCBmcy5jb3B5RmlsZShzcmNBcGssIGRzdEFwayk7XG4gIGxvZy5kZWJ1ZyhcIlRlc3RpbmcgbmV3IHRtcCBhcGtcIik7XG4gIGF3YWl0IGFzc2VydFppcEFyY2hpdmUoZHN0QXBrKTtcbiAgbG9nLmRlYnVnKFwiTW92aW5nIG1hbmlmZXN0XCIpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWModGhpcy5iaW5hcmllcy5hYXB0LCBbXG4gICAgICAncmVtb3ZlJywgZHN0QXBrLCBwYXRoLmJhc2VuYW1lKG1hbmlmZXN0KVxuICAgIF0pO1xuICB9IGNhdGNoIChpZ24pIHt9XG4gIGF3YWl0IGV4ZWModGhpcy5iaW5hcmllcy5hYXB0LCBbXG4gICAgJ2FkZCcsIGRzdEFwaywgcGF0aC5iYXNlbmFtZShtYW5pZmVzdClcbiAgXSwge2N3ZDogcGF0aC5kaXJuYW1lKG1hbmlmZXN0KX0pO1xuICBsb2cuZGVidWcoXCJJbnNlcnRlZCBtYW5pZmVzdC5cIik7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgcGFja2FnZSBtYW5pZmVzdCBjb250YWlucyBJbnRlcm5ldCBwZXJtaXNzaW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxBcGsgLSBUaGUgZnVsbCBwYXRoIHRvIGFwcGxpY2F0aW9uIHBhY2thZ2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBtYW5pZmVzdCByZXF1aXJlcyBJbnRlcm5ldCBhY2Nlc3MgcGVybWlzc2lvbi5cbiAqL1xubWFuaWZlc3RNZXRob2RzLmhhc0ludGVybmV0UGVybWlzc2lvbkZyb21NYW5pZmVzdCA9IGFzeW5jIGZ1bmN0aW9uIChsb2NhbEFwaykge1xuICBhd2FpdCB0aGlzLmluaXRBYXB0KCk7XG4gIGxvZy5kZWJ1ZyhgQ2hlY2tpbmcgaWYgJyR7bG9jYWxBcGt9JyByZXF1aXJlcyBpbnRlcm5ldCBhY2Nlc3MgcGVybWlzc2lvbiBpbiB0aGUgbWFuaWZlc3RgKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuYmluYXJpZXMuYWFwdCwgWydkdW1wJywgJ2JhZGdpbmcnLCBsb2NhbEFwa10pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKC91c2VzLXBlcm1pc3Npb246LionYW5kcm9pZC5wZXJtaXNzaW9uLklOVEVSTkVUJy8pLnRlc3Qoc3Rkb3V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNoZWNrIGlmICcke2xvY2FsQXBrfScgcmVxdWlyZXMgaW50ZXJuZXQgYWNjZXNzIHBlcm1pc3Npb24uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IG1hbmlmZXN0TWV0aG9kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
